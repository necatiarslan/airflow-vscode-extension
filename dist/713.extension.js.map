{"version":3,"file":"713.extension.js","mappings":"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","sources":["webpack://airflow-vscode-extension/./node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"],"names":["s","S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","f","F","lower","c","noop","MultipartParser","constructor","boundary","this","index","flags","onHeaderEnd","onHeaderField","onHeadersEnd","onHeaderValue","onPartBegin","onPartData","onPartEnd","boundaryChars","ui8a","Uint8Array","length","i","charCodeAt","lookbehind","state","write","data","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","cl","mark","name","clear","callback","callbackSymbol","start","end","undefined","subarray","dataCallback","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error","async","toFormData","Body","ct","test","TypeError","m","match","parser","headerField","headerValue","entryValue","entryName","contentType","filename","entryChunks","formData","decoder","decode","stream","appendToFile","push","appendFileToFormData","file","type","append","appendEntryToFormData","TextDecoder","toLowerCase","slice","lastIndexOf","replace","code","String","fromCharCode","_fileName","chunk"],"sourceRoot":""}