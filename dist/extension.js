/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toISODateString = toISODateString;
exports.toISODateTimeString = toISODateTimeString;
exports.getUri = getUri;
exports.showOutputMessage = showOutputMessage;
exports.logToOutput = logToOutput;
exports.showInfoMessage = showInfoMessage;
exports.showWarningMessage = showWarningMessage;
exports.showErrorMessage = showErrorMessage;
exports.showApiErrorMessage = showApiErrorMessage;
exports.getExtensionVersion = getExtensionVersion;
exports.openFile = openFile;
exports.getDuration = getDuration;
exports.convertMsToTime = convertMsToTime;
exports.isJsonString = isJsonString;
exports.isValidDate = isValidDate;
const vscode = __webpack_require__(1);
const vscode_1 = __webpack_require__(1);
const fs_1 = __webpack_require__(3);
const path_1 = __webpack_require__(4);
let outputChannel;
let logsOutputChannel;
const NEW_LINE = "\n\n";
function toISODateString(date) {
    if (!date) {
        return "";
    }
    return date.toISOString().split('T')[0];
}
function toISODateTimeString(date) {
    if (!date) {
        return "";
    }
    return date.toISOString().replace('T', ' ').substring(0, 19);
}
function getUri(webview, extensionUri, pathList) {
    return webview.asWebviewUri(vscode_1.Uri.joinPath(extensionUri, ...pathList));
}
function showOutputMessage(message, popupMessage = "Results are printed to OUTPUT / Airflow-Extension") {
    if (!outputChannel) {
        outputChannel = vscode.window.createOutputChannel("Airflow-Extension");
    }
    outputChannel.clear();
    if (typeof message === "object") {
        outputChannel.appendLine(JSON.stringify(message, null, 4));
    }
    else {
        outputChannel.appendLine(message);
    }
    outputChannel.show();
    showInfoMessage(popupMessage);
}
function logToOutput(message, error = undefined) {
    const now = new Date().toLocaleString();
    if (!logsOutputChannel) {
        logsOutputChannel = vscode.window.createOutputChannel("Airflow-Log");
    }
    if (typeof message === "object") {
        logsOutputChannel.appendLine("[" + now + "] " + JSON.stringify(message, null, 4));
    }
    else {
        logsOutputChannel.appendLine("[" + now + "] " + message);
    }
    if (error) {
        logsOutputChannel.appendLine(error.name);
        logsOutputChannel.appendLine(error.message);
        if (error.stack) {
            logsOutputChannel.appendLine(error.stack);
        }
    }
}
function showInfoMessage(message) {
    vscode.window.showInformationMessage(message);
}
function showWarningMessage(message) {
    vscode.window.showWarningMessage(message);
}
function showErrorMessage(message, error = undefined) {
    if (error) {
        vscode.window.showErrorMessage(message + NEW_LINE + error.name + NEW_LINE + error.message);
    }
    else {
        vscode.window.showErrorMessage(message);
    }
}
function showApiErrorMessage(message, jsonResult) {
    let preText = "";
    if (jsonResult) {
        if (jsonResult.status === 403) {
            preText = "Permission Denied !!!";
            vscode.window.showErrorMessage(preText);
        }
        else if (jsonResult.status === 401) {
            preText = "Invalid Authentication Info !!!";
            vscode.window.showErrorMessage(preText);
        }
        else if (jsonResult.status === 404) {
            preText = "Resource Not Found !!!";
            vscode.window.showErrorMessage(preText);
        }
        else {
            vscode.window.showErrorMessage(preText);
        }
    }
    else {
        vscode.window.showErrorMessage(message);
    }
}
function getExtensionVersion() {
    const { version: extVersion } = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(__dirname, '..', 'package.json'), { encoding: 'utf8' }));
    return extVersion;
}
function openFile(file) {
    // Use workspace API to open file in editor and show it in column one
    (async () => {
        try {
            const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(file));
            await vscode.window.showTextDocument(doc, { viewColumn: vscode.ViewColumn.One, preview: false });
        }
        catch (err) {
            logToOutput('openFile Error', err);
        }
    })();
}
function padTo2Digits(num) {
    return num.toString().padStart(2, '0');
}
function getDuration(startDate, endDate) {
    if (!startDate) {
        return "";
    }
    if (!endDate || endDate < startDate) {
        endDate = new Date(); //now
    }
    const duration = endDate.valueOf() - startDate.valueOf();
    return (convertMsToTime(duration));
}
function convertMsToTime(milliseconds) {
    let seconds = Math.floor(milliseconds / 1000);
    let minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    seconds = seconds % 60;
    minutes = minutes % 60;
    return `${padTo2Digits(hours)}:${padTo2Digits(minutes)}:${padTo2Digits(seconds)}`;
}
function isJsonString(jsonString) {
    try {
        const json = JSON.parse(jsonString);
        return (typeof json === 'object');
    }
    catch (e) {
        return false;
    }
}
function isValidDate(dateString) {
    const regEx = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateString.match(regEx)) {
        return false; // Invalid format
    }
    const d = new Date(dateString);
    const dNum = d.getTime();
    if (!dNum && dNum !== 0) {
        return false; // NaN value, Invalid date
    }
    return d.toISOString().slice(0, 10) === dateString;
}


/***/ }),
/* 3 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Session = void 0;
const Api_1 = __webpack_require__(6);
const ui = __webpack_require__(2);
class Session {
    constructor(context) {
        this.ServerList = [];
        Session.Current = this;
        this.Context = context;
        this.ExtensionUri = context.extensionUri;
        this.LoadState();
    }
    SaveState() {
        ui.logToOutput('Saving state...');
        this.Context.globalState.update('apiUrl', this.Server?.apiUrl);
        this.Context.globalState.update('apiUserName', this.Server?.apiUserName);
        this.Context.globalState.update('apiPassword', this.Server?.apiPassword);
        this.Context.globalState.update('serverList', this.ServerList);
    }
    LoadState() {
        ui.logToOutput('Loading state...');
        const apiUrlTemp = this.Context.globalState.get('apiUrl') || '';
        const apiUserNameTemp = this.Context.globalState.get('apiUserName') || '';
        const apiPasswordTemp = this.Context.globalState.get('apiPassword') || '';
        if (apiUrlTemp && apiUserNameTemp) {
            this.Server = { apiUrl: apiUrlTemp, apiUserName: apiUserNameTemp, apiPassword: apiPasswordTemp };
            this.Api = new Api_1.AirflowApi(this.Server);
        }
        this.ServerList = this.Context.globalState.get('serverList') || [];
    }
    SetServer(server) {
        this.Server = server;
        this.Api = new Api_1.AirflowApi(this.Server);
        this.SaveState();
    }
    ChangeServer(apiUrl, apiUserName) {
        this.Server = this.ServerList.find((server) => server.apiUrl === apiUrl && server.apiUserName === apiUserName);
        if (this.Server) {
            this.Api = new Api_1.AirflowApi(this.Server);
            this.SaveState();
        }
    }
    RemoveServer(apiUrl, apiUserName) {
        this.ServerList = this.ServerList.filter((server) => !(server.apiUrl === apiUrl && server.apiUserName === apiUserName));
        this.SaveState();
    }
    AddServer(server) {
        const exists = this.ServerList.some((s) => s.apiUrl === server.apiUrl && s.apiUserName === server.apiUserName);
        if (!exists) {
            this.ServerList.push(server);
            this.SaveState();
        }
    }
    TestServer(serverConfig) {
        let api = new Api_1.AirflowApi(serverConfig);
        let result = api.checkConnection();
        return result;
    }
    ClearServers() {
        this.ServerList = [];
        this.Server = undefined;
        this.Api = undefined;
        this.SaveState();
    }
    GetServer(apiUrl, apiUserName) {
        return this.ServerList.find((server) => server.apiUrl === apiUrl && server.apiUserName === apiUserName);
    }
    dispose() {
        Session.Current = undefined;
    }
}
exports.Session = Session;


/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AirflowApi = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const base_64_1 = __webpack_require__(7);
const ui = __webpack_require__(2);
const MethodResult_1 = __webpack_require__(8);
const Telemetry_1 = __webpack_require__(9);
// Wrapper for fetch to handle ESM node-fetch in CommonJS
const fetch = async (url, init) => {
    const module = await Promise.resolve().then(() => __webpack_require__(119));
    return module.default(url, init);
};
class AirflowApi {
    constructor(config) {
        this.config = config;
    }
    get version() {
        if (this.config.apiUrl.includes('v1')) {
            return 'v1';
        }
        if (this.config.apiUrl.includes('v2')) {
            return 'v2';
        }
        return 'unknown';
    }
    async getJwtToken() {
        if (this.jwtToken) {
            return this.jwtToken;
        }
        try {
            const response = await fetch(this.config.apiUrl.replace("/api/v2", "") + '/auth/token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username: this.config.apiUserName, password: this.config.apiPassword }),
            });
            const result = await response.json();
            if (response.status === 201 || response.status === 200) {
                this.jwtToken = result['access_token'];
                return this.jwtToken;
            }
            else {
                ui.logToOutput(`getJwtToken failed: ${response.status} - ${JSON.stringify(result)}`);
            }
        }
        catch (error) {
            ui.logToOutput("getJwtToken Error", error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.getJwtToken.error', { error: error.message });
        }
        return undefined;
    }
    async getHeaders() {
        const headers = {
            'Content-Type': 'application/json'
        };
        if (this.version === 'v1') {
            headers['Authorization'] = 'Basic ' + (0, base_64_1.encode)(`${this.config.apiUserName}:${this.config.apiPassword}`);
        }
        else if (this.version === 'v2') {
            const token = await this.getJwtToken();
            if (token) {
                headers['Authorization'] = 'Bearer ' + token;
            }
            else {
                ui.showWarningMessage('Unable to obtain JWT token for Airflow API v2.');
            }
        }
        return headers;
    }
    async checkConnection() {
        try {
            const headers = await this.getHeaders();
            const response = await fetch(`${this.config.apiUrl}/dags?limit=1`, { method: 'GET', headers });
            return response.status === 200;
        }
        catch (e) {
            Telemetry_1.Telemetry.Current.send('AirflowApi.checkConnection.error', { error: e.message });
            return false;
        }
    }
    async getDagList() {
        const result = new MethodResult_1.MethodResult();
        const allDags = [];
        let offset = 0;
        const limit = 100;
        try {
            while (true) {
                const headers = await this.getHeaders();
                const response = await fetch(`${this.config.apiUrl}/dags?limit=${limit}&offset=${offset}`, { method: 'GET', headers });
                const data = await response.json();
                if (response.status === 200) {
                    allDags.push(...data["dags"]);
                    if (data["dags"].length < limit) {
                        break;
                    }
                    offset += limit;
                }
                else {
                    ui.showApiErrorMessage('Api Call Error', data);
                    result.isSuccessful = false;
                    return result;
                }
            }
            result.result = allDags;
            result.isSuccessful = true;
        }
        catch (error) {
            ui.showErrorMessage('Cannot connect to Airflow.', error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.getDagList.error', { error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async triggerDag(dagId, config = "{}", date) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            let body = { conf: JSON.parse(config) };
            if (this.version === 'v1' && date) {
                body.logical_date = date + "T00:00:00Z";
            }
            else if (this.version === 'v2') {
                body.logical_date = date ? (date + "T00:00:00Z") : new Date().toISOString();
            }
            const response = await fetch(`${this.config.apiUrl}/dags/${dagId}/dagRuns`, {
                method: 'POST',
                headers,
                body: JSON.stringify(body),
            });
            const data = await response.json();
            if (response.status === 200 || response.status === 201) { // 201 Created is typical for POST
                //ui.showInfoMessage(`${dagId} Triggered.`);
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                ui.showApiErrorMessage(`${dagId} Trigger Error`, data);
                result.isSuccessful = false;
            }
        }
        catch (error) {
            ui.showErrorMessage(`${dagId} Trigger Error`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.triggerDag.error', { dagId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getDagRun(dagId, dagRunId) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            const response = await fetch(`${this.config.apiUrl}/dags/${dagId}/dagRuns/${dagRunId}`, { method: 'GET', headers });
            const data = await response.json();
            if (response.status === 200) {
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                result.isSuccessful = false;
            }
        }
        catch (error) {
            Telemetry_1.Telemetry.Current.send('AirflowApi.getDagRun.error', { dagId, dagRunId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getLastDagRun(dagId) {
        const history = await this.getDagRunHistory(dagId);
        if (history.isSuccessful && history.result && history.result.dag_runs && history.result.dag_runs.length > 0) {
            return this.getDagRun(dagId, history.result.dag_runs[0].dag_run_id);
        }
        const res = new MethodResult_1.MethodResult();
        res.isSuccessful = false;
        return res;
    }
    async getDagRunHistory(dagId, date) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            let url = `${this.config.apiUrl}/dags/${dagId}/dagRuns?order_by=-start_date`;
            // If date is provided, filter runs for that specific day
            if (date) {
                const startDate = `${date}T00:00:00Z`;
                const endDate = `${date}T23:59:59Z`;
                url += `&start_date_gte=${encodeURIComponent(startDate)}&start_date_lte=${encodeURIComponent(endDate)}`;
            }
            const response = await fetch(url, { method: 'GET', headers });
            const data = await response.json();
            if (response.status === 200) {
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                result.isSuccessful = false;
            }
        }
        catch (error) {
            Telemetry_1.Telemetry.Current.send('AirflowApi.getDagRunHistory.error', { dagId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async pauseDag(dagId, isPaused) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            const response = await fetch(`${this.config.apiUrl}/dags/${dagId}`, {
                method: 'PATCH',
                headers,
                body: JSON.stringify({ is_paused: isPaused })
            });
            const data = await response.json();
            if (response.status === 200) {
                //ui.showInfoMessage(`${dagId} ${isPaused ? "PAUSED" : "UN-PAUSED"}`);
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                ui.showApiErrorMessage(`${dagId} Pause Error`, data);
                result.isSuccessful = false;
            }
        }
        catch (error) {
            ui.showErrorMessage(`${dagId} Pause Error`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.pauseDag.error', { dagId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getSourceCode(dagId, fileToken) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            let url = "";
            if (this.version === 'v1' && fileToken) {
                url = `${this.config.apiUrl}/dagSources/${fileToken}`;
            }
            else if (this.version === 'v2') {
                url = `${this.config.apiUrl}/dagSources/${dagId}`;
            }
            else {
                throw new Error("Unknown Airflow Version or missing file token");
            }
            const response = await fetch(url, { method: 'GET', headers });
            if (response.status === 200) {
                if (this.version === 'v2') {
                    const json = await response.json();
                    result.result = json.content;
                }
                else {
                    result.result = await response.text();
                }
                result.isSuccessful = true;
            }
            else {
                const data = await response.json();
                ui.showApiErrorMessage(`${dagId} Source Code Error`, data);
                result.isSuccessful = false;
            }
        }
        catch (error) {
            ui.showErrorMessage(`${dagId} Source Code Error`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.getSourceCode.error', { dagId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getImportErrors() {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            const response = await fetch(`${this.config.apiUrl}/importErrors`, { method: 'GET', headers });
            const data = await response.json();
            if (response.status === 200) {
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                result.isSuccessful = false;
            }
        }
        catch (error) {
            Telemetry_1.Telemetry.Current.send('AirflowApi.getImportErrors.error', { error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getTaskInstanceLog(dagId, dagRunId, taskId, tryNumber) {
        const result = new MethodResult_1.MethodResult();
        try {
            //ui.showInfoMessage('Fetching Task Logs...');
            const headers = await this.getHeaders();
            const logRes = await fetch(`${this.config.apiUrl}/dags/${dagId}/dagRuns/${dagRunId}/taskInstances/${taskId}/logs/${tryNumber}`, { method: 'GET', headers });
            const logJson = await logRes.json();
            result.result = logJson;
            result.isSuccessful = true;
        }
        catch (error) {
            ui.showErrorMessage(`${dagId} Log Error`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.getTaskInstanceLog.error', { dagId, dagRunId, taskId, tryNumber: tryNumber.toString(), error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getTaskInstanceLogText(dagId, dagRunId, taskId, tryNumber) {
        const result = new MethodResult_1.MethodResult();
        try {
            if (tryNumber === undefined) {
                //get latest try number
                const taskInstancesResult = await this.getTaskInstances(dagId, dagRunId);
                if (!taskInstancesResult.isSuccessful) {
                    result.isSuccessful = false;
                    result.error = taskInstancesResult.error;
                    return result;
                }
                const taskInstance = taskInstancesResult.result.task_instances.find((ti) => ti.task_id === taskId);
                if (!taskInstance) {
                    throw new Error(`Task instance not found for taskId: ${taskId}`);
                }
                tryNumber = taskInstance.try_number;
            }
            const logJsonResult = await this.getTaskInstanceLog(dagId, dagRunId, taskId, tryNumber);
            if (!logJsonResult.isSuccessful) {
                result.isSuccessful = false;
                result.error = logJsonResult.error;
                return result;
            }
            const logJson = logJsonResult.result;
            const logText = JSON.stringify(logJson, null, 2);
            let logContent = '';
            logContent += `############################################################\n`;
            logContent += `Dag=${dagId}\nDagRun=${dagRunId}\nTaskId=${taskId}\nTry=${tryNumber}\n`;
            logContent += `############################################################\n\n`;
            logContent += logText;
            result.result = logContent;
            result.isSuccessful = true;
        }
        catch (error) {
            ui.showErrorMessage(`${dagId} Log Error`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.getTaskInstanceLogText.error', { dagId, dagRunId, taskId, tryNumber: tryNumber?.toString() || 'undefined', error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getLastDagRunLogText(dagId) {
        const result = new MethodResult_1.MethodResult();
        try {
            //ui.showInfoMessage('Fetching Latest DAG Run Logs...');
            const history = await this.getDagRunHistory(dagId);
            if (!history.isSuccessful || !history.result.dag_runs.length) {
                throw new Error("No DAG runs found");
            }
            const dagRunId = history.result.dag_runs[0].dag_run_id;
            let logContent = await this.getDagRunLogText(dagId, dagRunId);
            if (!logContent.isSuccessful) {
                result.isSuccessful = false;
                result.error = logContent.error;
                return result;
            }
            result.result = logContent.result;
            result.isSuccessful = true;
        }
        catch (error) {
            ui.showErrorMessage(`${dagId} Log Error`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.getLastDagRunLogText.error', { dagId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getDagRunLogText(dagId, dagRunId) {
        const result = new MethodResult_1.MethodResult();
        //ui.showInfoMessage('Fetching DAG Run Logs...');
        try {
            const taskInstancesResult = await this.getTaskInstances(dagId, dagRunId);
            if (!taskInstancesResult.isSuccessful) {
                result.isSuccessful = false;
                result.error = taskInstancesResult.error;
                return result;
            }
            let logContent = '';
            for (const ti of taskInstancesResult.result.task_instances) {
                const taskId = ti.task_id;
                const tryNumber = ti.try_number;
                const logTextResult = await this.getTaskInstanceLogText(dagId, dagRunId, taskId, tryNumber);
                if (!logTextResult.isSuccessful) {
                    result.isSuccessful = false;
                    result.error = logTextResult.error;
                    return result;
                }
                logContent += logTextResult.result + '\n\n';
            }
            result.result = logContent;
            result.isSuccessful = true;
            return result;
        }
        catch (error) {
            ui.showErrorMessage(`${dagId} Log Error`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.getDagRunLogText.error', { dagId, dagRunId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
    }
    async getDagInfo(dagId) {
        return this.genericGet(`/dags/${dagId}`);
    }
    async getDagTasks(dagId) {
        return this.genericGet(`/dags/${dagId}/tasks`);
    }
    async getTaskInstances(dagId, dagRunId) {
        return this.genericGet(`/dags/${dagId}/dagRuns/${dagRunId}/taskInstances`);
    }
    async cancelDagRun(dagId, dagRunId) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            const response = await fetch(`${this.config.apiUrl}/dags/${dagId}/dagRuns/${dagRunId}`, {
                method: 'PATCH',
                headers,
                body: JSON.stringify({ state: 'failed' })
            });
            const data = await response.json();
            if (response.status === 200) {
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                ui.showApiErrorMessage(`${dagId} Cancel Error`, data);
                result.isSuccessful = false;
            }
        }
        catch (error) {
            ui.showErrorMessage(`${dagId} Cancel Error`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.cancelDagRun.error', { dagId, dagRunId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async getTaskXComs(dagId, dagRunId, taskId) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            const response = await fetch(`${this.config.apiUrl}/dags/${dagId}/dagRuns/${dagRunId}/taskInstances/${taskId}/xcomEntries`, { method: 'GET', headers });
            if (response.status === 200) {
                const data = await response.json();
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                const data = await response.json();
                ui.showApiErrorMessage(`XCom fetch error for ${taskId}`, data);
                result.isSuccessful = false;
            }
        }
        catch (error) {
            ui.showErrorMessage(`XCom fetch error for ${taskId}`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.getTaskXComs.error', { dagId, dagRunId, taskId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    async updateDagRunNote(dagId, dagRunId, note) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            const response = await fetch(`${this.config.apiUrl}/dags/${dagId}/dagRuns/${dagRunId}`, {
                method: 'PATCH',
                headers,
                body: JSON.stringify({ note: note })
            });
            const data = await response.json();
            if (response.status === 200) {
                //ui.showInfoMessage('DAG run note updated successfully');
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                ui.showApiErrorMessage(`Failed to update note`, data);
                result.isSuccessful = false;
            }
        }
        catch (error) {
            ui.showErrorMessage(`Failed to update note`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.updateDagRunNote.error', { dagId, dagRunId, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
    // Add other methods as needed (getConnections, getVariables, getProviders)
    async getConnections() {
        return this.genericGet('/connections');
    }
    async getVariables() {
        return this.genericGet('/variables');
    }
    async getProviders() {
        return this.genericGet('/providers');
    }
    async getConfig() {
        return this.genericGet('/config');
    }
    async getPlugins() {
        return this.genericGet('/plugins');
    }
    async getHealth() {
        return this.genericGet('/monitor/health');
    }
    async genericGet(endpoint) {
        const result = new MethodResult_1.MethodResult();
        try {
            const headers = await this.getHeaders();
            const response = await fetch(`${this.config.apiUrl}${endpoint}`, { method: 'GET', headers });
            const data = await response.json();
            if (response.status === 200) {
                result.result = data;
                result.isSuccessful = true;
            }
            else {
                ui.showApiErrorMessage(`Error fetching ${endpoint}`, data);
                result.isSuccessful = false;
            }
        }
        catch (error) {
            ui.showErrorMessage(`Error fetching ${endpoint}`, error);
            Telemetry_1.Telemetry.Current.send('AirflowApi.genericGet.error', { endpoint, error: error.message });
            result.isSuccessful = false;
            result.error = error;
        }
        return result;
    }
}
exports.AirflowApi = AirflowApi;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/base64 v1.0.0 by @mathias | MIT license */
;(function(root) {

	// Detect free variables `exports`.
	var freeExports =  true && exports;

	// Detect free variable `module`.
	var freeModule =  true && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code, and use
	// it as `root`.
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var InvalidCharacterError = function(message) {
		this.message = message;
	};
	InvalidCharacterError.prototype = new Error;
	InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	var error = function(message) {
		// Note: the error messages used throughout this file match those used by
		// the native `atob`/`btoa` implementation in Chromium.
		throw new InvalidCharacterError(message);
	};

	var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	// http://whatwg.org/html/common-microsyntaxes.html#space-character
	var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;

	// `decode` is designed to be fully compatible with `atob` as described in the
	// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
	// The optimized base64-decoding algorithm used is based on @atk’s excellent
	// implementation. https://gist.github.com/atk/1020396
	var decode = function(input) {
		input = String(input)
			.replace(REGEX_SPACE_CHARACTERS, '');
		var length = input.length;
		if (length % 4 == 0) {
			input = input.replace(/==?$/, '');
			length = input.length;
		}
		if (
			length % 4 == 1 ||
			// http://whatwg.org/C#alphanumeric-ascii-characters
			/[^+a-zA-Z0-9/]/.test(input)
		) {
			error(
				'Invalid character: the string to be decoded is not correctly encoded.'
			);
		}
		var bitCounter = 0;
		var bitStorage;
		var buffer;
		var output = '';
		var position = -1;
		while (++position < length) {
			buffer = TABLE.indexOf(input.charAt(position));
			bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
			// Unless this is the first of a group of 4 characters…
			if (bitCounter++ % 4) {
				// …convert the first 8 bits to a single ASCII character.
				output += String.fromCharCode(
					0xFF & bitStorage >> (-2 * bitCounter & 6)
				);
			}
		}
		return output;
	};

	// `encode` is designed to be fully compatible with `btoa` as described in the
	// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa
	var encode = function(input) {
		input = String(input);
		if (/[^\0-\xFF]/.test(input)) {
			// Note: no need to special-case astral symbols here, as surrogates are
			// matched, and the input is supposed to only contain ASCII anyway.
			error(
				'The string to be encoded contains characters outside of the ' +
				'Latin1 range.'
			);
		}
		var padding = input.length % 3;
		var output = '';
		var position = -1;
		var a;
		var b;
		var c;
		var buffer;
		// Make sure any padding is handled outside of the loop.
		var length = input.length - padding;

		while (++position < length) {
			// Read three bytes, i.e. 24 bits.
			a = input.charCodeAt(position) << 16;
			b = input.charCodeAt(++position) << 8;
			c = input.charCodeAt(++position);
			buffer = a + b + c;
			// Turn the 24 bits into four chunks of 6 bits each, and append the
			// matching character for each of them to the output.
			output += (
				TABLE.charAt(buffer >> 18 & 0x3F) +
				TABLE.charAt(buffer >> 12 & 0x3F) +
				TABLE.charAt(buffer >> 6 & 0x3F) +
				TABLE.charAt(buffer & 0x3F)
			);
		}

		if (padding == 2) {
			a = input.charCodeAt(position) << 8;
			b = input.charCodeAt(++position);
			buffer = a + b;
			output += (
				TABLE.charAt(buffer >> 10) +
				TABLE.charAt((buffer >> 4) & 0x3F) +
				TABLE.charAt((buffer << 2) & 0x3F) +
				'='
			);
		} else if (padding == 1) {
			buffer = input.charCodeAt(position);
			output += (
				TABLE.charAt(buffer >> 2) +
				TABLE.charAt((buffer << 4) & 0x3F) +
				'=='
			);
		}

		return output;
	};

	var base64 = {
		'encode': encode,
		'decode': decode,
		'version': '1.0.0'
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return base64;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else // removed by dead control flow
{ var key; }

}(this));


/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* eslint-disable @typescript-eslint/naming-convention */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodResult = void 0;
class MethodResult {
    constructor() {
        this.result = undefined;
        this.isSuccessful = false;
        this.error = undefined;
    }
}
exports.MethodResult = MethodResult;


/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Telemetry = void 0;
const extension_telemetry_1 = __webpack_require__(10);
const vscode = __webpack_require__(1);
class Telemetry {
    constructor(context) {
        this.connectionString = "InstrumentationKey=10fbe7b4-13da-4481-ab61-902bd7acac44;IngestionEndpoint=https://eastus-8.in.applicationinsights.azure.com/;LiveEndpoint=https://eastus.livediagnostics.monitor.azure.com/;ApplicationId=1af62da8-61c9-4cb6-8c9b-34d84e6e8bfe";
        this.reporter = undefined;
        Telemetry.Current = this;
        if (vscode.env.isTelemetryEnabled && this.connectionString) {
            this.reporter = new extension_telemetry_1.TelemetryReporter(this.connectionString);
            context.subscriptions.push(this.reporter);
        }
    }
    send(eventName, properties, measurements) {
        if (!vscode.env.isTelemetryEnabled)
            return;
        if (!this.reporter)
            return;
        this.reporter.sendTelemetryEvent(eventName, properties, measurements);
    }
    sendError(eventName, errorOrProps, measurements) {
        if (!vscode.env.isTelemetryEnabled)
            return;
        if (!this.reporter)
            return;
        if (errorOrProps instanceof Error) {
            this.reporter.sendTelemetryErrorEvent(eventName, {
                message: errorOrProps.message,
                name: errorOrProps.name,
                stack: errorOrProps.stack ?? ''
            }, measurements);
        }
        else {
            const props = errorOrProps || {};
            this.reporter.sendTelemetryErrorEvent(eventName, props, measurements);
        }
    }
    dispose() {
        if (this.reporter) {
            this.reporter.dispose();
        }
    }
}
exports.Telemetry = Telemetry;


/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TelemetryReporter: () => (/* binding */ TelemetryReporter)
/* harmony export */ });
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _common_1dsClientFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
/* harmony import */ var _common_appInsightsClientFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);
/* harmony import */ var _common_baseTelemetryReporter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(117);
/* harmony import */ var _common_baseTelemetrySender__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(118);
/* harmony import */ var _common_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(105);
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/








/**
 * Create a replacement for the XHTMLRequest object utilizing nodes HTTP module.
 * @returns A XHR override object used to override the XHTMLRequest object in the 1DS SDK
 */
function getDefaultXHROverride() {
    // Override the way events get sent since node doesn't have XHTMLRequest
    const customHttpXHROverride = {
        sendPOST: (payload, oncomplete) => {
            const options = {
                method: "POST",
                headers: {
                    ...payload.headers,
                    "Content-Type": "application/json",
                    "Content-Length": Buffer.byteLength(payload.data)
                }
            };
            try {
                const req = https__WEBPACK_IMPORTED_MODULE_0__.request(payload.urlString, options, res => {
                    res.on("data", function (responseData) {
                        oncomplete(res.statusCode ?? 200, res.headers, responseData.toString());
                    });
                    // On response with error send status of 0 and a blank response to oncomplete so we can retry events
                    res.on("error", function () {
                        oncomplete(0, {});
                    });
                });
                req.write(payload.data, (err) => {
                    if (err) {
                        oncomplete(0, {});
                    }
                });
                req.end();
            }
            catch {
                // If it errors out, send status of 0 and a blank response to oncomplete so we can retry events
                oncomplete(0, {});
            }
        }
    };
    return customHttpXHROverride;
}
/**
 * Create an XHR override from a custom fetcher function.
 * @param fetcher The custom fetcher function to use for sending telemetry data
 * @returns A XHR override object used to override the XHTMLRequest object in the 1DS SDK
 */
function createXHROverrideFromFetcher(fetcher) {
    const xhrOverride = {
        sendPOST: (payload, oncomplete) => {
            const dataString = typeof payload.data === "string" ? payload.data : Buffer.from(payload.data).toString();
            fetcher(payload.urlString, { method: "POST", headers: payload.headers, body: dataString })
                .then(async (response) => {
                const responseHeaders = {};
                for (const [key, value] of response.headers) {
                    responseHeaders[key] = value;
                }
                const body = await response.text();
                oncomplete(response.status, responseHeaders, body);
            })
                .catch(() => {
                // If it errors out, send status of 0 and a blank response to oncomplete so we can retry events
                oncomplete(0, {});
            });
        }
    };
    return xhrOverride;
}
class TelemetryReporter extends _common_baseTelemetryReporter__WEBPACK_IMPORTED_MODULE_5__.BaseTelemetryReporter {
    constructor(connectionString, replacementOptions, initializationOptions, customFetcher) {
        const xhrOverride = customFetcher ? createXHROverrideFromFetcher(customFetcher) : getDefaultXHROverride();
        let clientFactory = (connectionString) => (0,_common_appInsightsClientFactory__WEBPACK_IMPORTED_MODULE_4__.appInsightsClientFactory)(connectionString, vscode__WEBPACK_IMPORTED_MODULE_2__.env.machineId, vscode__WEBPACK_IMPORTED_MODULE_2__.env.sessionId, xhrOverride, replacementOptions);
        // If connection string is usable by 1DS use the 1DS SDk
        if (_common_util__WEBPACK_IMPORTED_MODULE_7__.TelemetryUtil.shouldUseOneDataSystemSDK(connectionString)) {
            clientFactory = (key) => (0,_common_1dsClientFactory__WEBPACK_IMPORTED_MODULE_3__.oneDataSystemClientFactory)(key, vscode__WEBPACK_IMPORTED_MODULE_2__, xhrOverride);
        }
        const osShim = {
            release: os__WEBPACK_IMPORTED_MODULE_1__.release(),
            platform: os__WEBPACK_IMPORTED_MODULE_1__.platform(),
            architecture: os__WEBPACK_IMPORTED_MODULE_1__.arch(),
        };
        const sender = new _common_baseTelemetrySender__WEBPACK_IMPORTED_MODULE_6__.BaseTelemetrySender(connectionString, clientFactory);
        if (connectionString && connectionString.indexOf("AIF-") === 0) {
            throw new Error("AIF keys are no longer supported. Please switch to 1DS keys for 1st party extensions");
        }
        const initializationOpts = {
            ...initializationOptions,
            additionalCommonProperties: initializationOptions?.additionalCommonProperties ?
                { ...initializationOptions.additionalCommonProperties, ..._common_util__WEBPACK_IMPORTED_MODULE_7__.TelemetryUtil.getAdditionalCommonProperties(osShim) }
                : _common_util__WEBPACK_IMPORTED_MODULE_7__.TelemetryUtil.getAdditionalCommonProperties(osShim)
        };
        super(sender, vscode__WEBPACK_IMPORTED_MODULE_2__, initializationOpts);
    }
}
//# sourceMappingURL=telemetryReporter.js.map

/***/ }),
/* 11 */
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),
/* 12 */
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   oneDataSystemClientFactory: () => (/* binding */ oneDataSystemClientFactory)
/* harmony export */ });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Configures 1DS properly and returns the core client object
 * @param key The ingestion key
 * @param xhrOverride An optional override to use for requests instead of the XHTMLRequest object. Useful for node environments
 * @returns The AI core object
 */
const getAICore = async (key, vscodeAPI, xhrOverride) => {
    const oneDs = await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 14));
    const postPlugin = await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 63));
    const appInsightsCore = new oneDs.AppInsightsCore();
    const collectorChannelPlugin = new postPlugin.PostChannel();
    // Configure the app insights core to send to collector++ and disable logging of debug info
    const coreConfig = {
        instrumentationKey: key,
        endpointUrl: "https://mobile.events.data.microsoft.com/OneCollector/1.0",
        loggingLevelTelemetry: 0,
        loggingLevelConsole: 0,
        disableCookiesUsage: true,
        disableDbgExt: true,
        disableInstrumentationKeyValidation: true,
        channels: [[
                collectorChannelPlugin
            ]]
    };
    if (xhrOverride) {
        coreConfig.extensionConfig = {};
        // Configure the channel to use a XHR Request override since it's not available in node
        const channelConfig = {
            alwaysUseXhrOverride: true,
            httpXHROverride: xhrOverride
        };
        coreConfig.extensionConfig[collectorChannelPlugin.identifier] = channelConfig;
    }
    const config = vscodeAPI.workspace.getConfiguration("telemetry");
    const internalTesting = config.get("internalTesting");
    appInsightsCore.initialize(coreConfig, []);
    appInsightsCore.addTelemetryInitializer((envelope) => {
        envelope["ext"] = envelope["ext"] ?? {};
        envelope["ext"]["web"] = envelope["ext"]["web"] ?? {};
        envelope["ext"]["web"]["consentDetails"] = "{\"GPC_DataSharingOptIn\":false}";
        // Only add the remaining flags when `telemetry.internalTesting` is enabled
        if (!internalTesting) {
            return;
        }
        envelope["ext"]["utc"] = envelope["ext"]["utc"] ?? {};
        // Sets it to be internal only based on Windows UTC flagging
        envelope["ext"]["utc"]["flags"] = 0x0000811ECD;
    });
    return appInsightsCore;
};
/**
 * Configures and creates a telemetry client using the 1DS sdk
 * @param key The ingestion key
 * @param xhrOverride An optional override to use for requests instead of the XHTMLRequest object. Useful for node environments
 */
const oneDataSystemClientFactory = async (key, vscodeAPI, xhrOverride) => {
    let appInsightsCore = await getAICore(key, vscodeAPI, xhrOverride);
    const flushOneDS = async () => {
        try {
            const flushPromise = new Promise((resolve, reject) => {
                if (!appInsightsCore) {
                    resolve();
                    return;
                }
                appInsightsCore.flush(true, (completedFlush) => {
                    if (!completedFlush) {
                        reject("Failed to flush app 1DS!");
                        return;
                    }
                });
            });
            return flushPromise;
        }
        catch (e) {
            throw new Error("Failed to flush 1DS!\n" + e.message);
        }
    };
    // Shape the app insights core from 1DS into a standard format
    const telemetryClient = {
        logEvent: (eventName, data) => {
            try {
                appInsightsCore?.track({
                    name: eventName,
                    baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
                });
            }
            catch (e) {
                throw new Error("Failed to log event to app insights!\n" + e.message);
            }
        },
        flush: flushOneDS,
        dispose: async () => {
            const disposePromise = new Promise((resolve) => {
                if (!appInsightsCore) {
                    resolve();
                    return;
                }
                appInsightsCore.unload(false, () => {
                    resolve();
                    appInsightsCore = undefined;
                    return;
                }, 1000);
            });
            return disposePromise;
        }
    };
    return telemetryClient;
};
//# sourceMappingURL=1dsClientFactory.js.map

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActiveStatus: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.ActiveStatus),
/* harmony export */   AppInsightsCore: () => (/* reexport safe */ _AppInsightsCore__WEBPACK_IMPORTED_MODULE_0__.AppInsightsCore),
/* harmony export */   BaseTelemetryPlugin: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__.BaseTelemetryPlugin),
/* harmony export */   DiagnosticLogger: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__.DiagnosticLogger),
/* harmony export */   EventLatency: () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_1__.EventLatency),
/* harmony export */   EventPersistence: () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_1__.EventPersistence),
/* harmony export */   EventPropertyType: () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_1__.EventPropertyType),
/* harmony export */   EventsDiscardedReason: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.EventsDiscardedReason),
/* harmony export */   FullVersionString: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.FullVersionString),
/* harmony export */   InternalAppInsightsCore: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__.AppInsightsCore),
/* harmony export */   LoggingSeverity: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__.LoggingSeverity),
/* harmony export */   MinChannelPriorty: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.MinChannelPriorty),
/* harmony export */   NotificationManager: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.NotificationManager),
/* harmony export */   PerfEvent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.PerfEvent),
/* harmony export */   PerfManager: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.PerfManager),
/* harmony export */   ProcessTelemetryContext: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.ProcessTelemetryContext),
/* harmony export */   SenderPostManager: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.SenderPostManager),
/* harmony export */   TraceLevel: () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_1__.TraceLevel),
/* harmony export */   Undefined: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.strShimUndefined),
/* harmony export */   ValueKind: () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_1__.ValueKind),
/* harmony export */   ValueSanitizer: () => (/* reexport safe */ _ValueSanitizer__WEBPACK_IMPORTED_MODULE_2__.ValueSanitizer),
/* harmony export */   Version: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.Version),
/* harmony export */   _InternalLogMessage: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__._InternalLogMessage),
/* harmony export */   __getRegisteredEvents: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.__getRegisteredEvents),
/* harmony export */   _appendHeader: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__._appendHeader),
/* harmony export */   _getAllResponseHeaders: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__._getAllResponseHeaders),
/* harmony export */   _logInternalMessage: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__._logInternalMessage),
/* harmony export */   _testHookMaxUnloadHooksCb: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_26__._testHookMaxUnloadHooksCb),
/* harmony export */   _throwInternal: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__._throwInternal),
/* harmony export */   _warnToConsole: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__._warnToConsole),
/* harmony export */   addEventHandler: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.addEventHandler),
/* harmony export */   addEventListeners: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.addEventListeners),
/* harmony export */   addPageHideEventListener: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.addPageHideEventListener),
/* harmony export */   addPageShowEventListener: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.addPageShowEventListener),
/* harmony export */   addPageUnloadEventListener: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.addPageUnloadEventListener),
/* harmony export */   areCookiesSupported: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.areCookiesSupported),
/* harmony export */   arrForEach: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.arrForEach),
/* harmony export */   arrIndexOf: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.arrIndexOf),
/* harmony export */   arrMap: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.arrMap),
/* harmony export */   arrReduce: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.arrReduce),
/* harmony export */   attachEvent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.attachEvent),
/* harmony export */   blockDynamicConversion: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_29__.blockDynamicConversion),
/* harmony export */   convertAllHeadersToMap: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.convertAllHeadersToMap),
/* harmony export */   cookieAvailable: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.areCookiesSupported),
/* harmony export */   createCookieMgr: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.createCookieMgr),
/* harmony export */   createDynamicConfig: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.createDynamicConfig),
/* harmony export */   createEnumStyle: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.createEnumStyle),
/* harmony export */   createGuid: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.createGuid),
/* harmony export */   createProcessTelemetryContext: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.createProcessTelemetryContext),
/* harmony export */   createTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.createTraceParent),
/* harmony export */   createUniqueNamespace: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__.createUniqueNamespace),
/* harmony export */   createUnloadHandlerContainer: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.createUnloadHandlerContainer),
/* harmony export */   dateNow: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.utcNow),
/* harmony export */   detachEvent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.detachEvent),
/* harmony export */   disallowsSameSiteNone: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.uaDisallowsSameSiteNone),
/* harmony export */   doPerf: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.doPerf),
/* harmony export */   dumpObj: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.dumpObj),
/* harmony export */   eventOff: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.eventOff),
/* harmony export */   eventOn: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.eventOn),
/* harmony export */   extend: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.extend),
/* harmony export */   fieldRedaction: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.fieldRedaction),
/* harmony export */   findW3cTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.findW3cTraceParent),
/* harmony export */   forceDynamicConversion: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_29__.forceDynamicConversion),
/* harmony export */   formatErrorMessageXdr: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.formatErrorMessageXdr),
/* harmony export */   formatErrorMessageXhr: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.formatErrorMessageXhr),
/* harmony export */   formatTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.formatTraceParent),
/* harmony export */   generateW3CId: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_11__.generateW3CId),
/* harmony export */   getCommonSchemaMetaData: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.getCommonSchemaMetaData),
/* harmony export */   getConsole: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.getConsole),
/* harmony export */   getCookieValue: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.getCookieValue),
/* harmony export */   getCrypto: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.getCrypto),
/* harmony export */   getDocument: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getDocument),
/* harmony export */   getDynamicConfigHandler: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_29__.getDynamicConfigHandler),
/* harmony export */   getExceptionName: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.getExceptionName),
/* harmony export */   getFieldValueType: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.getFieldValueType),
/* harmony export */   getGlobal: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getGlobal),
/* harmony export */   getGlobalInst: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getInst),
/* harmony export */   getHistory: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getHistory),
/* harmony export */   getIEVersion: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.getIEVersion),
/* harmony export */   getISOString: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.toISOString),
/* harmony export */   getJSON: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.getJSON),
/* harmony export */   getLocation: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.getLocation),
/* harmony export */   getMsCrypto: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.getMsCrypto),
/* harmony export */   getNavigator: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getNavigator),
/* harmony export */   getPerformance: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getPerformance),
/* harmony export */   getResponseText: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.getResponseText),
/* harmony export */   getSetValue: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.getSetValue),
/* harmony export */   getTenantId: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.getTenantId),
/* harmony export */   getTime: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.getTime),
/* harmony export */   getWindow: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.getWindow),
/* harmony export */   hasDocument: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.hasDocument),
/* harmony export */   hasHistory: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.hasHistory),
/* harmony export */   hasJSON: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.hasJSON),
/* harmony export */   hasNavigator: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.hasNavigator),
/* harmony export */   hasOwnProperty: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.objHasOwnProperty),
/* harmony export */   hasWindow: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.hasWindow),
/* harmony export */   isArray: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isArray),
/* harmony export */   isArrayValid: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isArrayValid),
/* harmony export */   isBeaconsSupported: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.isBeaconsSupported),
/* harmony export */   isBoolean: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isBoolean),
/* harmony export */   isChromium: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isChromium),
/* harmony export */   isDate: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isDate),
/* harmony export */   isDocumentObjectAvailable: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isDocumentObjectAvailable),
/* harmony export */   isError: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isError),
/* harmony export */   isFeatureEnabled: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.isFeatureEnabled),
/* harmony export */   isFetchSupported: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.isFetchSupported),
/* harmony export */   isFunction: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isFunction),
/* harmony export */   isGreaterThanZero: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isGreaterThanZero),
/* harmony export */   isIE: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.isIE),
/* harmony export */   isLatency: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isLatency),
/* harmony export */   isNotTruthy: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isNotTruthy),
/* harmony export */   isNullOrUndefined: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isNullOrUndefined),
/* harmony export */   isNumber: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isNumber),
/* harmony export */   isObject: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isObject),
/* harmony export */   isReactNative: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.isReactNative),
/* harmony export */   isSampledFlag: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.isSampledFlag),
/* harmony export */   isString: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isString),
/* harmony export */   isTruthy: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isTruthy),
/* harmony export */   isTypeof: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isTypeof),
/* harmony export */   isUint8ArrayAvailable: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isUint8ArrayAvailable),
/* harmony export */   isUndefined: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.isUndefined),
/* harmony export */   isValidSpanId: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.isValidSpanId),
/* harmony export */   isValidTraceId: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.isValidTraceId),
/* harmony export */   isValidTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.isValidTraceParent),
/* harmony export */   isValueAssigned: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isValueAssigned),
/* harmony export */   isValueKind: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isValueKind),
/* harmony export */   isWindowObjectAvailable: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.isWindowObjectAvailable),
/* harmony export */   isXhrSupported: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.isXhrSupported),
/* harmony export */   mergeEvtNamespace: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.mergeEvtNamespace),
/* harmony export */   newGuid: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_11__.newGuid),
/* harmony export */   newId: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_10__.newId),
/* harmony export */   normalizeJsName: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.normalizeJsName),
/* harmony export */   objDefineAccessors: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.objDefineAccessors),
/* harmony export */   objForEachKey: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.objForEachKey),
/* harmony export */   objFreeze: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.objFreeze),
/* harmony export */   objKeys: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.objKeys),
/* harmony export */   objSeal: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.objSeal),
/* harmony export */   onConfigChange: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.onConfigChange),
/* harmony export */   openXhr: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.openXhr),
/* harmony export */   optimizeObject: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.optimizeObject),
/* harmony export */   parseResponse: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.parseResponse),
/* harmony export */   parseTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.parseTraceParent),
/* harmony export */   perfNow: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.perfNow),
/* harmony export */   prependTransports: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.prependTransports),
/* harmony export */   proxyAssign: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.proxyAssign),
/* harmony export */   proxyFunctionAs: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.proxyFunctionAs),
/* harmony export */   proxyFunctions: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.proxyFunctions),
/* harmony export */   random32: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_10__.random32),
/* harmony export */   randomValue: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_10__.randomValue),
/* harmony export */   removeEventHandler: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.removeEventHandler),
/* harmony export */   removeEventListeners: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.removeEventListeners),
/* harmony export */   removePageHideEventListener: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.removePageHideEventListener),
/* harmony export */   removePageShowEventListener: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.removePageShowEventListener),
/* harmony export */   removePageUnloadEventListener: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.removePageUnloadEventListener),
/* harmony export */   safeGetCookieMgr: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.safeGetCookieMgr),
/* harmony export */   safeGetLogger: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__.safeGetLogger),
/* harmony export */   sanitizeProperty: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.sanitizeProperty),
/* harmony export */   setEnableEnvMocks: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.setEnableEnvMocks),
/* harmony export */   setProcessTelemetryTimings: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_30__.setProcessTelemetryTimings),
/* harmony export */   setValue: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.setValue),
/* harmony export */   strContains: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.strContains),
/* harmony export */   strEndsWith: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.strEndsWith),
/* harmony export */   strFunction: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.strShimFunction),
/* harmony export */   strObject: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.strShimObject),
/* harmony export */   strPrototype: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.strShimPrototype),
/* harmony export */   strStartsWith: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.strStartsWith),
/* harmony export */   strTrim: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.strTrim),
/* harmony export */   strUndefined: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.strShimUndefined),
/* harmony export */   throwError: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.throwError),
/* harmony export */   toISOString: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__.toISOString),
/* harmony export */   useXDomainRequest: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.useXDomainRequest)
/* harmony export */ });
/* harmony import */ var _AppInsightsCore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _Enums__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony import */ var _ValueSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(20);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(49);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(27);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(47);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(24);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(59);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(60);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(35);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(61);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(28);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(42);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(43);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(40);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(62);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(38);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(23);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(50);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(51);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(46);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(22);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(31);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(53);
/*
 * 1DS JS SDK Core, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* Index.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
* File to export public classes, interfaces and enums.
*/






//# sourceMappingURL=Index.js.map

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AppInsightsCore: () => (/* binding */ AppInsightsCore)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(22);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(52);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(53);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(54);
/*
 * 1DS JS SDK Core, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

/**
* AppInsightsCore.ts
* @author Abhilash Panwar (abpanwar) Hector Hernandez (hectorh)
* @copyright Microsoft 2018
*/






/**
 * The default settings for the config.
 * WE MUST include all defaults here to ensure that the config is created with all of the properties
 * defined as dynamic.
 */
var defaultConfig = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.objDeepFreeze)({
    endpointUrl: _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_DEFAULT_ENDPOINT_URL,
    propertyStorageOverride: { isVal: _chkPropOverride }
});
function _chkPropOverride(propertyStorageOverride) {
    // Validate property storage override
    if (propertyStorageOverride && (!propertyStorageOverride.getProperty || !propertyStorageOverride.setProperty)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.throwError)("Invalid property storage override passed.");
    }
    return true;
}
/**
 * @group Classes
 * @group Entrypoint
 */
var AppInsightsCore = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__extendsFn)(AppInsightsCore, _super);
    function AppInsightsCore() {
        var _this = _super.call(this) || this;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(AppInsightsCore, _this, function (_self, _base) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_9__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, extensions, logger, notificationManager) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.doPerf)(_self, function () { return "AppInsightsCore.initialize"; }, function () {
                    try {
                        _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_9__._DYN_INITIALIZE /* @min:%2einitialize */]((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.createDynamicConfig)(config, defaultConfig, logger || _self.logger, false).cfg, extensions, logger, notificationManager);
                    }
                    catch (e) {
                        var logger_1 = _self.logger;
                        var message = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.dumpObj)(e);
                        if (message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_9__._DYN_INDEX_OF /* @min:%2eindexOf */]("channels") !== -1) {
                            // Add some additional context to the underlying reported error
                            message += "\n - Channels must be provided through config.channels only!";
                        }
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__._throwInternal)(logger_1, 1 /* eLoggingSeverity.CRITICAL */, 514 /* _eExtendedInternalMessageId.FailedToInitializeSDK */, "SDK Initialization Failed - no telemetry will be sent: " + message);
                    }
                }, function () { return ({ config: config, extensions: extensions, logger: logger, notificationManager: notificationManager }); });
            };
            _self.track = function (item) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.doPerf)(_self, function () { return "AppInsightsCore.track"; }, function () {
                    var telemetryItem = item;
                    if (telemetryItem) {
                        telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_9__._DYN_TIMINGS /* @min:%2etimings */] = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_9__._DYN_TIMINGS /* @min:%2etimings */] || {};
                        telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_9__._DYN_TIMINGS /* @min:%2etimings */].trackStart = (0,_Utils__WEBPACK_IMPORTED_MODULE_8__.getTime)();
                        if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_8__.isLatency)(telemetryItem.latency)) {
                            telemetryItem.latency = 1 /* EventLatencyValue.Normal */;
                        }
                        var itemExt = telemetryItem.ext = telemetryItem.ext || {};
                        itemExt.sdk = itemExt.sdk || {};
                        itemExt.sdk.ver = _Utils__WEBPACK_IMPORTED_MODULE_8__.FullVersionString;
                        var baseData = telemetryItem.baseData = telemetryItem.baseData || {};
                        baseData[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_PROPERTIES /* @min:%2eproperties */] = baseData[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_PROPERTIES /* @min:%2eproperties */] || {};
                        var itemProperties = baseData[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_PROPERTIES /* @min:%2eproperties */];
                        itemProperties[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_VERSION] = itemProperties[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_VERSION] || _self.pluginVersionString || _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY;
                    }
                    _base.track(telemetryItem);
                }, function () { return ({ item: item }); }, !(item.sync));
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_9__._DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */] = function (eventName) {
                return _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_9__._DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */](eventName || "InternalLog");
            };
        });
        return _this;
    }
// Removed Stub for AppInsightsCore.prototype.initialize.
// Removed Stub for AppInsightsCore.prototype.track.
// Removed Stub for AppInsightsCore.prototype.pollInternalLogs.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    AppInsightsCore.__ieDyn=1;

    return AppInsightsCore;
}(_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.AppInsightsCore));

//# sourceMappingURL=AppInsightsCore.js.map

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ReflectObj: () => (/* binding */ ReflectObj),
/* harmony export */   SymbolObj: () => (/* binding */ SymbolObj),
/* harmony export */   __assignFn: () => (/* binding */ __assignFn),
/* harmony export */   __createBindingFn: () => (/* binding */ __createBindingFn),
/* harmony export */   __decorateFn: () => (/* binding */ __decorateFn),
/* harmony export */   __exportStarFn: () => (/* binding */ __exportStarFn),
/* harmony export */   __extendsFn: () => (/* binding */ __extendsFn),
/* harmony export */   __hasReflect: () => (/* binding */ __hasReflect),
/* harmony export */   __importDefaultFn: () => (/* binding */ __importDefaultFn),
/* harmony export */   __importStarFn: () => (/* binding */ __importStarFn),
/* harmony export */   __makeTemplateObjectFn: () => (/* binding */ __makeTemplateObjectFn),
/* harmony export */   __metadataFn: () => (/* binding */ __metadataFn),
/* harmony export */   __objAssignFnImpl: () => (/* binding */ __objAssignFnImpl),
/* harmony export */   __paramFn: () => (/* binding */ __paramFn),
/* harmony export */   __readFn: () => (/* binding */ __readFn),
/* harmony export */   __restFn: () => (/* binding */ __restFn),
/* harmony export */   __spreadArrayFn: () => (/* binding */ __spreadArrayFn),
/* harmony export */   __spreadArraysFn: () => (/* binding */ __spreadArraysFn),
/* harmony export */   __valuesFn: () => (/* binding */ __valuesFn)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.


// Most of these functions have been directly shamelessly "lifted" from the https://github.com/@microsoft/tslib and
// modified to be ES5 compatible and applying several minification and tree-shaking techniques so that Application Insights
// can successfully use TypeScript "importHelpers" which imports tslib during compilation but it will use these at runtime
// Which is also why all of the functions have not been included as Application Insights currently doesn't use or require
// them.
var SymbolObj = ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)() || {})["Symbol"];
var ReflectObj = ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)() || {})["Reflect"];
var __hasReflect = !!ReflectObj;
var strDecorate = "decorate";
var strMetadata = "metadata";
var strGetOwnPropertySymbols = "getOwnPropertySymbols";
var strIterator = "iterator";
var strHasOwnProperty = "hasOwnProperty";
var __objAssignFnImpl = function (t) {
    // tslint:disable-next-line: ban-comma-operator
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (_Constants__WEBPACK_IMPORTED_MODULE_1__.ObjProto[strHasOwnProperty].call(s, p)) {
                t[p] = s[p];
            }
        }
    }
    return t;
};
var __assignFn = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objAssign || __objAssignFnImpl;
// tslint:disable-next-line: only-arrow-functions
var extendStaticsFn = function (d, b) {
    extendStaticsFn = _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjClass["setPrototypeOf"] ||
        // tslint:disable-next-line: only-arrow-functions
        ({ __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        }) ||
        // tslint:disable-next-line: only-arrow-functions
        function (d, b) {
            for (var p in b) {
                if (b[strHasOwnProperty](p)) {
                    d[p] = b[p];
                }
            }
        };
    return extendStaticsFn(d, b);
};
function __extendsFn(d, b) {
    if (typeof b !== _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction && b !== null) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("Class extends value " + String(b) + " is not a constructor or null");
    }
    extendStaticsFn(d, b);
    function __() {
        this.constructor = d;
    }
    // tslint:disable-next-line: ban-comma-operator
    d[_Constants__WEBPACK_IMPORTED_MODULE_1__.strShimPrototype] = b === null ? (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(b) : (__[_Constants__WEBPACK_IMPORTED_MODULE_1__.strShimPrototype] = b[_Constants__WEBPACK_IMPORTED_MODULE_1__.strShimPrototype], new __());
}
function __restFn(s, e) {
    var t = {};
    for (var k in s) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(s, k) && e.indexOf(k) < 0) {
            t[k] = s[k];
        }
    }
    if (s != null && typeof _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjClass[strGetOwnPropertySymbols] === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction) {
        for (var i = 0, p = _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjClass[strGetOwnPropertySymbols](s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjProto["propertyIsEnumerable"].call(s, p[i])) {
                t[p[i]] = s[p[i]];
            }
        }
    }
    return t;
}
function __decorateFn(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = _Constants__WEBPACK_IMPORTED_MODULE_1__.ObjClass["getOwnPropertyDescriptor"](target, key) : desc, d;
    if (__hasReflect && typeof ReflectObj[strDecorate] === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction) {
        r = ReflectObj[strDecorate](decorators, target, key, desc);
    }
    else {
        for (var i = decorators.length - 1; i >= 0; i--) {
            // eslint-disable-next-line no-cond-assign
            if (d = decorators[i]) {
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
            }
        }
    }
    // tslint:disable-next-line:ban-comma-operator
    return c > 3 && r && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(target, key, r), r;
}
function __paramFn(paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
}
function __metadataFn(metadataKey, metadataValue) {
    if (__hasReflect && ReflectObj[strMetadata] === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction) {
        return ReflectObj[strMetadata](metadataKey, metadataValue);
    }
}
function __exportStarFn(m, o) {
    for (var p in m) {
        if (p !== _Constants__WEBPACK_IMPORTED_MODULE_1__.strDefault && !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(o, p)) {
            __createBindingFn(o, m, p);
        }
    }
}
function __createBindingFn(o, m, k, k2) {
    if (k2 === undefined) {
        k2 = k;
    }
    if (!!_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(o, k2, {
            enumerable: true,
            get: function () {
                return m[k];
            }
        });
    }
    else {
        o[k2] = m[k];
    }
}
function __valuesFn(o) {
    var s = typeof SymbolObj === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction && SymbolObj[strIterator], m = s && o[s], i = 0;
    if (m) {
        return m.call(o);
    }
    if (o && typeof o.length === "number") {
        return {
            next: function () {
                if (o && i >= o.length) {
                    o = void 0;
                }
                return { value: o && o[i++], done: !o };
            }
        };
    }
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __readFn(o, n) {
    var m = typeof SymbolObj === _Constants__WEBPACK_IMPORTED_MODULE_1__.strShimFunction && o[SymbolObj[strIterator]];
    if (!m) {
        return o;
    }
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    }
    catch (error) {
        e = {
            error: error
        };
    }
    finally {
        try {
            // tslint:disable-next-line:no-conditional-assignment
            if (r && !r.done && (m = i["return"])) {
                m.call(i);
            }
        }
        finally {
            if (e) {
                // eslint-disable-next-line no-unsafe-finally
                throw e.error;
            }
        }
    }
    return ar;
}
/** @deprecated */
function __spreadArraysFn() {
    var theArgs = arguments;
    // Calculate new total size
    for (var s = 0, i = 0, il = theArgs.length; i < il; i++) {
        s += theArgs[i].length;
    }
    // Create new full array
    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = theArgs[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
        }
    }
    return r;
}
function __spreadArrayFn(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
        to[j] = from[i];
    }
    return to;
}
function __makeTemplateObjectFn(cooked, raw) {
    if (_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(cooked, "raw", { value: raw });
    }
    else {
        cooked.raw = raw;
    }
    return cooked;
}
function __importStarFn(mod) {
    if (mod && mod.__esModule) {
        return mod;
    }
    var result = {};
    if (mod != null) {
        for (var k in mod) {
            if (k !== _Constants__WEBPACK_IMPORTED_MODULE_1__.strDefault && Object.prototype.hasOwnProperty.call(mod, k)) {
                __createBindingFn(result, mod, k);
            }
        }
    }
    // Set default module
    if (!!_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(result, _Constants__WEBPACK_IMPORTED_MODULE_1__.strDefault, { enumerable: true, value: mod });
    }
    else {
        result[_Constants__WEBPACK_IMPORTED_MODULE_1__.strDefault] = mod;
    }
    return result;
}
function __importDefaultFn(mod) {
    return (mod && mod.__esModule) ? mod : { strDefault: mod };
}
//# sourceMappingURL=TsLibShims.js.map

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrAppend: () => (/* binding */ arrAppend),
/* harmony export */   arrContains: () => (/* binding */ arrContains),
/* harmony export */   arrEvery: () => (/* binding */ arrEvery),
/* harmony export */   arrFilter: () => (/* binding */ arrFilter),
/* harmony export */   arrFind: () => (/* binding */ arrFind),
/* harmony export */   arrFindIndex: () => (/* binding */ arrFindIndex),
/* harmony export */   arrFindLast: () => (/* binding */ arrFindLast),
/* harmony export */   arrFindLastIndex: () => (/* binding */ arrFindLastIndex),
/* harmony export */   arrForEach: () => (/* binding */ arrForEach),
/* harmony export */   arrFrom: () => (/* binding */ arrFrom),
/* harmony export */   arrIncludes: () => (/* binding */ arrIncludes),
/* harmony export */   arrIndexOf: () => (/* binding */ arrIndexOf),
/* harmony export */   arrLastIndexOf: () => (/* binding */ arrLastIndexOf),
/* harmony export */   arrMap: () => (/* binding */ arrMap),
/* harmony export */   arrReduce: () => (/* binding */ arrReduce),
/* harmony export */   arrSlice: () => (/* binding */ arrSlice),
/* harmony export */   arrSome: () => (/* binding */ arrSome),
/* harmony export */   arrayDeepCopyHandler: () => (/* binding */ arrayDeepCopyHandler),
/* harmony export */   asString: () => (/* binding */ asString),
/* harmony export */   createArrayIterator: () => (/* binding */ createArrayIterator),
/* harmony export */   createCachedValue: () => (/* binding */ createCachedValue),
/* harmony export */   createCustomError: () => (/* binding */ createCustomError),
/* harmony export */   createDeferredCachedValue: () => (/* binding */ createDeferredCachedValue),
/* harmony export */   createEnum: () => (/* binding */ createEnum),
/* harmony export */   createEnumKeyMap: () => (/* binding */ createEnumKeyMap),
/* harmony export */   createEnumValueMap: () => (/* binding */ createEnumValueMap),
/* harmony export */   createFilenameRegex: () => (/* binding */ createFilenameRegex),
/* harmony export */   createFnDeferredProxy: () => (/* binding */ createFnDeferredProxy),
/* harmony export */   createIterable: () => (/* binding */ createIterable),
/* harmony export */   createIterator: () => (/* binding */ createIterator),
/* harmony export */   createProxyFuncs: () => (/* binding */ createProxyFuncs),
/* harmony export */   createRangeIterator: () => (/* binding */ createRangeIterator),
/* harmony export */   createSimpleMap: () => (/* binding */ createSimpleMap),
/* harmony export */   createTimeout: () => (/* binding */ createTimeout),
/* harmony export */   createTimeoutWith: () => (/* binding */ createTimeoutWith),
/* harmony export */   createTypeMap: () => (/* binding */ createTypeMap),
/* harmony export */   createWildcardRegex: () => (/* binding */ createWildcardRegex),
/* harmony export */   dateDeepCopyHandler: () => (/* binding */ dateDeepCopyHandler),
/* harmony export */   deepExtend: () => (/* binding */ deepExtend),
/* harmony export */   dumpObj: () => (/* binding */ dumpObj),
/* harmony export */   elapsedTime: () => (/* binding */ elapsedTime),
/* harmony export */   encodeAsHtml: () => (/* binding */ encodeAsHtml),
/* harmony export */   encodeAsJson: () => (/* binding */ encodeAsJson),
/* harmony export */   fnApply: () => (/* binding */ fnApply),
/* harmony export */   fnBind: () => (/* binding */ fnBind),
/* harmony export */   fnCall: () => (/* binding */ fnCall),
/* harmony export */   functionDeepCopyHandler: () => (/* binding */ functionDeepCopyHandler),
/* harmony export */   getCancelIdleCallback: () => (/* binding */ getCancelIdleCallback),
/* harmony export */   getDeferred: () => (/* binding */ getDeferred),
/* harmony export */   getDocument: () => (/* binding */ getDocument),
/* harmony export */   getGlobal: () => (/* binding */ getGlobal),
/* harmony export */   getHistory: () => (/* binding */ getHistory),
/* harmony export */   getIdleCallback: () => (/* binding */ getIdleCallback),
/* harmony export */   getInst: () => (/* binding */ getInst),
/* harmony export */   getIntValue: () => (/* binding */ getIntValue),
/* harmony export */   getKnownSymbol: () => (/* binding */ getKnownSymbol),
/* harmony export */   getLazy: () => (/* binding */ getLazy),
/* harmony export */   getLength: () => (/* binding */ getLength),
/* harmony export */   getNavigator: () => (/* binding */ getNavigator),
/* harmony export */   getPerformance: () => (/* binding */ getPerformance),
/* harmony export */   getSymbol: () => (/* binding */ getSymbol),
/* harmony export */   getValueByIter: () => (/* binding */ getValueByIter),
/* harmony export */   getValueByKey: () => (/* binding */ getValueByKey),
/* harmony export */   getWindow: () => (/* binding */ getWindow),
/* harmony export */   getWritableDeferred: () => (/* binding */ getWritableDeferred),
/* harmony export */   getWritableLazy: () => (/* binding */ getWritableLazy),
/* harmony export */   hasDocument: () => (/* binding */ hasDocument),
/* harmony export */   hasHistory: () => (/* binding */ hasHistory),
/* harmony export */   hasIdleCallback: () => (/* binding */ hasIdleCallback),
/* harmony export */   hasNavigator: () => (/* binding */ hasNavigator),
/* harmony export */   hasPerformance: () => (/* binding */ hasPerformance),
/* harmony export */   hasSymbol: () => (/* binding */ hasSymbol),
/* harmony export */   hasValue: () => (/* binding */ hasValue),
/* harmony export */   hasWindow: () => (/* binding */ hasWindow),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isArrayBuffer: () => (/* binding */ isArrayBuffer),
/* harmony export */   isAsyncFunction: () => (/* binding */ isAsyncFunction),
/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),
/* harmony export */   isBigInt: () => (/* binding */ isBigInt),
/* harmony export */   isBlob: () => (/* binding */ isBlob),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isDate: () => (/* binding */ isDate),
/* harmony export */   isDefined: () => (/* binding */ isDefined),
/* harmony export */   isElement: () => (/* binding */ isElement),
/* harmony export */   isElementLike: () => (/* binding */ isElementLike),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isError: () => (/* binding */ isError),
/* harmony export */   isFile: () => (/* binding */ isFile),
/* harmony export */   isFiniteNumber: () => (/* binding */ isFiniteNumber),
/* harmony export */   isFormData: () => (/* binding */ isFormData),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isGenerator: () => (/* binding */ isGenerator),
/* harmony export */   isInteger: () => (/* binding */ isInteger),
/* harmony export */   isIterable: () => (/* binding */ isIterable),
/* harmony export */   isIterator: () => (/* binding */ isIterator),
/* harmony export */   isMap: () => (/* binding */ isMap),
/* harmony export */   isMapLike: () => (/* binding */ isMapLike),
/* harmony export */   isNode: () => (/* binding */ isNode),
/* harmony export */   isNotTruthy: () => (/* binding */ isNotTruthy),
/* harmony export */   isNullOrUndefined: () => (/* binding */ isNullOrUndefined),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   isPrimitive: () => (/* binding */ isPrimitive),
/* harmony export */   isPrimitiveType: () => (/* binding */ isPrimitiveType),
/* harmony export */   isPromise: () => (/* binding */ isPromise),
/* harmony export */   isPromiseLike: () => (/* binding */ isPromiseLike),
/* harmony export */   isRegExp: () => (/* binding */ isRegExp),
/* harmony export */   isSet: () => (/* binding */ isSet),
/* harmony export */   isSetLike: () => (/* binding */ isSetLike),
/* harmony export */   isStrictNullOrUndefined: () => (/* binding */ isStrictNullOrUndefined),
/* harmony export */   isStrictUndefined: () => (/* binding */ isStrictUndefined),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isSymbol: () => (/* binding */ isSymbol),
/* harmony export */   isThenable: () => (/* binding */ isThenable),
/* harmony export */   isTruthy: () => (/* binding */ isTruthy),
/* harmony export */   isTypeof: () => (/* binding */ isTypeof),
/* harmony export */   isUndefined: () => (/* binding */ isUndefined),
/* harmony export */   isWeakMap: () => (/* binding */ isWeakMap),
/* harmony export */   isWeakSet: () => (/* binding */ isWeakSet),
/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),
/* harmony export */   iterForOf: () => (/* binding */ iterForOf),
/* harmony export */   lazySafeGetInst: () => (/* binding */ lazySafeGetInst),
/* harmony export */   makeGlobRegex: () => (/* binding */ makeGlobRegex),
/* harmony export */   makeIterable: () => (/* binding */ makeIterable),
/* harmony export */   mathAbs: () => (/* binding */ mathAbs),
/* harmony export */   mathAcos: () => (/* binding */ mathAcos),
/* harmony export */   mathAsin: () => (/* binding */ mathAsin),
/* harmony export */   mathAtan: () => (/* binding */ mathAtan),
/* harmony export */   mathAtan2: () => (/* binding */ mathAtan2),
/* harmony export */   mathCeil: () => (/* binding */ mathCeil),
/* harmony export */   mathCos: () => (/* binding */ mathCos),
/* harmony export */   mathExp: () => (/* binding */ mathExp),
/* harmony export */   mathFloor: () => (/* binding */ mathFloor),
/* harmony export */   mathLog: () => (/* binding */ mathLog),
/* harmony export */   mathMax: () => (/* binding */ mathMax),
/* harmony export */   mathMin: () => (/* binding */ mathMin),
/* harmony export */   mathPow: () => (/* binding */ mathPow),
/* harmony export */   mathRandom: () => (/* binding */ mathRandom),
/* harmony export */   mathRound: () => (/* binding */ mathRound),
/* harmony export */   mathSin: () => (/* binding */ mathSin),
/* harmony export */   mathSqrt: () => (/* binding */ mathSqrt),
/* harmony export */   mathTan: () => (/* binding */ mathTan),
/* harmony export */   mathToInt: () => (/* binding */ mathToInt),
/* harmony export */   mathTrunc: () => (/* binding */ mathTrunc),
/* harmony export */   newSymbol: () => (/* binding */ newSymbol),
/* harmony export */   normalizeJsName: () => (/* binding */ normalizeJsName),
/* harmony export */   objAssign: () => (/* binding */ objAssign),
/* harmony export */   objCopyProps: () => (/* binding */ objCopyProps),
/* harmony export */   objCreate: () => (/* binding */ objCreate),
/* harmony export */   objDeepCopy: () => (/* binding */ objDeepCopy),
/* harmony export */   objDeepFreeze: () => (/* binding */ objDeepFreeze),
/* harmony export */   objDefine: () => (/* binding */ objDefine),
/* harmony export */   objDefineAccessors: () => (/* binding */ objDefineAccessors),
/* harmony export */   objDefineGet: () => (/* binding */ objDefineGet),
/* harmony export */   objDefineProp: () => (/* binding */ objDefineProp),
/* harmony export */   objDefineProperties: () => (/* binding */ objDefineProperties),
/* harmony export */   objDefineProps: () => (/* binding */ objDefineProps),
/* harmony export */   objEntries: () => (/* binding */ objEntries),
/* harmony export */   objExtend: () => (/* binding */ objExtend),
/* harmony export */   objForEachKey: () => (/* binding */ objForEachKey),
/* harmony export */   objFreeze: () => (/* binding */ objFreeze),
/* harmony export */   objFromEntries: () => (/* binding */ objFromEntries),
/* harmony export */   objGetOwnPropertyDescriptor: () => (/* binding */ objGetOwnPropertyDescriptor),
/* harmony export */   objGetOwnPropertyDescriptors: () => (/* binding */ objGetOwnPropertyDescriptors),
/* harmony export */   objGetOwnPropertyNames: () => (/* binding */ objGetOwnPropertyNames),
/* harmony export */   objGetOwnPropertySymbols: () => (/* binding */ objGetOwnPropertySymbols),
/* harmony export */   objGetPrototypeOf: () => (/* binding */ objGetPrototypeOf),
/* harmony export */   objHasOwn: () => (/* binding */ objHasOwn),
/* harmony export */   objHasOwnProperty: () => (/* binding */ objHasOwnProperty),
/* harmony export */   objIs: () => (/* binding */ objIs),
/* harmony export */   objIsExtensible: () => (/* binding */ objIsExtensible),
/* harmony export */   objIsFrozen: () => (/* binding */ objIsFrozen),
/* harmony export */   objIsSealed: () => (/* binding */ objIsSealed),
/* harmony export */   objKeys: () => (/* binding */ objKeys),
/* harmony export */   objPreventExtensions: () => (/* binding */ objPreventExtensions),
/* harmony export */   objPropertyIsEnumerable: () => (/* binding */ objPropertyIsEnumerable),
/* harmony export */   objSeal: () => (/* binding */ objSeal),
/* harmony export */   objSetPrototypeOf: () => (/* binding */ objSetPrototypeOf),
/* harmony export */   objToString: () => (/* binding */ objToString),
/* harmony export */   objValues: () => (/* binding */ objValues),
/* harmony export */   perfNow: () => (/* binding */ perfNow),
/* harmony export */   plainObjDeepCopyHandler: () => (/* binding */ plainObjDeepCopyHandler),
/* harmony export */   polyArrFind: () => (/* binding */ polyArrFind),
/* harmony export */   polyArrFindIndex: () => (/* binding */ polyArrFindIndex),
/* harmony export */   polyArrFindLast: () => (/* binding */ polyArrFindLast),
/* harmony export */   polyArrFindLastIndex: () => (/* binding */ polyArrFindLastIndex),
/* harmony export */   polyArrFrom: () => (/* binding */ polyArrFrom),
/* harmony export */   polyArrIncludes: () => (/* binding */ polyArrIncludes),
/* harmony export */   polyGetKnownSymbol: () => (/* binding */ polyGetKnownSymbol),
/* harmony export */   polyIsArray: () => (/* binding */ polyIsArray),
/* harmony export */   polyNewSymbol: () => (/* binding */ polyNewSymbol),
/* harmony export */   polyObjEntries: () => (/* binding */ polyObjEntries),
/* harmony export */   polyObjHasOwn: () => (/* binding */ polyObjHasOwn),
/* harmony export */   polyObjIs: () => (/* binding */ polyObjIs),
/* harmony export */   polyObjKeys: () => (/* binding */ polyObjKeys),
/* harmony export */   polyStrIncludes: () => (/* binding */ polyStrIncludes),
/* harmony export */   polyStrSubstr: () => (/* binding */ polyStrSubstr),
/* harmony export */   polyStrSymSplit: () => (/* binding */ polyStrSymSplit),
/* harmony export */   polyStrTrim: () => (/* binding */ polyStrTrim),
/* harmony export */   polyStrTrimEnd: () => (/* binding */ polyStrTrimEnd),
/* harmony export */   polyStrTrimStart: () => (/* binding */ polyStrTrimStart),
/* harmony export */   polySymbolFor: () => (/* binding */ polySymbolFor),
/* harmony export */   polySymbolKeyFor: () => (/* binding */ polySymbolKeyFor),
/* harmony export */   polyUtcNow: () => (/* binding */ polyUtcNow),
/* harmony export */   readArgs: () => (/* binding */ readArgs),
/* harmony export */   safe: () => (/* binding */ safe),
/* harmony export */   safeGet: () => (/* binding */ safeGet),
/* harmony export */   safeGetDeferred: () => (/* binding */ safeGetDeferred),
/* harmony export */   safeGetLazy: () => (/* binding */ safeGetLazy),
/* harmony export */   safeGetWritableDeferred: () => (/* binding */ safeGetWritableDeferred),
/* harmony export */   safeGetWritableLazy: () => (/* binding */ safeGetWritableLazy),
/* harmony export */   scheduleIdleCallback: () => (/* binding */ scheduleIdleCallback),
/* harmony export */   scheduleInterval: () => (/* binding */ scheduleInterval),
/* harmony export */   scheduleTimeout: () => (/* binding */ scheduleTimeout),
/* harmony export */   scheduleTimeoutWith: () => (/* binding */ scheduleTimeoutWith),
/* harmony export */   setBypassLazyCache: () => (/* binding */ setBypassLazyCache),
/* harmony export */   setDefaultIdleTimeout: () => (/* binding */ setDefaultIdleTimeout),
/* harmony export */   setDefaultMaxExecutionTime: () => (/* binding */ setDefaultMaxExecutionTime),
/* harmony export */   setGlobalTimeoutOverrides: () => (/* binding */ setGlobalTimeoutOverrides),
/* harmony export */   setTimeoutOverrides: () => (/* binding */ setTimeoutOverrides),
/* harmony export */   setValueByIter: () => (/* binding */ setValueByIter),
/* harmony export */   setValueByKey: () => (/* binding */ setValueByKey),
/* harmony export */   strCamelCase: () => (/* binding */ strCamelCase),
/* harmony export */   strContains: () => (/* binding */ strContains),
/* harmony export */   strEndsWith: () => (/* binding */ strEndsWith),
/* harmony export */   strIncludes: () => (/* binding */ strIncludes),
/* harmony export */   strIndexOf: () => (/* binding */ strIndexOf),
/* harmony export */   strIsNullOrEmpty: () => (/* binding */ strIsNullOrEmpty),
/* harmony export */   strIsNullOrWhiteSpace: () => (/* binding */ strIsNullOrWhiteSpace),
/* harmony export */   strKebabCase: () => (/* binding */ strKebabCase),
/* harmony export */   strLastIndexOf: () => (/* binding */ strLastIndexOf),
/* harmony export */   strLeft: () => (/* binding */ strLeft),
/* harmony export */   strLetterCase: () => (/* binding */ strLetterCase),
/* harmony export */   strLower: () => (/* binding */ strLower),
/* harmony export */   strPadEnd: () => (/* binding */ strPadEnd),
/* harmony export */   strPadStart: () => (/* binding */ strPadStart),
/* harmony export */   strRepeat: () => (/* binding */ strRepeat),
/* harmony export */   strRight: () => (/* binding */ strRight),
/* harmony export */   strSlice: () => (/* binding */ strSlice),
/* harmony export */   strSnakeCase: () => (/* binding */ strSnakeCase),
/* harmony export */   strSplit: () => (/* binding */ strSplit),
/* harmony export */   strStartsWith: () => (/* binding */ strStartsWith),
/* harmony export */   strSubstr: () => (/* binding */ strSubstr),
/* harmony export */   strSubstring: () => (/* binding */ strSubstring),
/* harmony export */   strSymSplit: () => (/* binding */ strSymSplit),
/* harmony export */   strTrim: () => (/* binding */ strTrim),
/* harmony export */   strTrimEnd: () => (/* binding */ strTrimEnd),
/* harmony export */   strTrimLeft: () => (/* binding */ strTrimLeft),
/* harmony export */   strTrimRight: () => (/* binding */ strTrimRight),
/* harmony export */   strTrimStart: () => (/* binding */ strTrimStart),
/* harmony export */   strUpper: () => (/* binding */ strUpper),
/* harmony export */   symbolFor: () => (/* binding */ symbolFor),
/* harmony export */   symbolKeyFor: () => (/* binding */ symbolKeyFor),
/* harmony export */   throwError: () => (/* binding */ throwError),
/* harmony export */   throwRangeError: () => (/* binding */ throwRangeError),
/* harmony export */   throwTypeError: () => (/* binding */ throwTypeError),
/* harmony export */   throwUnsupported: () => (/* binding */ throwUnsupported),
/* harmony export */   utcNow: () => (/* binding */ utcNow)
/* harmony export */ });
/*! https://github.com/nevware21/ts-utils v0.12.5 */
/*
 * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
/*#__NO_SIDE_EFFECTS__*/
function _pureAssign(func1, func2) {
    return func1 || func2;
}
/*#__NO_SIDE_EFFECTS__*/
function _pureRef(value, name) {
    return value[name];
}

var UNDEF_VALUE = undefined;
var NULL_VALUE = null;
var EMPTY = "";
var FUNCTION = "function";
var OBJECT = "object";
var PROTOTYPE = "prototype";
var __PROTO__ = "__proto__";
var UNDEFINED = "undefined";
var CONSTRUCTOR = "constructor";
var SYMBOL = "Symbol";
var LENGTH = "length";
var NAME = "name";
var CALL = "call";
var TO_STRING = "toString";
var GET_OWN_PROPERTY_DESCRIPTOR = "getOwnPropertyDescriptor";
var GET_OWN_PROPERTY_NAMES = "getOwnPropertyNames";
var GET_OWN_PROPERTY_SYMBOLS = "getOwnPropertySymbols";
var ObjClass = ( /*#__PURE__*/_pureAssign(Object));
var ObjProto = ( /*#__PURE__*/_pureRef(ObjClass, PROTOTYPE));
var StrCls = ( /*#__PURE__*/_pureAssign(String));
var StrProto = ( /*#__PURE__*/_pureRef(StrCls, PROTOTYPE));
var MathCls = ( /*#__PURE__*/_pureAssign(Math));
var ArrCls = ( /*#__PURE__*/_pureAssign(Array));
var ArrProto = ( /*#__PURE__*/_pureRef(ArrCls, PROTOTYPE));
var ArrSlice = ( /*#__PURE__*/_pureRef(ArrProto, "slice"));
var NumberCls = ( /*#__PURE__*/_pureAssign(Number));

var POLYFILL_TAG = "_polyfill";
var POLYFILL_TYPE_NAME = "__nw21$polytype__";
function _isPolyfill(obj) {
    return !!(obj && obj[POLYFILL_TAG]);
}
function _isPolyfillType(obj, polyfillTypeName) {
    return !!(obj && obj[POLYFILL_TYPE_NAME] === polyfillTypeName);
}

function safe(func, argArray) {
    try {
        return {
            v: func.apply(this, argArray)
        };
    }
    catch (e) {
        return { e: e };
    }
}

/*#__NO_SIDE_EFFECTS__*/
function safeGet(cb, defValue, argArray) {
    var result = safe(cb, argArray);
    return result.e ? defValue : result.v;
}

var _primitiveTypes;
/*#__NO_SIDE_EFFECTS__*/
function _createIs(theType) {
    return function (value) {
        return typeof value === theType;
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createIsWithPoly(theType) {
    return function (value) {
        return typeof value === theType || _isPolyfillType(value, theType);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createObjIs(theName) {
    var theType = "[object " + theName + "]";
    return function (value) {
        return !!(value && objToString(value) === theType);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function objToString(value) {
    return ObjProto[TO_STRING].call(value);
}
/*#__NO_SIDE_EFFECTS__*/
function isTypeof(value, theType) {
    return typeof value === theType;
}
/*#__NO_SIDE_EFFECTS__*/
function isUndefined(value) {
    return typeof value === UNDEFINED || value === UNDEFINED;
}
/*#__NO_SIDE_EFFECTS__*/
function isStrictUndefined(arg) {
    return arg === UNDEF_VALUE;
}
/*#__NO_SIDE_EFFECTS__*/
function isNullOrUndefined(value) {
    return value === NULL_VALUE || isUndefined(value);
}
/*#__NO_SIDE_EFFECTS__*/
function isStrictNullOrUndefined(value) {
    return value === NULL_VALUE || value === UNDEF_VALUE;
}
/*#__NO_SIDE_EFFECTS__*/
function isDefined(arg) {
    return !!arg || arg !== UNDEF_VALUE;
}
/*#__NO_SIDE_EFFECTS__*/
function isPrimitive(value) {
    return value === NULL_VALUE || isPrimitiveType(typeof value);
}
/*#__NO_SIDE_EFFECTS__*/
function isPrimitiveType(theType) {
    !_primitiveTypes && (_primitiveTypes = ["string", "number", "boolean", UNDEFINED, "symbol", "bigint"]);
    return !!(theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1);
}
var isString = ( /*#__PURE__*/_createIs("string"));
var isFunction = ( /*#__PURE__*/_createIs(FUNCTION));
var isAsyncFunction = ( /*#__PURE__*/_createObjIs("AsyncFunction"));
var isGenerator = ( /*#__PURE__*/_createObjIs("GeneratorFunction"));
var isAsyncGenerator = ( /*#__PURE__*/_createObjIs("AsyncGeneratorFunction"));
/*#__NO_SIDE_EFFECTS__*/
function isObject(value) {
    if (!value && isNullOrUndefined(value)) {
        return false;
    }
    return !!value && typeof value === OBJECT;
}
var isArray = ( /* #__PURE__*/_pureRef(ArrCls, "isArray"));
var isDate = ( /*#__PURE__*/_createObjIs("Date"));
var isNumber = ( /*#__PURE__*/_createIs("number"));
var isBoolean = ( /*#__PURE__*/_createIs("boolean"));
var isRegExp = ( /*#__PURE__*/_createObjIs("RegExp"));
var isFile = ( /*#__PURE__*/_createObjIs("File"));
var isFormData = ( /*#__PURE__*/_createObjIs("FormData"));
var isBlob = ( /*#__PURE__*/_createObjIs("Blob"));
var isArrayBuffer = ( /*#__PURE__*/_createObjIs("ArrayBuffer"));
var isError = ( /*#__PURE__*/_createObjIs("Error"));
/*#__NO_SIDE_EFFECTS__*/
function isPromiseLike(value) {
    return !!(value && value.then && isFunction(value.then));
}
var isThenable = isPromiseLike;
/*#__NO_SIDE_EFFECTS__*/
function isPromise(value) {
    return !!(value && value.then && value.catch && isFunction(value.then) && isFunction(value.catch));
}
var isMap = ( /*#__PURE__*/_createObjIs("Map"));
var isWeakMap = ( /*#__PURE__*/_createObjIs("WeakMap"));
var isSet = ( /*#__PURE__*/_createObjIs("Set"));
var isWeakSet = ( /*#__PURE__*/_createObjIs("WeakSet"));
/*#__NO_SIDE_EFFECTS__*/
function isMapLike(value) {
    return !!(value &&
        isFunction(value.get) &&
        isFunction(value.set) &&
        isFunction(value.has) &&
        isFunction(value.delete) &&
        isNumber(value.size));
}
function isSetLike(value) {
    return !!(value &&
        isFunction(value.add) &&
        isFunction(value.has) &&
        isFunction(value.delete) &&
        isNumber(value.size));
}
/*#__NO_SIDE_EFFECTS__*/
function isNotTruthy(value) {
    return !value || !isTruthy(value);
}
/*#__NO_SIDE_EFFECTS__*/
function isTruthy(value) {
    return !(!value || safeGet(function () { return !(value && (0 + value)); }, !value));
}
var isBigInt = ( /*#__PURE__*/_createIsWithPoly("bigint"));

function _returnNothing() {
    return;
}
function _returnEmptyArray() {
    return [];
}
function _returnFalse() {
    return false;
}

var asString = ( /*#__PURE__*/_pureAssign(StrCls));

var ERROR_TYPE = "[object Error]";
/*#__NO_SIDE_EFFECTS__*/
function dumpObj(object, format) {
    var propertyValueDump = EMPTY;
    var objType = ObjProto[TO_STRING][CALL](object);
    if (objType === ERROR_TYPE) {
        object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };
    }
    try {
        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? ((typeof format === "number") ? format : 4) : UNDEF_VALUE);
        propertyValueDump = (propertyValueDump ? propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") : NULL_VALUE) || asString(object);
    }
    catch (e) {
        propertyValueDump = " - " + dumpObj(e, format);
    }
    return objType + ": " + propertyValueDump;
}

function throwError(message) {
    throw new Error(message);
}
function throwTypeError(message) {
    throw new TypeError(message);
}
function throwRangeError(message) {
    throw new RangeError(message);
}

function _throwIfNullOrUndefined(obj) {
    if (isStrictNullOrUndefined(obj)) {
        throwTypeError("Cannot convert undefined or null to object");
    }
}
function _throwIfNotString(value) {
    if (!isString(value)) {
        throwTypeError("'" + dumpObj(value) + "' is not a string");
    }
}

/*#__NO_SIDE_EFFECTS__*/
function objHasOwnProperty(obj, prop) {
    return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
}

var _objGetOwnPropertyDescriptor$2 = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR)), _returnNothing));
var objHasOwn = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "hasOwn")), polyObjHasOwn));
/*#__NO_SIDE_EFFECTS__*/
function polyObjHasOwn(obj, prop) {
    _throwIfNullOrUndefined(obj);
    return objHasOwnProperty(obj, prop) || !!_objGetOwnPropertyDescriptor$2(obj, prop);
}

function objForEachKey(theObject, callbackfn, thisArg) {
    if (theObject && (isObject(theObject) || isFunction(theObject))) {
        for (var prop in theObject) {
            if (objHasOwn(theObject, prop)) {
                if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {
                    break;
                }
            }
        }
    }
}

function arrForEach(theArray, callbackfn, thisArg) {
    if (theArray) {
        var len = theArray[LENGTH] >>> 0;
        for (var idx = 0; idx < len; idx++) {
            if (idx in theArray) {
                if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                    break;
                }
            }
        }
    }
}

var _unwrapFunction = ( _unwrapFunctionWithPoly);
/*#__NO_SIDE_EFFECTS__*/
function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
    var clsFn = clsProto ? clsProto[funcName] : NULL_VALUE;
    return function (thisArg) {
        var theFunc = (thisArg ? thisArg[funcName] : NULL_VALUE) || clsFn;
        if (theFunc || polyFunc) {
            var theArgs = arguments;
            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);
        }
        throwTypeError("\"" + asString(funcName) + "\" not defined for " + dumpObj(thisArg));
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _unwrapProp(propName) {
    return function (thisArg) {
        return thisArg[propName];
    };
}

function _objPropertyIsEnum(obj, propKey) {
    var desc;
    var fn = ObjClass.getOwnPropertyDescriptor;
    if (!isStrictNullOrUndefined(obj) && fn) {
        desc = safe(fn, [obj, propKey]).v || NULL_VALUE;
    }
    if (!desc) {
        desc = safe(function () {
            for (var key in obj) {
                if (key === propKey) {
                    return { enumerable: true };
                }
            }
        }).v;
    }
    return (desc && desc.enumerable) || false;
}
var objPropertyIsEnumerable = ( /*#__PURE__*/_unwrapFunctionWithPoly("propertyIsEnumerable", NULL_VALUE, _objPropertyIsEnum));

var _objGetOwnPropertyDescriptor$1 = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR)), _returnNothing));
var _objGetOwnPropertySymbols = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_SYMBOLS)), _returnEmptyArray));
var propMap = {
    e: "enumerable",
    c: "configurable",
    v: "value",
    w: "writable",
    g: "get",
    s: "set"
};
/*#__NO_SIDE_EFFECTS__*/
function _createProp(value) {
    var prop = {};
    prop[propMap["c"]] = true;
    prop[propMap["e"]] = true;
    if (value.l) {
        prop.get = function () { return value.l.v; };
        var desc = _objGetOwnPropertyDescriptor$1(value.l, "v");
        if (desc && desc.set) {
            prop.set = function (newValue) {
                value.l.v = newValue;
            };
        }
    }
    objForEachKey(value, function (key, value) {
        prop[propMap[key]] = isStrictUndefined(value) ? prop[propMap[key]] : value;
    });
    return prop;
}
var objDefineProp = ( /*#__PURE__*/_pureRef(ObjClass, "defineProperty"));
var objDefineProperties = ( /*#__PURE__*/_pureRef(ObjClass, "defineProperties"));
function objDefineGet(target, key, value, configurable, enumerable) {
    var _a;
    return objDefineProp(target, key, _createProp((_a = {
            e: enumerable,
            c: configurable
        },
        _a[isFunction(value) ? "g" : "v"] = value,
        _a)));
}
function objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {
    var desc = {
        e: enumerable,
        c: configurable
    };
    if (getProp) {
        desc.g = getProp;
    }
    if (setProp) {
        desc.s = setProp;
    }
    return objDefineProp(target, prop, _createProp(desc));
}
function objDefine(target, key, propDesc) {
    return objDefineProp(target, key, _createProp(propDesc));
}
function objDefineProps(target, propDescMap) {
    var props = {};
    objForEachKey(propDescMap, function (key, value) {
        props[key] = _createProp(value);
    });
    arrForEach(_objGetOwnPropertySymbols(propDescMap), function (sym) {
        if (objPropertyIsEnumerable(propDescMap, sym)) {
            props[sym] = _createProp(propDescMap[sym]);
        }
    });
    return objDefineProperties(target, props);
}

/*#__NO_SIDE_EFFECTS__*/
function _createKeyValueMap(values, keyType, valueType, completeFn, writable) {
    var theMap = {};
    objForEachKey(values, function (key, value) {
        _assignMapValue(theMap, key, keyType ? value : key);
        _assignMapValue(theMap, value, valueType ? value : key);
    });
    return completeFn ? completeFn(theMap) : theMap;
}
function _assignMapValue(theMap, key, value, writable) {
    objDefineProp(theMap, key, {
        value: value,
        enumerable: true,
        writable: false
    });
}

function _objIterateEntries(obj, mapper) {
    var result = [];
    objForEachKey(obj, function (key, val) {
        result.push(mapper(key, val));
    });
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function polyObjKeys(obj) {
    _throwIfNullOrUndefined(obj);
    if (!isObject(obj)) {
        throwTypeError("non-object " + dumpObj(obj));
    }
    return _objIterateEntries(obj, function (k, _) { return k; });
}
/*#__NO_SIDE_EFFECTS__*/
function polyObjEntries(value) {
    return _objIterateEntries(value, function (k, v) { return [k, v]; });
}
/*#__NO_SIDE_EFFECTS__*/
function polyObjValues(value) {
    return _objIterateEntries(value, function (_, v) { return v; });
}

function polyObjIs(value1, value2) {
    if (value1 !== value1) {
        return value2 !== value2;
    }
    if (value1 === 0 && value2 === 0) {
        return 1 / value1 === 1 / value2;
    }
    return value1 === value2;
}

var objIsFrozen = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "isFrozen")), _returnFalse));
var objIsSealed = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "isSealed")), _returnFalse));

var _objFreeze = ( /*#__PURE__*/_pureRef(ObjClass, "freeze"));
function _doNothing(value) {
    return value;
}
/*#__NO_SIDE_EFFECTS__*/
function _getProto(value) {
    _throwIfNullOrUndefined(value);
    return value[__PROTO__] || NULL_VALUE;
}
var objAssign = ( /*#__PURE__*/_pureRef(ObjClass, "assign"));
var objKeys = ( /*#__PURE__*/_pureRef(ObjClass, "keys"));
function _deepFreeze(val, visited) {
    if ((isArray(val) || isObject(val) || isFunction(val)) && !objIsFrozen(val)) {
        for (var lp = 0; lp < visited.length; lp++) {
            if (visited[lp] === val) {
                return val;
            }
        }
        visited.push(val);
        objForEachKey(val, function (_key, propValue) {
            _deepFreeze(propValue, visited);
        });
        objFreeze(val);
    }
    return val;
}
function objDeepFreeze(value) {
    return _objFreeze ? _deepFreeze(value, []) : value;
}
var objFreeze = ( /*#__PURE__*/_pureAssign(_objFreeze, _doNothing));
var objSeal = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "seal")), _doNothing));
var objGetPrototypeOf = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "getPrototypeOf")), _getProto));
var objEntries = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "entries")), polyObjEntries));
var objValues = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "values")), polyObjValues));
var objIs = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "is")), polyObjIs));

/*#__NO_SIDE_EFFECTS__*/
function createEnum(values) {
    return _createKeyValueMap(values, 1 , 0 , objFreeze);
}
/*#__NO_SIDE_EFFECTS__*/
function createEnumKeyMap(values) {
    return _createKeyValueMap(values, 0 , 0 , objFreeze);
}
/*#__NO_SIDE_EFFECTS__*/
function createEnumValueMap(values) {
    return _createKeyValueMap(values, 1 , 1 , objFreeze);
}
/*#__NO_SIDE_EFFECTS__*/
function createSimpleMap(values) {
    var mapClass = {};
    objForEachKey(values, function (key, value) {
        _assignMapValue(mapClass, key, value[1]);
        _assignMapValue(mapClass, value[0], value[1]);
    });
    return objFreeze(mapClass);
}
/*#__NO_SIDE_EFFECTS__*/
function createTypeMap(values) {
    return createSimpleMap(values);
}

var _wellKnownSymbolMap = ( /*#__PURE__*/createEnumKeyMap({
    asyncIterator: 0 ,
    hasInstance: 1 ,
    isConcatSpreadable: 2 ,
    iterator: 3 ,
    match: 4 ,
    matchAll: 5 ,
    replace: 6 ,
    search: 7 ,
    species: 8 ,
    split: 9 ,
    toPrimitive: 10 ,
    toStringTag: 11 ,
    unscopables: 12
}));

var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
var _globalCfg;
/*#__NO_SIDE_EFFECTS__*/
function _getGlobalValue() {
    var result;
    if (typeof globalThis !== UNDEFINED) {
        result = globalThis;
    }
    if (!result && typeof self !== UNDEFINED) {
        result = self;
    }
    if (!result && typeof window !== UNDEFINED) {
        result = window;
    }
    if (!result && typeof global !== UNDEFINED) {
        result = global;
    }
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function _getGlobalConfig() {
    if (!_globalCfg) {
        var gbl = safe(_getGlobalValue).v || {};
        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
    }
    return _globalCfg;
}

var mathMin = ( /*#__PURE__*/_pureRef(MathCls, "min"));
var mathMax = ( /*#__PURE__*/_pureRef(MathCls, "max"));

var strSlice = ( /*#__PURE__*/_unwrapFunction("slice", StrProto));

var strSubstring = ( /*#__PURE__*/_unwrapFunction("substring", StrProto));
var strSubstr = ( /*#__PURE__*/_unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr));
/*#__NO_SIDE_EFFECTS__*/
function polyStrSubstr(value, start, length) {
    _throwIfNullOrUndefined(value);
    if (length < 0) {
        return EMPTY;
    }
    start = start || 0;
    if (start < 0) {
        start = mathMax(start + value[LENGTH], 0);
    }
    if (isUndefined(length)) {
        return strSlice(value, start);
    }
    return strSlice(value, start, start + length);
}
/*#__NO_SIDE_EFFECTS__*/
function strLeft(value, count) {
    return strSubstring(value, 0, count);
}
/*#__NO_SIDE_EFFECTS__*/
function strRight(value, count) {
    return count <= 0 ? EMPTY : (value[LENGTH] > count ? strSlice(value, -count) : value);
}

function _tagAsPolyfill(target, polyfillTypeName) {
    if (target) {
        safe(function () {
            target[POLYFILL_TAG] = true;
            target[POLYFILL_TYPE_NAME] = polyfillTypeName;
        });
        safe(objDefine, [target, POLYFILL_TAG, {
                v: true,
                w: false,
                e: false
            }]);
        safe(objDefine, [target, POLYFILL_TYPE_NAME, {
                v: polyfillTypeName,
                w: false,
                e: false
            }]);
    }
    return target;
}

var objCreate = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, "create")), polyObjCreate));
/*#__NO_SIDE_EFFECTS__*/
function polyObjCreate(obj, properties) {
    var newObj = null;
    function tempFunc() { }
    if (!isStrictNullOrUndefined(obj)) {
        var type = typeof obj;
        if (type !== OBJECT && type !== FUNCTION) {
            throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
        }
        tempFunc[PROTOTYPE] = obj;
        safe(function () {
            tempFunc[__PROTO__] = obj;
        });
        newObj = new tempFunc();
    }
    else {
        newObj = {};
    }
    if (properties) {
        safe(objDefineProperties, [newObj, properties]);
    }
    return newObj;
}

/*#__NO_SIDE_EFFECTS__*/
function utcNow() {
    return (Date.now || polyUtcNow)();
}
/*#__NO_SIDE_EFFECTS__*/
function polyUtcNow() {
    return new Date().getTime();
}

function fnApply(fn, thisArg, argArray) {
    return fn.apply(thisArg, argArray);
}
function fnCall(fn, thisArg) {
    return fn.apply(thisArg, ArrSlice[CALL](arguments, 2));
}
function fnBind(fn, thisArg) {
    return fn.bind.apply(fn, ArrSlice[CALL](arguments, 1));
}

var _globalLazyTestHooks;
function _initTestHooks() {
    _globalLazyTestHooks = _getGlobalConfig();
}
/*#__NO_SIDE_EFFECTS__*/
function getLazy(cb, argArray) {
    var lazyValue = {};
    !_globalLazyTestHooks && _initTestHooks();
    lazyValue.b = _globalLazyTestHooks.lzy;
    objDefineProp(lazyValue, "v", {
        configurable: true,
        get: function () {
            var result = fnApply(cb, null, argArray);
            if (!_globalLazyTestHooks.lzy) {
                objDefineProp(lazyValue, "v", {
                    value: result
                });
            }
            lazyValue.b = _globalLazyTestHooks.lzy;
            return result;
        }
    });
    return lazyValue;
}
function setBypassLazyCache(newValue) {
    !_globalLazyTestHooks && _initTestHooks();
    _globalLazyTestHooks.lzy = newValue;
}
function getWritableLazy(cb, argArray) {
    var lazyValue = {};
    !_globalLazyTestHooks && _initTestHooks();
    lazyValue.b = _globalLazyTestHooks.lzy;
    var _setValue = function (newValue) {
        objDefineProp(lazyValue, "v", {
            value: newValue,
            writable: true
        });
        if (lazyValue.b) {
            delete lazyValue.b;
        }
    };
    objDefineProp(lazyValue, "v", {
        configurable: true,
        get: function () {
            var result = fnApply(cb, null, argArray);
            if (!_globalLazyTestHooks.lzy) {
                _setValue(result);
            }
            if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {
                lazyValue.b = _globalLazyTestHooks.lzy;
            }
            return result;
        },
        set: _setValue
    });
    return lazyValue;
}

var mathRandom = ( /*#__PURE__*/_pureRef(MathCls, "random"));

var _uniqueInstanceId = ( /*#__PURE__*/getLazy(function () {
    var value = (utcNow().toString(36).slice(2));
    while (value.length < 16) {
        value += mathRandom().toString(36).slice(2);
    }
    value = value.substring(0, 16);
    return value;
}));

var UNIQUE_REGISTRY_ID = "_urid";
var POLY_SYM = "$nw21sym";
var _polySymbols;
var _polyId = 0;
/*#__NO_SIDE_EFFECTS__*/
function _globalSymbolRegistry() {
    if (!_polySymbols) {
        var gblCfg = _getGlobalConfig();
        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
    }
    return _polySymbols;
}
var _wellKnownSymbolCache;
/*#__NO_SIDE_EFFECTS__*/
function polyNewSymbol(description) {
    var uniqueId = "_" + _polyId++ + "_" + _uniqueInstanceId.v;
    var symString = SYMBOL + "(" + description + ")";
    function _setProp(name, value) {
        objDefine(theSymbol, name, {
            v: value,
            e: false,
            w: false
        });
    }
    var theSymbol = objCreate(null);
    _setProp("description", asString(description));
    _setProp(TO_STRING, function () { return symString + POLY_SYM + uniqueId; });
    _setProp("valueOf", function () { return theSymbol; });
    _setProp("v", symString);
    _setProp("_uid", uniqueId);
    return _tagAsPolyfill(theSymbol, "symbol");
}
/*#__NO_SIDE_EFFECTS__*/
function polySymbolFor(key) {
    var registry = _globalSymbolRegistry();
    if (!objHasOwn(registry.k, key)) {
        var newSymbol_1 = polyNewSymbol(key);
        var regId_1 = objKeys(registry.s).length;
        newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + "_" + newSymbol_1[TO_STRING](); };
        registry.k[key] = newSymbol_1;
        registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
    }
    return registry.k[key];
}
/*#__NO_SIDE_EFFECTS__*/
function polySymbolKeyFor(sym) {
    if (!sym || !sym[TO_STRING] || strSubstring(sym[TO_STRING](), 0, 6) != SYMBOL) {
        throwTypeError(sym + " is not a symbol");
    }
    var regId = _isPolyfill(sym) && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();
    return regId ? _globalSymbolRegistry().s[regId] : undefined;
}
/*#__NO_SIDE_EFFECTS__*/
function polyGetKnownSymbol(name) {
    !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
    var result;
    var knownName = _wellKnownSymbolMap[name];
    if (knownName) {
        result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
    }
    return result;
}

/*#__NO_SIDE_EFFECTS__*/
function createCachedValue(value) {
    return objDefineProp({
        toJSON: function () { return value; }
    }, "v", { value: value });
}
var createDeferredCachedValue = getDeferred;
/*#__NO_SIDE_EFFECTS__*/
function getDeferred(cb, argArray) {
    var theValue = {
        toJSON: function () { return theValue.v; }
    };
    return objDefineProp(theValue, "v", {
        get: function () {
            var result = fnApply(cb, null, argArray);
            cb = NULL_VALUE;
            objDefineProp(theValue, "v", { value: result });
            return result;
        },
        configurable: true
    });
}
/*#__NO_SIDE_EFFECTS__*/
function getWritableDeferred(cb, argArray) {
    var theValue = {
        toJSON: function () { return theValue.v; }
    };
    var _setValue = function (newValue) {
        objDefineProp(theValue, "v", {
            value: newValue,
            writable: true
        });
    };
    return objDefineProp(theValue, "v", {
        get: function () {
            var result = fnApply(cb, null, argArray);
            _setValue(result);
            cb = NULL_VALUE;
            return result;
        },
        set: _setValue,
        configurable: true
    });
}

var WINDOW = "window";
var _cachedGlobal;
function _getGlobalInstFn(getFn, theArgs) {
    var cachedValue;
    return function () {
        !_globalLazyTestHooks && _initTestHooks();
        if (!cachedValue || _globalLazyTestHooks.lzy) {
            cachedValue = createCachedValue(safe(getFn, theArgs).v);
        }
        return cachedValue.v;
    };
}
/*#__NO_SIDE_EFFECTS__*/
function lazySafeGetInst(name) {
    return getLazy(function () { return safe((getInst), [name]).v || UNDEF_VALUE; });
}
function getGlobal(useCached) {
    !_globalLazyTestHooks && _initTestHooks();
    if (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) {
        _cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE);
    }
    return _cachedGlobal.v;
}
/*#__NO_SIDE_EFFECTS__*/
function getInst(name, useCached) {
    var gbl;
    if (!_cachedGlobal || useCached === false) {
        gbl = getGlobal(useCached);
    }
    else {
        gbl = _cachedGlobal.v;
    }
    if (gbl && gbl[name]) {
        return gbl[name];
    }
    if (name === WINDOW) {
        try {
            return window;
        }
        catch (e) {
        }
    }
    return NULL_VALUE;
}
/*#__NO_SIDE_EFFECTS__*/
function hasDocument() {
    return !!( /*#__PURE__*/getDocument());
}
var getDocument = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["document"]));
/*#__NO_SIDE_EFFECTS__*/
function hasWindow() {
    return !!( /*#__PURE__*/getWindow());
}
var getWindow = ( /*#__PURE__*/_getGlobalInstFn(getInst, [WINDOW]));
/*#__NO_SIDE_EFFECTS__*/
function hasNavigator() {
    return !!( /*#__PURE__*/getNavigator());
}
var getNavigator = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["navigator"]));
/*#__NO_SIDE_EFFECTS__*/
function hasHistory() {
    return !!( /*#__PURE__*/getHistory());
}
var getHistory = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["history"]));
var isNode = ( /*#__PURE__*/_getGlobalInstFn(function () {
    return !!( /*#__PURE__*/safe(function () { return (process && (process.versions || {}).node); }).v);
}));
var isWebWorker = ( /*#__PURE__*/_getGlobalInstFn(function () {
    return !!( /*#__PURE__*/safe(function () { return self && self instanceof WorkerGlobalScope; }).v);
}));

var _symbol;
var _symbolFor;
var _symbolKeyFor;
/*#__NO_SIDE_EFFECTS__*/
function _initSymbol() {
    _symbol = ( /*#__PURE__*/createCachedValue(safe((getInst), [SYMBOL]).v));
    return _symbol;
}
function _getSymbolKey(key) {
    var gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
    return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE);
}
var isSymbol = ( /*#__PURE__*/_createIsWithPoly("symbol"));
/*#__NO_SIDE_EFFECTS__*/
function hasSymbol() {
    return !!( /*#__PURE__*/getSymbol());
}
/*#__NO_SIDE_EFFECTS__*/
function getSymbol() {
    !_globalLazyTestHooks && _initTestHooks();
    return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol()).v;
}
/*#__NO_SIDE_EFFECTS__*/
function getKnownSymbol(name, noPoly) {
    var knownName = _wellKnownSymbolMap[name];
    !_globalLazyTestHooks && _initTestHooks();
    var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
    return sym.v ? sym.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
}
/*#__NO_SIDE_EFFECTS__*/
function newSymbol(description, noPoly) {
    !_globalLazyTestHooks && _initTestHooks();
    var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());
    return sym.v ? sym.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);
}
/*#__NO_SIDE_EFFECTS__*/
function symbolFor(key) {
    !_globalLazyTestHooks && _initTestHooks();
    _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), ["for"]).v)));
    return (_symbolFor.v || polySymbolFor)(key);
}
/*#__NO_SIDE_EFFECTS__*/
function symbolKeyFor(sym) {
    !_globalLazyTestHooks && _initTestHooks();
    _symbolKeyFor = ((!_globalLazyTestHooks.lzy ? _symbolKeyFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), ["keyFor"]).v)));
    return (_symbolKeyFor.v || polySymbolKeyFor)(sym);
}

/*#__NO_SIDE_EFFECTS__*/
function isIterator(value) {
    return !!value && isFunction(value.next);
}
/*#__NO_SIDE_EFFECTS__*/
function isIterable(value) {
    return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);
}

var _iterSymbol$1;
function iterForOf(iter, callbackfn, thisArg) {
    if (iter) {
        if (!isIterator(iter)) {
            !_iterSymbol$1 && (_iterSymbol$1 = createCachedValue(getKnownSymbol(3 )));
            iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : NULL_VALUE;
        }
        if (isIterator(iter)) {
            var err = UNDEF_VALUE;
            var iterResult = UNDEF_VALUE;
            try {
                var count = 0;
                while (!(iterResult = iter.next()).done) {
                    if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {
                        break;
                    }
                    count++;
                }
            }
            catch (failed) {
                err = { e: failed };
                if (iter.throw) {
                    iterResult = NULL_VALUE;
                    iter.throw(err);
                }
            }
            finally {
                try {
                    if (iterResult && !iterResult.done) {
                        iter.return && iter.return(iterResult);
                    }
                }
                finally {
                    if (err) {
                        // eslint-disable-next-line no-unsafe-finally
                        throw err.e;
                    }
                }
            }
        }
    }
}

function arrAppend(target, elms) {
    if (!isUndefined(elms) && target) {
        if (isArray(elms)) {
            fnApply(target.push, target, elms);
        }
        else if (isIterator(elms) || isIterable(elms)) {
            iterForOf(elms, function (elm) {
                target.push(elm);
            });
        }
        else {
            target.push(elms);
        }
    }
    return target;
}

var arrEvery = /*#__PURE__*/ _unwrapFunction("every", ArrProto);
var arrFilter = /*#__PURE__*/ _unwrapFunction("filter", ArrProto);

var arrIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", ArrProto));
var arrLastIndexOf = ( /*#__PURE__*/_unwrapFunction("lastIndexOf", ArrProto));

var arrMap = ( /*#__PURE__*/_unwrapFunction("map", ArrProto));

function arrSlice(theArray, start, end) {
    return ((theArray ? theArray["slice"] : NULL_VALUE) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));
}

/*#__NO_SIDE_EFFECTS__*/
function polyIsArray(value) {
    if (isNullOrUndefined(value)) {
        return false;
    }
    return objToString(value) === "[object Array]";
}
/*#__NO_SIDE_EFFECTS__*/
function polyArrIncludes(theArray, searchElement, fromIndex) {
    return arrIndexOf(theArray, searchElement, fromIndex) !== -1;
}
function polyArrFind(theArray, callbackFn, thisArg) {
    var result;
    var idx = polyArrFindIndex(theArray, callbackFn, thisArg);
    return idx !== -1 ? theArray[idx] : result;
}
function polyArrFindIndex(theArray, callbackFn, thisArg) {
    var result = -1;
    arrForEach(theArray, function (value, index) {
        if (callbackFn[CALL](thisArg | theArray, value, index, theArray)) {
            result = index;
            return -1;
        }
    });
    return result;
}
function polyArrFindLast(theArray, callbackFn, thisArg) {
    var result;
    var idx = polyArrFindLastIndex(theArray, callbackFn, thisArg);
    return idx !== -1 ? theArray[idx] : result;
}
function polyArrFindLastIndex(theArray, callbackFn, thisArg) {
    var result = -1;
    var len = theArray[LENGTH] >>> 0;
    for (var idx = len - 1; idx >= 0; idx--) {
        if (idx in theArray && callbackFn[CALL](thisArg | theArray, theArray[idx], idx, theArray)) {
            result = idx;
            break;
        }
    }
    return result;
}
function polyArrFrom(theValue, mapFn, thisArg) {
    if (isArray(theValue)) {
        var result_1 = arrSlice(theValue);
        return mapFn ? arrMap(result_1, mapFn, thisArg) : result_1;
    }
    var result = [];
    iterForOf(theValue, function (value, cnt) {
        return result.push(mapFn ? mapFn[CALL](thisArg, value, cnt) : value);
    });
    return result;
}

var arrFind = /*#__PURE__*/ _unwrapFunctionWithPoly("find", ArrProto, polyArrFind);
var arrFindIndex = /*#__PURE__*/ _unwrapFunctionWithPoly("findIndex", ArrProto, polyArrFindIndex);
var arrFindLast = /*#__PURE__*/ _unwrapFunctionWithPoly("findLast", ArrProto, polyArrFindLast);
var arrFindLastIndex = /*#__PURE__*/ _unwrapFunctionWithPoly("findLastIndex", ArrProto, polyArrFindLastIndex);

var arrFrom = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ArrCls, "from")), polyArrFrom));

var arrIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly("includes", ArrProto, polyArrIncludes));
var arrContains = arrIncludes;

var arrReduce = ( /*#__PURE__*/_unwrapFunction("reduce", ArrProto));

var arrSome = ( /*#__PURE__*/_unwrapFunction("some", ArrProto));

/*#__NO_SIDE_EFFECTS__*/
function createFnDeferredProxy(hostFn, funcName) {
    return function () {
        var theArgs = ArrSlice[CALL](arguments);
        var theHost = hostFn();
        return fnApply(theHost[funcName], theHost, theArgs);
    };
}
function createProxyFuncs(target, host, funcDefs) {
    if (target && host && isArray(funcDefs)) {
        var isDeferred_1 = isFunction(host);
        arrForEach(funcDefs, function (funcDef) {
            var targetName = (funcDef.as || funcDef.n);
            if (funcDef.rp === false && target[targetName]) {
                return;
            }
            target[targetName] = isDeferred_1 ?
                createFnDeferredProxy(host, funcDef.n) :
                fnBind(host[funcDef.n], host);
        });
    }
    return target;
}

var _iterSymbol;
/*#__NO_SIDE_EFFECTS__*/
function readArgs(theArgs, start, end) {
    if (!objHasOwn(theArgs, LENGTH)) {
        !_iterSymbol && (_iterSymbol = createCachedValue(hasSymbol() && getKnownSymbol(3 )));
        var iterFn = void 0;
        if (_iterSymbol.v) {
            iterFn = theArgs[_iterSymbol.v];
        }
        if (iterFn) {
            var values_1 = [];
            var from_1 = (start === UNDEF_VALUE || start < 0) ? 0 : start;
            var to_1 = end < 0 || start < 0 ? UNDEF_VALUE : end;
            iterForOf(iterFn[CALL](theArgs), function (value, cnt) {
                if (to_1 !== UNDEF_VALUE && cnt >= to_1) {
                    return -1;
                }
                if (cnt >= from_1) {
                    values_1.push(value);
                }
            });
            if ((start === UNDEF_VALUE || start >= 0) && (end === UNDEF_VALUE || end >= 0)) {
                return values_1;
            }
            theArgs = values_1;
        }
    }
    return arrSlice(theArgs, start, end);
}

var _isProtoArray;
var objSetPrototypeOf = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "setPrototypeOf")), _polyObjSetPrototypeOf));
function _polyObjSetPrototypeOf(obj, proto) {
    var _a;
    !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a) instanceof Array));
    _isProtoArray.v ? obj[__PROTO__] = proto : objForEachKey(proto, function (key, value) { return obj[key] = value; });
    return obj;
}

/*#__NO_SIDE_EFFECTS__*/
function _createCustomError(name, d, b) {
    safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);
    d = objSetPrototypeOf(d, b);
    function __() {
        this[CONSTRUCTOR] = d;
        safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);
    }
    d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
    return d;
}
function _setName(baseClass, name) {
    name && (baseClass[NAME] = name);
}
/*#__NO_SIDE_EFFECTS__*/
function createCustomError(name, constructCb, errorBase) {
    var theBaseClass = errorBase || Error;
    var orgName = theBaseClass[PROTOTYPE][NAME];
    var captureFn = Error.captureStackTrace;
    return _createCustomError(name, function () {
        var _this = this;
        var theArgs = arguments;
        try {
            safe(_setName, [theBaseClass, name]);
            var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;
            if (_self !== _this) {
                var orgProto = objGetPrototypeOf(_this);
                if (orgProto !== objGetPrototypeOf(_self)) {
                    objSetPrototypeOf(_self, orgProto);
                }
            }
            captureFn && captureFn(_self, _this[CONSTRUCTOR]);
            constructCb && constructCb(_self, theArgs);
            return _self;
        }
        finally {
            safe(_setName, [theBaseClass, orgName]);
        }
    }, theBaseClass);
}
var _unsupportedError;
function throwUnsupported(message) {
    if (!_unsupportedError) {
        _unsupportedError = createCustomError("UnsupportedError");
    }
    throw new _unsupportedError(message);
}

function isElement(value) {
    return !!value && value.nodeType === 1 &&
        !!value.nodeName &&
        !!(typeof Element !== "undefined" && value instanceof Element);
}
function isElementLike(value) {
    return !!value && value.nodeType === 1 && !!value.nodeName;
}

function isEmpty(value) {
    var result = isStrictNullOrUndefined(value);
    if (!result) {
        if (isString(value) || isArray(value)) {
            result = (value.length === 0);
        }
        else if (isMapLike(value) || isSetLike(value)) {
            result = (value.size === 0);
        }
        else if (isObject(value)) {
            result = objKeys(value).length === 0;
        }
    }
    return result;
}

/*#__NO_SIDE_EFFECTS__*/
function _createTrimFn(exp) {
    return function _doTrim(value) {
        _throwIfNullOrUndefined(value);
        if (value && value.replace) {
            value = value.replace(exp, EMPTY);
        }
        return value;
    };
}
var polyStrTrim = ( /*#__PURE__*/_createTrimFn(/^\s+|(?=\s)\s+$/g));
var polyStrTrimStart = ( /*#__PURE__*/_createTrimFn(/^\s+/g));
var polyStrTrimEnd = ( /*#__PURE__*/_createTrimFn(/(?=\s)\s+$/g));

var strTrim = ( /*#__PURE__*/_unwrapFunctionWithPoly("trim", StrProto, polyStrTrim));
var strTrimStart = ( /*#__PURE__*/_unwrapFunctionWithPoly("trimStart", StrProto, polyStrTrimStart));
var strTrimLeft = ( /*#__PURE__*/_pureAssign(strTrimStart));
var strTrimEnd = ( /*#__PURE__*/_unwrapFunctionWithPoly("trimEnd", StrProto, polyStrTrimEnd));
var strTrimRight = ( /*#__PURE__*/_pureAssign(strTrimEnd));

var strUpper = ( /*#__PURE__*/_unwrapFunction("toUpperCase", StrProto));
var strLower = ( /*#__PURE__*/_unwrapFunction("toLowerCase", StrProto));

/*#__NO_SIDE_EFFECTS__*/
function _convertCase(value, newPrefix, upperWord) {
    return strTrim(asString(value)).replace(/((_|\W)+(\w){0,1}|([a-z])([A-Z]))/g, function (_match, _g1, _g2, wordStart, upperPrefix, upperLetter) {
        var convertMatch = wordStart || upperLetter || EMPTY;
        if (upperWord) {
            convertMatch = strUpper(convertMatch);
        }
        return (upperPrefix || EMPTY) + newPrefix + convertMatch;
    });
}
/*#__NO_SIDE_EFFECTS__*/
function strLetterCase(value) {
    return asString(value).replace(/(_|\b)\w/g, strUpper);
}
/*#__NO_SIDE_EFFECTS__*/
function strCamelCase(value, upperFirst) {
    var result = _convertCase(value, "", true);
    return result.replace(/^\w/, upperFirst ? strUpper : strLower);
}
/*#__NO_SIDE_EFFECTS__*/
function strKebabCase(value, scream) {
    var result = _convertCase(value, "-");
    return (scream ? strUpper : strLower)(result);
}
/*#__NO_SIDE_EFFECTS__*/
function strSnakeCase(value, scream) {
    var result = _convertCase(value, "_");
    return (scream ? strUpper : strLower)(result);
}

var mathFloor = ( /*#__PURE__*/_pureRef(MathCls, "floor"));
var mathCeil = ( /*#__PURE__*/_pureRef(MathCls, "ceil"));

var mathTrunc = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(MathCls, "trunc")), polyMathTrunc));
/*#__NO_SIDE_EFFECTS__*/
function polyMathTrunc(value) {
    var theValue = +value;
    return (theValue > 0 ? mathFloor : mathCeil)(theValue);
}

/*#__NO_SIDE_EFFECTS__*/
function mathToInt(value, throwInfinity) {
    var result = +value;
    if (throwInfinity && (result === Infinity || result == Infinity)) {
        throwRangeError("invalid value [" + dumpObj(value) + "]");
    }
    return result !== result || result === 0 ? 0 : mathTrunc(result);
}

var strRepeat = ( /*#__PURE__*/_unwrapFunctionWithPoly("repeat", StrProto, polyStrRepeat));
/*#__NO_SIDE_EFFECTS__*/
function polyStrRepeat(value, count) {
    _throwIfNullOrUndefined(value);
    count = mathToInt(count, true);
    if (count < 0) {
        throwRangeError("invalid count must be >= 0 && < Infinity");
    }
    var pad = isString(value) ? value : asString(value);
    var result = EMPTY;
    for (; count > 0; (count >>>= 1) && (pad += pad)) {
        if (count & 1) {
            result += pad;
        }
    }
    return result;
}

/*#__NO_SIDE_EFFECTS__*/
function _padValue(value, targetLength, padString) {
    var result = EMPTY;
    targetLength = mathToInt(targetLength, true);
    targetLength >>= 0;
    var len = value[LENGTH];
    if (len < targetLength) {
        result = isNullOrUndefined(padString) ? " " : asString(padString);
        targetLength = targetLength - len;
        if (targetLength > result[LENGTH]) {
            result = strRepeat(result, mathCeil(targetLength / result[LENGTH]));
        }
        if (result[LENGTH] > targetLength) {
            result = strSubstring(result, 0, targetLength);
        }
    }
    return result;
}
var strPadStart = ( /*#__PURE__*/_unwrapFunctionWithPoly("padStart", StrProto, polyStrPadStart));
var strPadEnd = ( /*#__PURE__*/_unwrapFunctionWithPoly("padEnd", StrProto, polyStrPadEnd));
/*#__NO_SIDE_EFFECTS__*/
function polyStrPadStart(value, targetLength, padString) {
    return _padValue(value, targetLength, padString) + value;
}
/*#__NO_SIDE_EFFECTS__*/
function polyStrPadEnd(value, targetLength, padString) {
    return value + _padValue(value, targetLength, padString);
}

var DBL_QUOTE = "\"";
var INVALID_JS_NAME = /([^\w\d_$])/g;
var _htmlEntityCache;
/*#__NO_SIDE_EFFECTS__*/
function normalizeJsName(jsName, camelCase) {
    var result = asString(jsName).replace(INVALID_JS_NAME, "_");
    return !isUndefined(camelCase) ? strCamelCase(result, !camelCase) : result;
}
/*#__NO_SIDE_EFFECTS__*/
function encodeAsJson(value, format) {
    var result;
    if (isString(value)) {
        result = DBL_QUOTE + value.replace(/[^\w .,\-!@#$%\^&*\(\)_+={}\[\]:;|<>?]/g, function (match) {
            if (match === DBL_QUOTE || match === "\\") {
                return "\\" + match;
            }
            var hex = match.charCodeAt(0)[TO_STRING](16);
            return "\\u" + strPadStart(strUpper(hex), 4, "0");
        }) + DBL_QUOTE;
    }
    else {
        try {
            result = JSON.stringify(value, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
        }
        catch (e) {
            result = DBL_QUOTE + dumpObj(e) + DBL_QUOTE;
        }
    }
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function encodeAsHtml(value) {
    !_htmlEntityCache && (_htmlEntityCache = {
        "&": "amp",
        "<": "lt",
        ">": "gt",
        "\"": "quot",
        "'": "#39"
    });
    return asString(value).replace(/[&<>"']/g, function (match) { return "&" + _htmlEntityCache[match] + ";"; });
}

var _fnToString;
var _objCtrFnString;
var _gblWindow;
/*#__NO_SIDE_EFFECTS__*/
function isPlainObject(value) {
    if (!value || typeof value !== OBJECT) {
        return false;
    }
    if (!_gblWindow) {
        _gblWindow = hasWindow() ? getWindow() : true;
    }
    var result = false;
    if (value !== _gblWindow) {
        if (!_objCtrFnString) {
            _fnToString = Function[PROTOTYPE][TO_STRING];
            _objCtrFnString = _fnToString[CALL](ObjClass);
        }
        try {
            var proto = objGetPrototypeOf(value);
            result = !proto;
            if (!result) {
                if (objHasOwnProperty(proto, CONSTRUCTOR)) {
                    proto = proto[CONSTRUCTOR];
                }
                result = !!(proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString);
            }
        }
        catch (ex) {
        }
    }
    return result;
}

/*#__NO_SIDE_EFFECTS__*/
function _defaultDeepCopyHandler(details) {
    details.value && plainObjDeepCopyHandler(details);
    return true;
}
var defaultDeepCopyHandlers = [
    arrayDeepCopyHandler,
    plainObjDeepCopyHandler,
    functionDeepCopyHandler,
    dateDeepCopyHandler
];
/*#__NO_SIDE_EFFECTS__*/
function _getSetVisited(visitMap, source, newPath, cb) {
    var theEntry;
    arrForEach(visitMap, function (entry) {
        if (entry.k === source) {
            theEntry = entry;
            return -1;
        }
    });
    if (!theEntry) {
        theEntry = { k: source, v: source };
        visitMap.push(theEntry);
        cb(theEntry);
    }
    return theEntry.v;
}
function _deepCopy(visitMap, value, ctx, key) {
    var userHandler = ctx.handler;
    var newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];
    var newCtx = {
        handler: ctx.handler,
        src: ctx.src,
        path: newPath
    };
    var theType = typeof value;
    var isPlain = false;
    var isPrim = value === NULL_VALUE;
    if (!isPrim) {
        if (value && theType === OBJECT) {
            isPlain = isPlainObject(value);
        }
        else {
            isPrim = isPrimitiveType(theType);
        }
    }
    var details = {
        type: theType,
        isPrim: isPrim,
        isPlain: isPlain,
        value: value,
        result: value,
        path: newPath,
        origin: ctx.src,
        copy: function (source, newKey) {
            return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
        },
        copyTo: function (target, source) {
            return _copyProps(visitMap, target, source, newCtx);
        }
    };
    if (!details.isPrim) {
        return _getSetVisited(visitMap, value, newPath, function (newEntry) {
            objDefine(details, "result", {
                g: function () {
                    return newEntry.v;
                },
                s: function (newValue) {
                    newEntry.v = newValue;
                }
            });
            var idx = 0;
            var handler = userHandler;
            while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {
                handler = NULL_VALUE;
            }
        });
    }
    if (userHandler && userHandler[CALL](ctx, details)) {
        return details.result;
    }
    return value;
}
function _copyProps(visitMap, target, source, ctx) {
    if (!isNullOrUndefined(source)) {
        for (var key in source) {
            target[key] = _deepCopy(visitMap, source[key], ctx, key);
        }
    }
    return target;
}
function objCopyProps(target, source, handler) {
    var ctx = {
        handler: handler,
        src: source,
        path: []
    };
    return _copyProps([], target, source, ctx);
}
/*#__NO_SIDE_EFFECTS__*/
function objDeepCopy(source, handler) {
    var ctx = {
        handler: handler,
        src: source
    };
    return _deepCopy([], source, ctx);
}
function arrayDeepCopyHandler(details) {
    var value = details.value;
    if (isArray(value)) {
        var target = details.result = [];
        target.length = value.length;
        details.copyTo(target, value);
        return true;
    }
    return false;
}
function dateDeepCopyHandler(details) {
    var value = details.value;
    if (isDate(value)) {
        details.result = new Date(value.getTime());
        return true;
    }
    return false;
}
function functionDeepCopyHandler(details) {
    if (details.type === FUNCTION) {
        return true;
    }
    return false;
}
function plainObjDeepCopyHandler(details) {
    var value = details.value;
    if (value && details.isPlain) {
        var target = details.result = {};
        details.copyTo(target, value);
        return true;
    }
    return false;
}

function _doExtend(target, theArgs) {
    arrForEach(theArgs, function (theArg) {
        objCopyProps(target, theArg);
    });
    return target;
}
function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
    return _doExtend(objDeepCopy(target) || {}, ArrSlice[CALL](arguments));
}
function objExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
    return _doExtend(target || {}, ArrSlice[CALL](arguments));
}

/*#__NO_SIDE_EFFECTS__*/
function polyStrSymSplit(value, splitter, limit) {
    var splitFn = splitter ? splitter[getKnownSymbol(9 )] : UNDEF_VALUE;
    return splitFn ? splitFn(value, limit) : [value];
}

var strSplit = ( /*#__PURE__*/_unwrapFunction("split", StrProto));
var strSymSplit = ( /*#__PURE__*/_unwrapFunctionWithPoly("split", StrProto, polyStrSymSplit));

/*#__NO_SIDE_EFFECTS__*/
function getValueByKey(target, path, defValue) {
    if (!path || !target) {
        return defValue;
    }
    var parts = strSplit(path, ".");
    var cnt = parts.length;
    for (var lp = 0; lp < cnt && !isNullOrUndefined(target); lp++) {
        target = target[parts[lp]];
    }
    return (!isNullOrUndefined(target) ? target : defValue);
}
/*#__NO_SIDE_EFFECTS__*/
function getValueByIter(target, iter, defValue) {
    if (!iter || !target) {
        return defValue;
    }
    iterForOf(iter, function (value) {
        if (isNullOrUndefined(target)) {
            return -1;
        }
        target = target[value];
    });
    return (!isNullOrUndefined(target) ? target : defValue);
}
function setValueByKey(target, path, value) {
    if (target && path) {
        var parts = strSplit(path, ".");
        var lastKey = parts.pop();
        arrForEach(parts, function (key) {
            if (isNullOrUndefined(target[key])) {
                target[key] = {};
            }
            target = target[key];
        });
        target[lastKey] = value;
    }
}
function setValueByIter(target, iter, value) {
    if (target && iter) {
        var lastKey_1;
        iterForOf(iter, function (key) {
            if (lastKey_1) {
                if (isNullOrUndefined(target[lastKey_1])) {
                    target[lastKey_1] = {};
                }
                target = target[lastKey_1];
            }
            lastKey_1 = key;
        });
        target[lastKey_1] = value;
    }
}

var getLength = ( /*#__PURE__*/_unwrapProp(LENGTH));

/*#__NO_SIDE_EFFECTS__*/
function getIntValue(value, defValue) {
    try {
        var theValue = value;
        if (!isNumber(value)) {
            theValue = parseInt(asString(value), 10);
        }
        return (isNullOrUndefined(value) || isNaN(theValue)) ? defValue : theValue;
    }
    catch (e) {
    }
    return defValue;
}
var isInteger = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(NumberCls, "isInteger")), _polyNumberIsInteger));
function _polyNumberIsInteger(value) {
    return isNumber(value) && !isNaN(value) &&
        isFinite(value) &&
        mathFloor(value) === value;
}
function isFiniteNumber(value) {
    return isNumber(value) && !isNaN(value) && isFinite(value);
}

var _perf;
/*#__NO_SIDE_EFFECTS__*/
function hasPerformance() {
    return !!getPerformance();
}
/*#__NO_SIDE_EFFECTS__*/
function getPerformance() {
    !_globalLazyTestHooks && _initTestHooks();
    if (!_perf || _globalLazyTestHooks.lzy) {
        _perf = createCachedValue(safe((getInst), ["performance"]).v);
    }
    return _perf.v;
}
/*#__NO_SIDE_EFFECTS__*/
function perfNow() {
    var perf = getPerformance();
    if (perf && perf.now) {
        return perf.now();
    }
    return utcNow();
}
/*#__NO_SIDE_EFFECTS__*/
function elapsedTime(startTime) {
    return perfNow() - startTime;
}

var MATCH_ANY = "(.*)";
var MATCH_SINGLE = "(.)";
function _createRegExp(value, escapeRgx, replaceFn, ignoreCase, fullMatch) {
    // eslint-disable-next-line security/detect-non-literal-regexp
    return new RegExp((fullMatch ? "^" : EMPTY) + replaceFn(value.replace(escapeRgx, "\\$1")) + (fullMatch ? "$" : EMPTY), ignoreCase ? "i" : "");
}
/*#__NO_SIDE_EFFECTS__*/
function createWildcardRegex(value, ignoreCase, fullMatch) {
    return _createRegExp(asString(value), /([-+|^$#\.\?{}()\[\]\\\/\"\'])/g, function (value) {
        return value.replace(/\*/g, MATCH_ANY);
    }, !!ignoreCase, fullMatch);
}
/*#__NO_SIDE_EFFECTS__*/
function createFilenameRegex(value, ignoreCase, fullMatch) {
    return _createRegExp(asString(value), /([-+|^$#\.{}()\\\/\[\]\"\'])/g, function (value) {
        return value.replace(/(\\\\|\\\/|\*|\?)/g, function (_all, g1) {
            if (g1 == "\\/" || g1 == "\\\\") {
                return "[\\\\\\/]{1}";
            }
            return g1 == "*" ? MATCH_ANY : MATCH_SINGLE;
        });
    }, !!ignoreCase, fullMatch);
}
/*#__NO_SIDE_EFFECTS__*/
function makeGlobRegex(value, ignoreCase, fullMatch) {
    return _createRegExp(asString(value), /([-+|^$#\.{}()\\\/\[\]\"\'])/g, function (value) {
        return value.replace(/(\*\*\\[\\\/]|\\\\|\\\/|\*\*|\*|\?)/g, function (_all, g1) {
            if (g1 == "**\\/" || g1 == "**\\\\") {
                return "(.*[\\\\\\/])*";
            }
            if (g1 === "\\/" || g1 == "\\\\") {
                return "[\\\\\\/]{1}";
            }
            if (g1 === "**") {
                return MATCH_ANY;
            }
            return g1 === "*" ? "([^\\\\\\/]*)" : "([^\\\\\\/]{1})";
        });
    }, !!ignoreCase, fullMatch);
}

/*#__NO_SIDE_EFFECTS__*/
function safeGetLazy(cb, defValue, argArray) {
    return getLazy(function () {
        var result = safe(cb, argArray);
        return result.e ? defValue : result.v;
    });
}
/*#__NO_SIDE_EFFECTS__*/
function safeGetWritableLazy(cb, defValue, argArray) {
    return getWritableLazy(function () {
        var result = safe(cb, argArray);
        return result.e ? defValue : result.v;
    });
}
/*#__NO_SIDE_EFFECTS__*/
function safeGetDeferred(cb, defValue, argArray) {
    return getDeferred(function () {
        var result = safe(cb, argArray);
        return result.e ? defValue : result.v;
    });
}
/*#__NO_SIDE_EFFECTS__*/
function safeGetWritableDeferred(cb, defValue, argArray) {
    return getWritableDeferred(function () {
        var result = safe(cb, argArray);
        return result.e ? defValue : result.v;
    });
}

/*#__NO_SIDE_EFFECTS__*/
function _checkLength(value, props) {
    var result;
    arrForEach(props, function (prop) {
        if (prop in value) {
            var propValue = value[prop];
            result = (isFunction(propValue) ? propValue() : propValue) > 0;
            return -1;
        }
    });
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function _hasValue(value, depth) {
    var result = value === false || value === 0;
    if (!result && !isNullOrUndefined(value)) {
        if (isArray(value)) {
            result = value[LENGTH] > 0;
        }
        else if (isDate(value)) {
            result = !isNaN(value.getTime());
        }
        else if (isBoolean(value)) {
            return true;
        }
        else if (isObject(value)) {
            try {
                var chkValue = _checkLength(value, [LENGTH, "byteLength", "size", "count"]);
                if (isBoolean(chkValue)) {
                    return chkValue;
                }
                if (isFunction(value.valueOf) && depth < 5) {
                    return _hasValue(value.valueOf(), ++depth);
                }
            }
            catch (e) {
            }
            return !!objKeys(value)[LENGTH];
        }
        else {
            result = isTruthy(value);
        }
    }
    return result;
}
/*#__NO_SIDE_EFFECTS__*/
function hasValue(value) {
    return _hasValue(value, 0);
}

/*#__NO_SIDE_EFFECTS__*/
function createIterable(ctx) {
    return makeIterable({}, ctx);
}
function makeIterable(target, ctx) {
    var itSymbol = getKnownSymbol(3 );
    function _createIterator() {
        return createIterator(ctx);
    }
    target[itSymbol] = _createIterator;
    return target;
}
/*#__NO_SIDE_EFFECTS__*/
function createIterator(ctx) {
    var isDone = false;
    function _value() {
        return ctx.v;
    }
    function _next() {
        if (!isDone) {
            isDone = (ctx.n ? ctx.n(arguments) : true);
        }
        var result = {
            done: isDone
        };
        if (!isDone) {
            objDefine(result, "value", { g: _value });
        }
        return result;
    }
    function _return(value) {
        isDone = true;
        return {
            done: true,
            value: ctx.r && ctx.r(value)
        };
    }
    function _throw(e) {
        isDone = true;
        return {
            done: true,
            value: ctx.t && ctx.t(e)
        };
    }
    var theIterator = {
        next: _next
    };
    if (ctx.r) {
        theIterator.return = _return;
    }
    if (ctx.t) {
        theIterator.throw = _throw;
    }
    return theIterator;
}

/*#__NO_SIDE_EFFECTS__*/
function createArrayIterator(values) {
    var idx = -1;
    var theValues = values ? values.slice() : [];
    var len = theValues[LENGTH];
    function _value() {
        if (idx >= 0 && idx < len) {
            return theValues[idx];
        }
    }
    function _getNext() {
        idx++;
        return idx >= len;
    }
    var ctx = {
        n: _getNext
    };
    objDefine(ctx, "v", { g: _value });
    return createIterator(ctx);
}

/*#__NO_SIDE_EFFECTS__*/
function createRangeIterator(start, end, step) {
    var nextValue = start;
    var theValue = UNDEF_VALUE;
    if (isNullOrUndefined(end)) {
        end = start;
    }
    var theStep = step;
    if (!theStep) {
        theStep = (start <= end) ? 1 : -1;
    }
    function _value() {
        return theValue;
    }
    function _getNext() {
        var isDone = (theStep > 0) ? (nextValue > end) : (nextValue < end);
        if (!isDone) {
            theValue = nextValue;
            nextValue += theStep;
        }
        return isDone;
    }
    return createIterator(objDefine({
        n: _getNext
    }, "v", { g: _value }));
}

var mathAbs = ( /*#__PURE__*/_pureRef(MathCls, "abs"));

var mathExp = ( /*#__PURE__*/_pureRef(MathCls, "exp"));
var mathLog = ( /*#__PURE__*/_pureRef(MathCls, "log"));

var mathAsin = ( /*#__PURE__*/_pureRef(MathCls, "asin"));
var mathAcos = ( /*#__PURE__*/_pureRef(MathCls, "acos"));
var mathAtan = ( /*#__PURE__*/_pureRef(MathCls, "atan"));
var mathAtan2 = ( /*#__PURE__*/_pureRef(MathCls, "atan2"));

var mathPow = ( /*#__PURE__*/_pureRef(MathCls, "pow"));
var mathSqrt = ( /*#__PURE__*/_pureRef(MathCls, "sqrt"));

var mathRound = ( /*#__PURE__*/_pureRef(MathCls, "round"));

var mathSin = ( /*#__PURE__*/_pureRef(MathCls, "sin"));
var mathCos = ( /*#__PURE__*/_pureRef(MathCls, "cos"));
var mathTan = ( /*#__PURE__*/_pureRef(MathCls, "tan"));

var _recursionCheckOwnDescriptors;
var _recursionCheckOwnSymbols;
var _objGetOwnPropertyNames = ( /* #__PURE__ */_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, GET_OWN_PROPERTY_NAMES)), _returnEmptyArray));
var _objGetOwnPropertyDescriptor = ( /* #__PURE__ */_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR)), _returnNothing));
function polyObjGetOwnPropertyDescriptors(obj) {
    var result = {};
    _throwIfNullOrUndefined(obj);
    if (!_recursionCheckOwnDescriptors) {
        try {
            _recursionCheckOwnDescriptors = true;
            arrForEach(_objGetOwnPropertyNames(obj), function (propName) {
                var descriptor = _objGetOwnPropertyDescriptor(obj, propName);
                if (descriptor !== undefined) {
                    result[propName] = descriptor;
                }
            });
            arrForEach(_polyObjGetOwnPropertySymbols(obj), function (sym) {
                var descriptor = _objGetOwnPropertyDescriptor(obj, sym);
                if (descriptor !== undefined) {
                    result[sym] = descriptor;
                }
            });
        }
        finally {
            _recursionCheckOwnDescriptors = false;
        }
    }
    return result;
}
function _polyObjGetOwnPropertySymbols(obj) {
    var result = [];
    var objHasOwn = ObjClass.hasOwn || polyObjHasOwn;
    if (!_recursionCheckOwnSymbols) {
        try {
            _recursionCheckOwnSymbols = true;
            var symEnum = 0 ;
            while (symEnum <= 12 ) {
                var sym = getKnownSymbol(symEnum);
                if (sym && objHasOwn(obj, sym)) {
                    result.push(sym);
                }
                symEnum++;
            }
        }
        finally {
            _recursionCheckOwnSymbols = false;
        }
    }
    return result;
}

var objGetOwnPropertyDescriptor = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_DESCRIPTOR)), _returnNothing));
var objGetOwnPropertyDescriptors = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "getOwnPropertyDescriptors")), polyObjGetOwnPropertyDescriptors));
var objGetOwnPropertyNames = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, GET_OWN_PROPERTY_NAMES)), _returnEmptyArray));
var objGetOwnPropertySymbols = ( /* #__PURE__*/_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, GET_OWN_PROPERTY_SYMBOLS)), _returnEmptyArray));

function polyObjFromEntries(entries) {
    var result = {};
    function addEntry(entry) {
        if (isArray(entry) && entry.length >= 2) {
            result[entry[0]] = entry[1];
        }
    }
    if (isArray(entries)) {
        arrForEach(entries, addEntry);
    }
    else if (isIterable(entries)) {
        iterForOf(entries, addEntry);
    }
    return result;
}

var objFromEntries = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "fromEntries")), polyObjFromEntries));

var objPreventExtensions = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "preventExtensions")), _doNothing));
var objIsExtensible = ( /*#__PURE__*/_pureAssign(( /*#__PURE__*/_pureRef(ObjClass, "isExtensible")), _returnFalse));

var strEndsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith));
/*#__NO_SIDE_EFFECTS__*/
function polyStrEndsWith(value, searchString, length) {
    _throwIfNotString(value);
    var searchValue = isString(searchString) ? searchString : asString(searchString);
    var end = (!isUndefined(length) && length < value[LENGTH]) ? length : value[LENGTH];
    return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
}

var strIndexOf = ( /*#__PURE__*/_unwrapFunction("indexOf", StrProto));
var strLastIndexOf = ( /*#__PURE__*/_unwrapFunction("lastIndexOf", StrProto));

var strIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly("includes", StrProto, polyStrIncludes));
var strContains = ( /*#__PURE__*/_pureAssign(strIncludes));
/*#__NO_SIDE_EFFECTS__*/
function polyStrIncludes(value, searchString, position) {
    if (isRegExp(searchString)) {
        throwTypeError("'searchString' must not be a regular expression" + dumpObj(searchString));
    }
    return strIndexOf(value, asString(searchString), position) !== -1;
}

/*#__NO_SIDE_EFFECTS__*/
function strIsNullOrWhiteSpace(value) {
    if (isString(value)) {
        return value.replace(/[\s\t\r\n\f]+/g, EMPTY) === EMPTY;
    }
    return isNullOrUndefined(value);
}
/*#__NO_SIDE_EFFECTS__*/
function strIsNullOrEmpty(value) {
    if (isString(value)) {
        return value === EMPTY;
    }
    return isNullOrUndefined(value);
}

var strStartsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith));
/*#__NO_SIDE_EFFECTS__*/
function polyStrStartsWith(value, searchString, position) {
    _throwIfNotString(value);
    var searchValue = isString(searchString) ? searchString : asString(searchString);
    var pos = position > 0 ? position : 0;
    return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;
}

var REF = "ref";
var UNREF = "unref";
var HAS_REF = "hasRef";
var ENABLED = "enabled";
/*#__NO_SIDE_EFFECTS__*/
function _createTimerHandler(startTimer, refreshFn, cancelFn) {
    var ref = true;
    var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
    var theTimerHandler;
    function _unref() {
        ref = false;
        timerId && timerId[UNREF] && timerId[UNREF]();
        return theTimerHandler;
    }
    function _cancel() {
        timerId && cancelFn(timerId);
        timerId = NULL_VALUE;
    }
    function _refresh() {
        timerId = refreshFn(timerId);
        if (!ref) {
            _unref();
        }
        return theTimerHandler;
    }
    function _setEnabled(value) {
        !value && timerId && _cancel();
        value && !timerId && _refresh();
    }
    theTimerHandler = {
        cancel: _cancel,
        refresh: _refresh
    };
    theTimerHandler[HAS_REF] = function () {
        if (timerId && timerId[HAS_REF]) {
            return timerId[HAS_REF]();
        }
        return ref;
    };
    theTimerHandler[REF] = function () {
        ref = true;
        timerId && timerId[REF] && timerId[REF]();
        return theTimerHandler;
    };
    theTimerHandler[UNREF] = _unref;
    theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {
        get: function () { return !!timerId; },
        set: _setEnabled
    });
    return {
        h: theTimerHandler,
        dn: function () {
            timerId = NULL_VALUE;
        }
    };
}

var _setTimeoutFn;
var _clearTimeoutFn;
function _resolveTimeoutFn(timeoutFn) {
    var result = isFunction(timeoutFn) ? timeoutFn : _setTimeoutFn;
    if (!result) {
        var globalOverrides = _getGlobalConfig().tmOut || [];
        if (isArray(globalOverrides) && globalOverrides.length > 0 && isFunction(globalOverrides[0])) {
            result = globalOverrides[0];
        }
    }
    return result || setTimeout;
}
function _resolveClearTimeoutFn(timeoutFn) {
    var result = isFunction(timeoutFn) ? timeoutFn : _clearTimeoutFn;
    if (!result) {
        var globalOverrides = _getGlobalConfig().tmOut || [];
        if (isArray(globalOverrides) && globalOverrides.length > 1 && isFunction(globalOverrides[1])) {
            result = globalOverrides[1];
        }
    }
    return result || clearTimeout;
}
function _createTimeoutWith(startTimer, overrideFn, theArgs) {
    var isArr = isArray(overrideFn);
    var len = isArr ? overrideFn.length : 0;
    var setFn = _resolveTimeoutFn(len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE));
    var clearFn = _resolveClearTimeoutFn(len > 1 ? overrideFn[1] : UNDEF_VALUE);
    var timerFn = theArgs[0];
    theArgs[0] = function () {
        handler.dn();
        fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));
    };
    var handler = _createTimerHandler(startTimer, function (timerId) {
        if (timerId) {
            if (timerId.refresh) {
                timerId.refresh();
                return timerId;
            }
            fnApply(clearFn, UNDEF_VALUE, [timerId]);
        }
        return fnApply(setFn, UNDEF_VALUE, theArgs);
    }, function (timerId) {
        fnApply(clearFn, UNDEF_VALUE, [timerId]);
    });
    return handler.h;
}
function setTimeoutOverrides(overrideFn) {
    var isArr = isArray(overrideFn);
    var len = isArr ? overrideFn.length : 0;
    _setTimeoutFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE));
    _clearTimeoutFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE);
}
function setGlobalTimeoutOverrides(overrideFn) {
    var isArr = isArray(overrideFn);
    var len = isArr ? overrideFn.length : 0;
    var globalCfg = _getGlobalConfig();
    if (!overrideFn) {
        globalCfg.tmOut = undefined;
    }
    else {
        globalCfg.tmOut = [
            (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : null)),
            (len > 1 ? overrideFn[1] : null)
        ];
    }
}
function scheduleTimeout(callback, timeout) {
    return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));
}
function scheduleTimeoutWith(overrideFn, callback, timeout) {
    return _createTimeoutWith(true, overrideFn, ArrSlice[CALL](arguments, 1));
}
function createTimeout(callback, timeout) {
    return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));
}
function createTimeoutWith(overrideFn, callback, timeout) {
    return _createTimeoutWith(false, overrideFn, ArrSlice[CALL](arguments, 1));
}

var _defaultIdleTimeout = 100;
var _maxExecutionTime = 50;
/*#__NO_SIDE_EFFECTS__*/
function hasIdleCallback() {
    return !!( /*#__PURE__*/getIdleCallback());
}
var getIdleCallback = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["requestIdleCallback"]));
var getCancelIdleCallback = ( /*#__PURE__*/_getGlobalInstFn(getInst, ["cancelIdleCallback"]));
function setDefaultIdleTimeout(timeout) {
    _defaultIdleTimeout = timeout;
}
function setDefaultMaxExecutionTime(maxTime) {
    _maxExecutionTime = maxTime;
}
function scheduleIdleCallback(callback, options) {
    function _createDeadline(timedOut) {
        var startTime = perfNow();
        return {
            didTimeout: timedOut,
            timeRemaining: function () {
                return _maxExecutionTime - elapsedTime(startTime);
            }
        };
    }
    if (hasIdleCallback()) {
        var handler_1 = _createTimerHandler(true, function (idleId) {
            idleId && getCancelIdleCallback()(idleId);
            return getIdleCallback()(function (deadline) {
                handler_1.dn();
                callback(deadline || _createDeadline(false));
            }, options);
        }, function (idleId) {
            getCancelIdleCallback()(idleId);
        });
        return handler_1.h;
    }
    var timeout = (options || {}).timeout;
    if (isUndefined(timeout)) {
        timeout = _defaultIdleTimeout;
    }
    return scheduleTimeout(function () {
        callback(_createDeadline(true));
    }, timeout);
}

function scheduleInterval(callback, timeout) {
    var theArguments = ArrSlice[CALL](arguments);
    var handler = _createTimerHandler(true, function (intervalId) {
        intervalId && clearInterval(intervalId);
        return fnApply(setInterval, UNDEF_VALUE, theArguments);
    }, function (intervalId) {
        fnApply(clearInterval, UNDEF_VALUE, [intervalId]);
    });
    return handler.h;
}


//# sourceMappingURL=ts-utils.js.map


/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjClass: () => (/* binding */ ObjClass),
/* harmony export */   ObjProto: () => (/* binding */ ObjProto),
/* harmony export */   strDefault: () => (/* binding */ strDefault),
/* harmony export */   strShimFunction: () => (/* binding */ strShimFunction),
/* harmony export */   strShimObject: () => (/* binding */ strShimObject),
/* harmony export */   strShimPrototype: () => (/* binding */ strShimPrototype),
/* harmony export */   strShimUndefined: () => (/* binding */ strShimUndefined)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var strShimFunction = "function";
var strShimObject = "object";
var strShimUndefined = "undefined";
var strShimPrototype = "prototype";
var strDefault = "default";
var ObjClass = Object;
var ObjProto = ObjClass[strShimPrototype];
//# sourceMappingURL=Constants.js.map

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dynamicProto)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var _a;

;
var UNDEFINED = "undefined";
/**
 * Constant string defined to support minimization
 * @ignore
 */
var Constructor = 'constructor';
/**
 * Constant string defined to support minimization
 * @ignore
 */
var Prototype = 'prototype';
/**
 * Constant string defined to support minimization
 * @ignore
 */
var strFunction = 'function';
/**
 * Used to define the name of the instance function lookup table
 * @ignore
 */
var DynInstFuncTable = '_dynInstFuncs';
/**
 * Name used to tag the dynamic prototype function
 * @ignore
 */
var DynProxyTag = '_isDynProxy';
/**
 * Name added to a prototype to define the dynamic prototype "class" name used to lookup the function table
 * @ignore
 */
var DynClassName = '_dynClass';
/**
 * Prefix added to the classname to avoid any name clashes with other instance level properties
 * @ignore
 */
var DynClassNamePrefix = '_dynCls$';
/**
 * A tag which is used to check if we have already to attempted to set the instance function if one is not present
 * @ignore
 */
var DynInstChkTag = '_dynInstChk';
/**
 * A tag which is used to check if we are allows to try and set an instance function is one is not present. Using the same
 * tag name as the function level but a different const name for readability only.
 */
var DynAllowInstChkTag = DynInstChkTag;
/**
 * The global (imported) instances where the global performance options are stored
 */
var DynProtoDefaultOptions = '_dfOpts';
/**
 * Value used as the name of a class when it cannot be determined
 * @ignore
 */
var UnknownValue = '_unknown_';
/**
 * Constant string defined to support minimization
 * @ignore
 */
var str__Proto = "__proto__";
/**
 * The polyfill version of __proto__ so that it doesn't cause issues for anyone not expecting it to exist
 */
var DynProtoBaseProto = "_dyn" + str__Proto;
/**
 * Runtime Global holder for dynamicProto settings
 */
var DynProtoGlobalSettings = "__dynProto$Gbl";
/**
 * Track the current prototype for IE8 as you can't look back to get the prototype
 */
var DynProtoCurrent = "_dynInstProto";
/**
 * Constant string defined to support minimization
 * @ignore
 */
var strUseBaseInst = 'useBaseInst';
/**
 * Constant string defined to support minimization
 * @ignore
 */
var strSetInstFuncs = 'setInstFuncs';
var Obj = Object;
/**
 * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)
 * @ignore
 */
var _objGetPrototypeOf = Obj["getPrototypeOf"];
/**
 * Pre-lookup to check for the existence of this function
 */
var _objGetOwnProps = Obj["getOwnPropertyNames"];
// Since 1.1.7 moving these to the runtime global to work around mixed version and module issues
// See Issue https://github.com/microsoft/DynamicProto-JS/issues/57 for details
var _gbl = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
    o: (_a = {},
        _a[strSetInstFuncs] = true,
        _a[strUseBaseInst] = true,
        _a),
    n: 1000 // Start new global index @ 1000 so we "fix" some cases when mixed with 1.1.6 or earlier
});
/**
 * Helper used to check whether the target is an Object prototype or Array prototype
 * @ignore
 */
function _isObjectOrArrayPrototype(target) {
    return target && (target === Obj[Prototype] || target === Array[Prototype]);
}
/**
 * Helper used to check whether the target is an Object prototype, Array prototype or Function prototype
 * @ignore
 */
function _isObjectArrayOrFunctionPrototype(target) {
    return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
}
/**
 * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.
 * @ignore
 */
function _getObjProto(target) {
    var newProto;
    if (target) {
        // This method doesn't exist in older browsers (e.g. IE8)
        if (_objGetPrototypeOf) {
            return _objGetPrototypeOf(target);
        }
        var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
        // Using the pre-calculated value as IE8 doesn't support looking up the prototype of a prototype and thus fails for more than 1 base class
        newProto = target[DynProtoBaseProto] || curProto;
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, DynProtoBaseProto)) {
            // As this prototype doesn't have this property then this is from an inherited class so newProto is the base to return so save it
            // so we can look it up value (which for a multiple hierarchy dynamicProto will be the base class)
            delete target[DynProtoCurrent]; // Delete any current value allocated to this instance so we pick up the value from prototype hierarchy
            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
            target[DynProtoCurrent] = curProto;
        }
    }
    return newProto;
}
/**
 * Helper to get the properties of an object, including none enumerable ones as functions on a prototype in ES6
 * are not enumerable.
 * @param target
 */
function _forEachProp(target, func) {
    var props = [];
    if (_objGetOwnProps) {
        props = _objGetOwnProps(target);
    }
    else {
        for (var name_1 in target) {
            if (typeof name_1 === "string" && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, name_1)) {
                props.push(name_1);
            }
        }
    }
    if (props && props.length > 0) {
        for (var lp = 0; lp < props.length; lp++) {
            func(props[lp]);
        }
    }
}
/**
 * Helper function to check whether the provided function name is a potential candidate for dynamic
 * callback and prototype generation.
 * @param target The target object, may be a prototype or class object
 * @param funcName The function name
 * @param skipOwn Skips the check for own property
 * @ignore
 */
function _isDynamicCandidate(target, funcName, skipOwn) {
    return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, funcName)) && funcName !== str__Proto && funcName !== Prototype);
}
/**
 * Helper to throw a TypeError exception
 * @param message the message
 * @ignore
 */
function _throwTypeError(message) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("DynamicProto: " + message);
}
/**
 * Returns a collection of the instance functions that are defined directly on the thisTarget object, it does
 * not return any inherited functions
 * @param thisTarget The object to get the instance functions from
 * @ignore
 */
function _getInstanceFuncs(thisTarget) {
    // Get the base proto
    var instFuncs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null);
    // Save any existing instance functions
    _forEachProp(thisTarget, function (name) {
        // Don't include any dynamic prototype instances - as we only want the real functions
        if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {
            // Create an instance callback for passing the base function to the caller
            instFuncs[name] = thisTarget[name];
        }
    });
    return instFuncs;
}
/**
 * Returns whether the value is included in the array
 * @param values The array of values
 * @param value  The value
 */
function _hasVisited(values, value) {
    for (var lp = values.length - 1; lp >= 0; lp--) {
        if (values[lp] === value) {
            return true;
        }
    }
    return false;
}
/**
 * Returns an object that contains callback functions for all "base/super" functions, this is used to "save"
 * enabling calling super.xxx() functions without requiring that the base "class" has defined a prototype references
 * @param target The current instance
 * @ignore
 */
function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
    function _instFuncProxy(target, funcHost, funcName) {
        var theFunc = funcHost[funcName];
        if (theFunc[DynProxyTag] && useBaseInst) {
            // grab and reuse the hosted looking function (if available) otherwise the original passed function
            var instFuncTable = target[DynInstFuncTable] || {};
            if (instFuncTable[DynAllowInstChkTag] !== false) {
                theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
            }
        }
        return function () {
            // eslint-disable-next-line prefer-rest-params
            return theFunc.apply(target, arguments);
        };
    }
    // Start creating a new baseFuncs by creating proxies for the instance functions (as they may get replaced)
    var baseFuncs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null);
    _forEachProp(instFuncs, function (name) {
        // Create an instance callback for passing the base function to the caller
        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
    });
    // Get the base prototype functions
    var baseProto = _getObjProto(classProto);
    var visited = [];
    // Don't include base object functions for Object, Array or Function
    while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
        // look for prototype functions
        _forEachProp(baseProto, function (name) {
            // Don't include any dynamic prototype instances - as we only want the real functions
            // For IE 7/8 the prototype lookup doesn't provide the full chain so we need to bypass the 
            // hasOwnProperty check we get all of the methods, main difference is that IE7/8 doesn't return
            // the Object prototype methods while bypassing the check
            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {
                // Create an instance callback for passing the base function to the caller
                baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);
            }
        });
        // We need to find all possible functions that might be overloaded by walking the entire prototype chain
        // This avoids the caller from needing to check whether it's direct base class implements the function or not
        // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.
        visited.push(baseProto);
        baseProto = _getObjProto(baseProto);
    }
    return baseFuncs;
}
function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
    var instFunc = null;
    // We need to check whether the class name is defined directly on this prototype otherwise
    // it will walk the proto chain and return any parent proto classname.
    if (target && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(proto, DynClassName)) {
        var instFuncTable = target[DynInstFuncTable] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null);
        instFunc = (instFuncTable[proto[DynClassName]] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null))[funcName];
        if (!instFunc) {
            // Avoid stack overflow from recursive calling the same function
            _throwTypeError("Missing [" + funcName + "] " + strFunction);
        }
        // We have the instance function, lets check it we can speed up further calls
        // by adding the instance function back directly on the instance (avoiding the dynamic func lookup)
        if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
            // If the instance already has an instance function we can't replace it
            var canAddInst = !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, funcName);
            // Get current prototype
            var objProto = _getObjProto(target);
            var visited = [];
            // Lookup the function starting at the top (instance level prototype) and traverse down, if the first matching function
            // if nothing is found or if the first hit is a dynamic proto instance then we can safely add an instance shortcut
            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
                var protoFunc = objProto[funcName];
                if (protoFunc) {
                    canAddInst = (protoFunc === currentDynProtoProxy);
                    break;
                }
                // We need to find all possible initial functions to ensure that we don't bypass a valid override function
                visited.push(objProto);
                objProto = _getObjProto(objProto);
            }
            try {
                if (canAddInst) {
                    // This instance doesn't have an instance func and the class hierarchy does have a higher level prototype version
                    // so it's safe to directly assign for any subsequent calls (for better performance)
                    target[funcName] = instFunc;
                }
                // Block further attempts to set the instance function for any
                instFunc[DynInstChkTag] = 1;
            }
            catch (e) {
                // Don't crash if the object is readonly or the runtime doesn't allow changing this
                // And set a flag so we don't try again for any function
                instFuncTable[DynAllowInstChkTag] = false;
            }
        }
    }
    return instFunc;
}
function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
    var protoFunc = proto[funcName];
    // Check that the prototype function is not a self reference -- try to avoid stack overflow!
    if (protoFunc === currentDynProtoProxy) {
        // It is so lookup the base prototype
        protoFunc = _getObjProto(proto)[funcName];
    }
    if (typeof protoFunc !== strFunction) {
        _throwTypeError("[" + funcName + "] is not a " + strFunction);
    }
    return protoFunc;
}
/**
 * Add the required dynamic prototype methods to the the class prototype
 * @param proto - The class prototype
 * @param className - The instance classname
 * @param target - The target instance
 * @param baseInstFuncs - The base instance functions
 * @param setInstanceFunc - Flag to allow prototype function to reset the instance function if one does not exist
 * @ignore
 */
function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
    function _createDynamicPrototype(proto, funcName) {
        var dynProtoProxy = function () {
            // Use the instance or prototype function
            var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
            // eslint-disable-next-line prefer-rest-params
            return instFunc.apply(this, arguments);
        };
        // Tag this function as a proxy to support replacing dynamic proxy elements (primary use case is for unit testing
        // via which can dynamically replace the prototype function reference)
        dynProtoProxy[DynProxyTag] = 1;
        return dynProtoProxy;
    }
    if (!_isObjectOrArrayPrototype(proto)) {
        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null);
        if (!_isObjectOrArrayPrototype(instFuncTable)) {
            var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objCreate)(null)); // fetch and assign if as it may not exist yet
            // Set whether we are allow to lookup instances, if someone has set to false then do not re-enable
            if (instFuncTable[DynAllowInstChkTag] !== false) {
                instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
            }
            if (!_isObjectOrArrayPrototype(instFuncs_1)) {
                _forEachProp(target, function (name) {
                    // Only add overridden functions
                    if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {
                        // Save the instance Function to the lookup table and remove it from the instance as it's not a dynamic proto function
                        instFuncs_1[name] = target[name];
                        delete target[name];
                        // Add a dynamic proto if one doesn't exist or if a prototype function exists and it's not a dynamic one
                        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {
                            proto[name] = _createDynamicPrototype(proto, name);
                        }
                    }
                });
            }
        }
    }
}
/**
 * Checks whether the passed prototype object appears to be correct by walking the prototype hierarchy of the instance
 * @param classProto The class prototype instance
 * @param thisTarget The current instance that will be checked whether the passed prototype instance is in the hierarchy
 * @ignore
 */
function _checkPrototype(classProto, thisTarget) {
    // This method doesn't existing in older browsers (e.g. IE8)
    if (_objGetPrototypeOf) {
        // As this is primarily a coding time check, don't bother checking if running in IE8 or lower
        var visited = [];
        var thisProto = _getObjProto(thisTarget);
        while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
            if (thisProto === classProto) {
                return true;
            }
            // This avoids the caller from needing to check whether it's direct base class implements the function or not
            // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.
            visited.push(thisProto);
            thisProto = _getObjProto(thisProto);
        }
        return false;
    }
    // If objGetPrototypeOf doesn't exist then just assume everything is ok.
    return true;
}
/**
 * Gets the current prototype name using the ES6 name if available otherwise falling back to a use unknown as the name.
 * It's not critical for this to return a name, it's used to decorate the generated unique name for easier debugging only.
 * @param target
 * @param unknownValue
 * @ignore
 */
function _getObjName(target, unknownValue) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(target, Prototype)) {
        // Look like a prototype
        return target.name || unknownValue || UnknownValue;
    }
    return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;
}
/**
 * Helper function when creating dynamic (inline) functions for classes, this helper performs the following tasks :-
 * - Saves references to all defined base class functions
 * - Calls the delegateFunc with the current target (this) and a base object reference that can be used to call all "super" functions.
 * - Will populate the class prototype for all overridden functions to support class extension that call the prototype instance.
 * Callers should use this helper when declaring all function within the constructor of a class, as mentioned above the delegateFunc is
 * passed both the target "this" and an object that can be used to call any base (super) functions, using this based object in place of
 * super.XXX() (which gets expanded to _super.prototype.XXX()) provides a better minification outcome and also ensures the correct "this"
 * context is maintained as TypeScript creates incorrect references using super.XXXX() for dynamically defined functions i.e. Functions
 * defined in the constructor or some other function (rather than declared as complete typescript functions).
 * ### Usage
 * ```typescript
 * import dynamicProto from "@microsoft/dynamicproto-js";
 * class ExampleClass extends BaseClass {
 *     constructor() {
 *         dynamicProto(ExampleClass, this, (_self, base) => {
 *             // This will define a function that will be converted to a prototype function
 *             _self.newFunc = () => {
 *                 // Access any "this" instance property
 *                 if (_self.someProperty) {
 *                     ...
 *                 }
 *             }
 *             // This will define a function that will be converted to a prototype function
 *             _self.myFunction = () => {
 *                 // Access any "this" instance property
 *                 if (_self.someProperty) {
 *                     // Call the base version of the function that we are overriding
 *                     base.myFunction();
 *                 }
 *                 ...
 *             }
 *             _self.initialize = () => {
 *                 ...
 *             }
 *             // Warnings: While the following will work as _self is simply a reference to
 *             // this, if anyone overrides myFunction() the overridden will be called first
 *             // as the normal JavaScript method resolution will occur and the defined
 *             // _self.initialize() function is actually gets removed from the instance and
 *             // a proxy prototype version is created to reference the created method.
 *             _self.initialize();
 *         });
 *     }
 * }
 * ```
 * @typeparam DPType This is the generic type of the class, used to keep intellisense valid
 * @typeparam DPCls The type that contains the prototype of the current class
 * @param theClass - This is the current class instance which contains the prototype for the current class
 * @param target - The current "this" (target) reference, when the class has been extended this.prototype will not be the 'theClass' value.
 * @param delegateFunc - The callback function (closure) that will create the dynamic function
 * @param options - Additional options to configure how the dynamic prototype operates
 */
function dynamicProto(theClass, target, delegateFunc, options) {
    // Make sure that the passed theClass argument looks correct
    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(theClass, Prototype)) {
        _throwTypeError("theClass is an invalid class definition.");
    }
    // Quick check to make sure that the passed theClass argument looks correct (this is a common copy/paste error)
    var classProto = theClass[Prototype];
    if (!_checkPrototype(classProto, target)) {
        _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
    }
    var className = null;
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwnProperty)(classProto, DynClassName)) {
        // Only grab the class name if it's defined on this prototype (i.e. don't walk the prototype chain)
        className = classProto[DynClassName];
    }
    else {
        // As not all browser support name on the prototype creating a unique dynamic one if we have not already
        // assigned one, so we can use a simple string as the lookup rather than an object for the dynamic instance
        // function table lookup.
        className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
        _gblInst.n++;
        classProto[DynClassName] = className;
    }
    var perfOptions = dynamicProto[DynProtoDefaultOptions];
    var useBaseInst = !!perfOptions[strUseBaseInst];
    if (useBaseInst && options && options[strUseBaseInst] !== undefined) {
        useBaseInst = !!options[strUseBaseInst];
    }
    // Get the current instance functions
    var instFuncs = _getInstanceFuncs(target);
    // Get all of the functions for any base instance (before they are potentially overridden)
    var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
    // Execute the delegate passing in both the current target "this" and "base" function references
    // Note casting the same type as we don't actually have the base class here and this will provide some intellisense support
    delegateFunc(target, baseFuncs);
    // Don't allow setting instance functions for older IE instances
    var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
    if (setInstanceFunc && options) {
        setInstanceFunc = !!options[strSetInstFuncs];
    }
    // Populate the Prototype for any overridden instance functions
    _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
}
/**
 * Exposes the default global options to allow global configuration, if the global values are disabled these will override
 * any passed values. This is primarily exposed to support unit-testing without the need for individual classes to expose
 * their internal usage of dynamic proto.
 */
dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
//# sourceMappingURL=DynamicProto.js.map

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AppInsightsCore: () => (/* binding */ AppInsightsCore)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22);
/* harmony import */ var _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(25);
/* harmony import */ var _AsyncUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(37);
/* harmony import */ var _CookieMgr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(38);
/* harmony import */ var _DataCacheHelper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(23);
/* harmony import */ var _DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(41);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(40);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(24);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(26);
/* harmony import */ var _NotificationManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(42);
/* harmony import */ var _PerfManager__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(43);
/* harmony import */ var _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(44);
/* harmony import */ var _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(45);
/* harmony import */ var _TelemetryInitializerPlugin__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(48);
/* harmony import */ var _UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(50);
/* harmony import */ var _UnloadHookContainer__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(51);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


var _a;






















// import { IStatsBeat, IStatsBeatConfig, IStatsBeatState } from "../JavaScriptSDK.Interfaces/IStatsBeat";
// import { IStatsMgr } from "../JavaScriptSDK.Interfaces/IStatsMgr";
var strValidationError = "Plugins must provide initialize method";
var strNotificationManager = "_notificationManager";
var strSdkUnloadingError = "SDK is still unloading...";
var strSdkNotInitialized = "SDK is not initialized";
var maxInitQueueSize = 100;
var maxInitTimeout = 50000;
// const strPluginUnloadFailed = "Failed to unload plugin";
// /**
//  * Default StatsBeatMgr configuration
//  * @internal
//  */
// const defaultStatsCfg: IConfigDefaults<IStatsBeatConfig> = objDeepFreeze({
//     shrtInt: UNDEFINED_VALUE,
//     endCfg: cfgDfMerge([])
// });
// /**
//  * Default SDK initialization configuration
//  * @internal
//  */
// const defaultSdkConfig: IConfigDefaults<IInternalSdkConfiguration> = objDeepFreeze({
//     stats: { rdOnly: true, mrg: true, v: defaultStatsCfg }
// });
/**
 * The default settings for the config.
 * WE MUST include all defaults here to ensure that the config is created with all of the properties
 * defined as dynamic.
 */
var defaultConfig = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objDeepFreeze)((_a = {
        cookieCfg: {}
    },
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EXTENSIONS] = { rdOnly: true, ref: true, v: [] },
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CHANNELS] = { rdOnly: true, ref: true, v: [] },
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EXTENSION_CONFIG] = { ref: true, v: {} },
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CREATE_PERF_MGR] = _InternalConstants__WEBPACK_IMPORTED_MODULE_14__.UNDEFINED_VALUE,
    _a.loggingLevelConsole = 0 /* eLoggingSeverity.DISABLED */,
    _a.diagnosticLogInterval = _InternalConstants__WEBPACK_IMPORTED_MODULE_14__.UNDEFINED_VALUE,
    _a));
/**
 * Helper to create the default performance manager
 * @param core - The AppInsightsCore instance
 * @param notificationMgr - The notification manager
 */
function _createPerfManager(core, notificationMgr) {
    return new _PerfManager__WEBPACK_IMPORTED_MODULE_16__.PerfManager(notificationMgr);
}
function _validateExtensions(logger, channelPriority, allExtensions) {
    // Concat all available extensions
    var coreExtensions = [];
    var channels = [];
    // Check if any two extensions have the same priority, then warn to console
    // And extract the local extensions from the
    var extPriorities = {};
    // Extension validation
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(allExtensions, function (ext) {
        // Check for ext.initialize
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(ext) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(ext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_INITIALIZE /* @min:%2einitialize */])) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)(strValidationError);
        }
        var extPriority = ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_PRIORITY /* @min:%2epriority */];
        var identifier = ext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IDENTIFIER /* @min:%2eidentifier */];
        if (ext && extPriority) {
            if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(extPriorities[extPriority])) {
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__._warnToConsole)(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
            }
            else {
                // set a value
                extPriorities[extPriority] = identifier;
            }
        }
        // Split extensions to core and channels
        if (!extPriority || extPriority < channelPriority) {
            // Add to core extension that will be managed by AppInsightsCore
            coreExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](ext);
        }
        else {
            channels[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](ext);
        }
    });
    return {
        core: coreExtensions,
        channels: channels
    };
}
function _isPluginPresent(thePlugin, plugins) {
    var exists = false;
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(plugins, function (plugin) {
        if (plugin === thePlugin) {
            exists = true;
            return -1;
        }
    });
    return exists;
}
function _deepMergeConfig(details, target, newValues, merge) {
    // Lets assign the new values to the existing config
    if (newValues) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objForEachKey)(newValues, function (key, value) {
            if (merge) {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(value) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(target[key])) {
                    // The target is an object and it has a value
                    _deepMergeConfig(details, target[key], value, merge);
                }
            }
            if (merge && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(value) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isPlainObject)(target[key])) {
                // The target is an object and it has a value
                _deepMergeConfig(details, target[key], value, merge);
            }
            else {
                // Just Assign (replace) and/or make the property dynamic
                details.set(target, key, value);
            }
        });
    }
}
function _findWatcher(listeners, newWatcher) {
    var theListener = null;
    var idx = -1;
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(listeners, function (listener, lp) {
        if (listener.w === newWatcher) {
            theListener = listener;
            idx = lp;
            return -1;
        }
    });
    return { i: idx, l: theListener };
}
function _addDelayedCfgListener(listeners, newWatcher) {
    var theListener = _findWatcher(listeners, newWatcher).l;
    if (!theListener) {
        theListener = {
            w: newWatcher,
            rm: function () {
                var fnd = _findWatcher(listeners, newWatcher);
                if (fnd.i !== -1) {
                    listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_SPLICE /* @min:%2esplice */](fnd.i, 1);
                }
            }
        };
        listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](theListener);
    }
    return theListener;
}
function _registerDelayedCfgListener(config, listeners, logger) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(listeners, function (listener) {
        var unloadHdl = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_4__.onConfigChange)(config, listener.w, logger);
        delete listener.w; // Clear the listener reference so it will get garbage collected.
        // replace the remove function
        listener.rm = function () {
            unloadHdl.rm();
        };
    });
}
// Moved this outside of the closure to reduce the retained memory footprint
function _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {
    // Will get recalled if any referenced config values are changed
    unloadContainer.add(configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_WATCH /* @min:%2ewatch */](function (details) {
        var disableDbgExt = details.cfg.disableDbgExt;
        if (disableDbgExt === true && debugListener) {
            // Remove any previously loaded debug listener
            notificationManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */](debugListener);
            debugListener = null;
        }
        if (notificationManager && !debugListener && disableDbgExt !== true) {
            debugListener = (0,_DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_11__.getDebugListener)(details.cfg);
            notificationManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](debugListener);
        }
    }));
    return debugListener;
}
// Moved this outside of the closure to reduce the retained memory footprint
function _createUnloadHook(unloadHook) {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objDefine)({
        rm: function () {
            unloadHook.rm();
        }
    }, "toJSON", { v: function () { return "aicore::onCfgChange<" + JSON.stringify(unloadHook) + ">"; } });
}
/**
 * @group Classes
 * @group Entrypoint
 */
var AppInsightsCore = /** @class */ (function () {
    function AppInsightsCore() {
        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()
        var _configHandler;
        var _isInitialized;
        var _logger;
        var _eventQueue;
        var _notificationManager;
        // let _statsBeat: IStatsBeat | null;
        // let _statsMgr: IStatsMgr | null;
        var _perfManager;
        var _cfgPerfManager;
        var _cookieManager;
        var _pluginChain;
        var _configExtensions;
        var _channelConfig;
        var _channels;
        var _isUnloading;
        var _telemetryInitializerPlugin;
        var _internalLogsEventName;
        var _evtNamespace;
        var _unloadHandlers;
        var _hookContainer;
        var _debugListener;
        var _traceCtx;
        var _instrumentationKey;
        var _cfgListeners;
        var _extensions;
        var _pluginVersionStringArr;
        var _pluginVersionString;
        var _activeStatus; // to indicate if ikey or endpoint url promised is resolved or not
        var _endpoint;
        var _initInMemoMaxSize; // max event count limit during wait for init promises to be resolved
        var _isStatusSet; // track if active status is set in case of init timeout and init promises setting the status twice
        var _initTimer;
        /**
         * Internal log poller
         */
        var _internalLogPoller;
        var _internalLogPollerListening;
        var _forceStopInternalLogPoller;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(AppInsightsCore, this, function (_self) {
            // Set the default values (also called during teardown)
            _initDefaults();
            // Special internal method to allow the unit tests and DebugPlugin to hook embedded objects
            _self["_getDbgPlgTargets"] = function () {
                return [_extensions, _eventQueue];
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () { return _isInitialized; };
            // since version 3.3.0
            _self.activeStatus = function () { return _activeStatus; };
            // since version 3.3.0
            // internal
            _self._setPendingStatus = function () {
                _activeStatus = 3 /* eActiveStatus.PENDING */;
            };
            // Creating the self.initialize = ()
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, extensions, logger, notificationManager) {
                if (_isUnloading) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)(strSdkUnloadingError);
                }
                // Make sure core is only initialized once
                if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)("Core cannot be initialized more than once");
                }
                _configHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_4__.createDynamicConfig)(config, defaultConfig, logger || _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */], false);
                // Re-assigning the local config property so we don't have any references to the passed value and it can be garbage collected
                config = _configHandler.cfg;
                // This will be "re-run" if the referenced config properties are changed
                _addUnloadHook(_configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_WATCH /* @min:%2ewatch */](function (details) {
                    var rootCfg = details.cfg;
                    _initInMemoMaxSize = rootCfg.initInMemoMaxSize || maxInitQueueSize;
                    _handleIKeyEndpointPromises(rootCfg);
                    // Mark the extensionConfig and all first level keys as referenced
                    // This is so that calls to getExtCfg() will always return the same object
                    // Even when a user may "re-assign" the plugin properties (or it's unloaded/reloaded)
                    var extCfg = details.ref(details.cfg, _InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EXTENSION_CONFIG);
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objForEachKey)(extCfg, function (key) {
                        details.ref(extCfg, key);
                    });
                }));
                _notificationManager = notificationManager;
                // Initialize the debug listener outside of the closure to reduce the retained memory footprint
                _debugListener = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */](), _debugListener);
                _initPerfManager();
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */] = logger;
                var cfgExtensions = config[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EXTENSIONS /* @min:%2eextensions */];
                // Extension validation
                _configExtensions = [];
                _configExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */].apply(_configExtensions, (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__spreadArrayFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__spreadArrayFn)([], extensions, false), cfgExtensions, false));
                _channelConfig = config[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CHANNELS /* @min:%2echannels */];
                _initPluginChain(null);
                if (!_channels || _channels[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] === 0) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)("No " + _InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CHANNELS + " available");
                }
                if (_channelConfig && _channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 1) {
                    var teeController = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_PLUGIN /* @min:%2egetPlugin */]("TeeChannelController");
                    if (!teeController || !teeController.plugin) {
                        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, "TeeChannel required");
                    }
                }
                _registerDelayedCfgListener(config, _cfgListeners, _logger);
                _cfgListeners = null;
                _isInitialized = true;
                if (_activeStatus === _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_5__.ActiveStatus.ACTIVE) {
                    _releaseQueues();
                }
            };
            _self.getChannels = function () {
                var controls = [];
                if (_channels) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(_channels, function (channel) {
                        controls[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](channel);
                    });
                }
                return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objFreeze)(controls);
            };
            _self.track = function (telemetryItem) {
                (0,_PerfManager__WEBPACK_IMPORTED_MODULE_16__.doPerf)(_self[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_GET_PERF_MGR /* @min:%2egetPerfMgr */](), function () { return "AppInsightsCore:track"; }, function () {
                    if (telemetryItem === null) {
                        _notifyInvalidEvent(telemetryItem);
                        // throw error
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)("Invalid telemetry item");
                    }
                    // do basic validation before sending it through the pipeline
                    if (!telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_NAME /* @min:%2ename */] && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_NAME /* @min:%2ename */])) {
                        _notifyInvalidEvent(telemetryItem);
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)("telemetry name required");
                    }
                    // setup default iKey if not passed in
                    telemetryItem.iKey = telemetryItem.iKey || _instrumentationKey;
                    // add default timestamp if not passed in
                    telemetryItem.time = telemetryItem.time || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_13__.toISOString)(new Date());
                    // Common Schema 4.0
                    telemetryItem.ver = telemetryItem.ver || "4.0";
                    if (!_isUnloading && _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]() && _activeStatus === _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_5__.ActiveStatus.ACTIVE) {
                        // Process the telemetry plugin chain
                        _createTelCtx()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](telemetryItem);
                    }
                    else if (_activeStatus !== _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_5__.ActiveStatus.INACTIVE) {
                        // Queue events until all extensions are initialized
                        if (_eventQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] <= _initInMemoMaxSize) {
                            // set limit, if full, stop adding new events
                            _eventQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](telemetryItem);
                        }
                    }
                }, function () { return ({ item: telemetryItem }); }, !(telemetryItem.sync));
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_PROCESS_TEL_CONT2 /* @min:%2egetProcessTelContext */] = _createTelCtx;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */] = function () {
                if (!_notificationManager) {
                    _notificationManager = new _NotificationManager__WEBPACK_IMPORTED_MODULE_15__.NotificationManager(_configHandler.cfg);
                    // For backward compatibility only
                    _self[strNotificationManager] = _notificationManager;
                }
                return _notificationManager;
            };
            /**
             * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.
             * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be
             * called.
             * @param listener - An INotificationListener object.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {
                _self.getNotifyMgr()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](listener);
            };
            /**
             * Removes all instances of the listener.
             * @param listener - INotificationListener to remove.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {
                if (_notificationManager) {
                    _notificationManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */](listener);
                }
            };
            _self.getCookieMgr = function () {
                if (!_cookieManager) {
                    _cookieManager = (0,_CookieMgr__WEBPACK_IMPORTED_MODULE_9__.createCookieMgr)(_configHandler.cfg, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */]);
                }
                return _cookieManager;
            };
            _self.setCookieMgr = function (cookieMgr) {
                if (_cookieManager !== cookieMgr) {
                    (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_7__.runTargetUnload)(_cookieManager, false);
                    _cookieManager = cookieMgr;
                }
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_GET_PERF_MGR /* @min:%2egetPerfMgr */] = function () {
                return _perfManager || _cfgPerfManager || (0,_PerfManager__WEBPACK_IMPORTED_MODULE_16__.getGblPerfMgr)();
            };
            _self.setPerfMgr = function (perfMgr) {
                _perfManager = perfMgr;
            };
            // _self.getStatsBeat = (statsBeatState: IStatsBeatState) => {
            //     // create a new statsbeat if not initialize yet or the endpoint is different
            //     // otherwise, return the existing one, or null
            //     if (statsBeatState) {
            //         if (_statsMgr && _statsMgr.enabled) {
            //             if (_statsBeat && _statsBeat.endpoint !== statsBeatState.endpoint) {
            //                 // Different endpoint, so unload the existing and create a new one
            //                 _statsBeat.enabled = false;
            //                 _statsBeat = null;
            //             }
            //             if (!_statsBeat) {
            //                 // Create a new statsbeat instance
            //                 _statsBeat = _statsMgr.newInst(statsBeatState);
            //             }
            //         } else if (_statsBeat) {
            //             // Disable and remove any previously created statsbeat instance
            //             _statsBeat.enabled = false;
            //             _statsBeat = null;
            //         }
            //         // Return the current statsbeat instance or null if not created
            //         return _statsBeat;
            //     }
            //     // Return null as no statsbeat state was provided
            //     return null;
            // };
            // _self.setStatsMgr = (statsMgr: IStatsMgr) => {
            //     if (_statsMgr && _statsMgr !== statsMgr) {
            //         // Disable any previously created statsbeat instance
            //         if (_statsBeat) {
            //             _statsBeat.enabled = false;
            //             _statsBeat = null;
            //         }
            //     }
            //     _statsMgr = statsMgr;
            // };
            _self.eventCnt = function () {
                return _eventQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */];
            };
            _self.releaseQueue = function () {
                if (_isInitialized && _eventQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var eventQueue = _eventQueue;
                    _eventQueue = [];
                    if (_activeStatus === 2 /* eActiveStatus.ACTIVE */) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(eventQueue, function (event) {
                            event.iKey = event.iKey || _instrumentationKey;
                            _createTelCtx()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](event);
                        });
                    }
                    else {
                        // new one for msg ikey
                        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__._throwInternal)(_logger, 2 /* eLoggingSeverity.WARNING */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, "core init status is not active");
                    }
                }
            };
            _self.pollInternalLogs = function (eventName) {
                _internalLogsEventName = eventName || null;
                _forceStopInternalLogPoller = false;
                _internalLogPoller && _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CANCEL /* @min:%2ecancel */]();
                return _startLogPoller(true);
            };
            function _handleIKeyEndpointPromises(theConfig) {
                // app Insights core only handle ikey and endpointurl, aisku will handle cs
                // But we want to reference these config values so that if any future changes are made
                // this will trigger the re-run of the watch function
                // and the ikey and endpointUrl will be set to the new values
                var ikey = theConfig.instrumentationKey;
                var endpointUrl = theConfig.endpointUrl; // do not need to validate endpoint url, if it is null, default one will be set by sender
                // Check if we are waiting for previous promises to be resolved, won't apply new changes
                if (_activeStatus !== 3 /* eActiveStatus.PENDING */) {
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(ikey)) {
                        _instrumentationKey = null;
                        // if new ikey is null, set status to be inactive, all new events will be saved in memory or dropped
                        _activeStatus = _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_5__.ActiveStatus.INACTIVE;
                        var msg = "Please provide instrumentation key";
                        if (!_isInitialized) {
                            // only throw error during initialization
                            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)(msg);
                        }
                        else {
                            (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, msg);
                            _releaseQueues();
                        }
                        return;
                    }
                    var promises = [];
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isPromiseLike)(ikey)) {
                        promises[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](ikey);
                        _instrumentationKey = null; // reset current local ikey variable (otherwise it will always be the previous ikeys if timeout is called before promise cb)
                    }
                    else {
                        // string
                        _instrumentationKey = ikey;
                    }
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isPromiseLike)(endpointUrl)) {
                        promises[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](endpointUrl);
                        _endpoint = null; // reset current local endpoint variable (otherwise it will always be the previous urls if timeout is called before promise cb)
                    }
                    else {
                        // string or null
                        _endpoint = endpointUrl;
                    }
                    // at least have one promise
                    if (promises[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */]) {
                        _waitForInitPromises(theConfig, promises);
                    }
                    else {
                        // means no promises
                        _setStatus();
                    }
                }
            }
            function _waitForInitPromises(theConfig, promises) {
                // reset to false for new dynamic changes
                _isStatusSet = false;
                _activeStatus = 3 /* eActiveStatus.PENDING */;
                var initTimeout = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_13__.isNotNullOrUndefined)(theConfig.initTimeOut) ? theConfig.initTimeOut : maxInitTimeout; // theConfig.initTimeOut could be 0
                var allPromises = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_2__.createSyncAllSettledPromise)(promises);
                if (_initTimer) {
                    // Stop any previous timer
                    _initTimer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CANCEL /* @min:%2ecancel */]();
                }
                _initTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.scheduleTimeout)(function () {
                    // set _isStatusSet to true
                    // set active status
                    // release queues
                    _initTimer = null;
                    if (!_isStatusSet) {
                        _setStatus();
                    }
                }, initTimeout);
                (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_2__.doAwaitResponse)(allPromises, function (response) {
                    try {
                        if (_isStatusSet) {
                            // promises take too long to resolve, ignore them
                            // active status should be set by timeout already
                            return;
                        }
                        if (!response.rejected) {
                            var values = response[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_VALUE /* @min:%2evalue */];
                            if (values && values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */]) {
                                // ikey
                                var ikeyRes = values[0];
                                _instrumentationKey = ikeyRes && ikeyRes[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_VALUE /* @min:%2evalue */];
                                // endpoint
                                if (values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 1) {
                                    var endpointRes = values[1];
                                    _endpoint = endpointRes && endpointRes[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_VALUE /* @min:%2evalue */];
                                }
                            }
                            if (_instrumentationKey) {
                                // if ikey is null, no need to trigger extra dynamic changes for extensions
                                theConfig.instrumentationKey = _instrumentationKey; // set config.instrumentationKey for extensions to consume
                                theConfig.endpointUrl = _endpoint; // set config.endpointUrl for extensions to consume
                            }
                        }
                        // set _isStatusSet to true
                        // set active status
                        // release queues
                        _setStatus();
                    }
                    catch (e) {
                        if (!_isStatusSet) {
                            _setStatus();
                        }
                    }
                });
            }
            function _setStatus() {
                _isStatusSet = true;
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isNullOrUndefined)(_instrumentationKey)) {
                    _activeStatus = _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_5__.ActiveStatus.INACTIVE;
                    (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 112 /* _eInternalMessageId.InitPromiseException */, "ikey can't be resolved from promises");
                }
                else {
                    _activeStatus = _JavaScriptSDK_Enums_InitActiveStatusEnum__WEBPACK_IMPORTED_MODULE_5__.ActiveStatus.ACTIVE;
                }
                _releaseQueues();
            }
            function _releaseQueues() {
                if (_isInitialized) {
                    _self.releaseQueue();
                    _self.pollInternalLogs();
                }
            }
            function _startLogPoller(alwaysStart) {
                if ((!_internalLogPoller || !_internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ENABLED /* @min:%2eenabled */]) && !_forceStopInternalLogPoller) {
                    var shouldStart = alwaysStart || (_logger && _logger.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0);
                    if (shouldStart) {
                        if (!_internalLogPollerListening) {
                            _internalLogPollerListening = true;
                            // listen for any configuration changes so that changes to the
                            // interval will cause the timer to be re-initialized
                            _addUnloadHook(_configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_WATCH /* @min:%2ewatch */](function (details) {
                                var interval = details.cfg.diagnosticLogInterval;
                                if (!interval || !(interval > 0)) {
                                    interval = 10000;
                                }
                                var isRunning = false;
                                if (_internalLogPoller) {
                                    // It was already created so remember it's running and cancel
                                    isRunning = _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ENABLED /* @min:%2eenabled */];
                                    _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CANCEL /* @min:%2ecancel */]();
                                }
                                // Create / reconfigure
                                _internalLogPoller = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.createTimeout)(_flushInternalLogs, interval);
                                _internalLogPoller.unref();
                                // Restart if previously running
                                _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ENABLED /* @min:%2eenabled */] = isRunning;
                            }));
                        }
                        _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ENABLED /* @min:%2eenabled */] = true;
                    }
                }
                return _internalLogPoller;
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */] = function () {
                _forceStopInternalLogPoller = true;
                _internalLogPoller && _internalLogPoller[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CANCEL /* @min:%2ecancel */]();
                _flushInternalLogs();
            };
            // Add addTelemetryInitializer
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_13__.proxyFunctions)(_self, function () { return _telemetryInitializerPlugin; }, ["addTelemetryInitializer"]);
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_UNLOAD /* @min:%2eunload */] = function (isAsync, unloadComplete, cbTimeout) {
                if (isAsync === void 0) { isAsync = true; }
                if (!_isInitialized) {
                    // The SDK is not initialized
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)(strSdkNotInitialized);
                }
                // Check if the SDK still unloading so throw
                if (_isUnloading) {
                    // The SDK is already unloading
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)(strSdkUnloadingError);
                }
                var unloadState = {
                    reason: 50 /* TelemetryUnloadReason.SdkUnload */,
                    isAsync: isAsync,
                    flushComplete: false
                };
                var result;
                if (isAsync && !unloadComplete) {
                    result = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_2__.createPromise)(function (resolve) {
                        // Set the callback to the promise resolve callback
                        unloadComplete = resolve;
                    });
                }
                var processUnloadCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_17__.createProcessTelemetryUnloadContext)(_getPluginChain(), _self);
                processUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {
                    // if (_statsBeat) {
                    //     // Disable any statsbeat instance
                    //     _statsBeat.enabled = false;
                    //     _statsBeat = null;
                    // }
                    _hookContainer.run(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */]);
                    // Run any "unload" functions for the _cookieManager, _notificationManager and _logger
                    (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_7__.doUnloadAll)([_cookieManager, _notificationManager, _logger], isAsync, function () {
                        _initDefaults();
                        unloadComplete && unloadComplete(unloadState);
                    });
                }, _self);
                function _doUnload(flushComplete) {
                    unloadState.flushComplete = flushComplete;
                    _isUnloading = true;
                    // Run all of the unload handlers first (before unloading the plugins)
                    _unloadHandlers.run(processUnloadCtx, unloadState);
                    // Stop polling the internal logs
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */]();
                    // Start unloading the components, from this point onwards the SDK should be considered to be in an unstable state
                    processUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);
                }
                _flushInternalLogs();
                if (!_flushChannels(isAsync, _doUnload, 6 /* SendRequestReason.SdkUnload */, cbTimeout)) {
                    _doUnload(false);
                }
                return result;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_PLUGIN /* @min:%2egetPlugin */] = _getPlugin;
            _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {
                if (!plugin) {
                    addCb && addCb(false);
                    _logOrThrowError(strValidationError);
                    return;
                }
                var existingPlugin = _getPlugin(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IDENTIFIER /* @min:%2eidentifier */]);
                if (existingPlugin && !replaceExisting) {
                    addCb && addCb(false);
                    _logOrThrowError("Plugin [" + plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IDENTIFIER /* @min:%2eidentifier */] + "] is already loaded!");
                    return;
                }
                var updateState = {
                    reason: 16 /* TelemetryUpdateReason.PluginAdded */
                };
                function _addPlugin(removed) {
                    _configExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](plugin);
                    updateState.added = [plugin];
                    // Re-Initialize the plugin chain
                    _initPluginChain(updateState);
                    addCb && addCb(true);
                }
                if (existingPlugin) {
                    var removedPlugins_1 = [existingPlugin.plugin];
                    var unloadState = {
                        reason: 2 /* TelemetryUnloadReason.PluginReplace */,
                        isAsync: !!isAsync
                    };
                    _removePlugins(removedPlugins_1, unloadState, function (removed) {
                        if (!removed) {
                            // Previous plugin was successfully removed or was not installed
                            addCb && addCb(false);
                        }
                        else {
                            updateState.removed = removedPlugins_1;
                            updateState.reason |= 32 /* TelemetryUpdateReason.PluginRemoved */;
                            _addPlugin(true);
                        }
                    });
                }
                else {
                    _addPlugin(false);
                }
            };
            _self.updateCfg = function (newConfig, mergeExisting) {
                if (mergeExisting === void 0) { mergeExisting = true; }
                var updateState;
                if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {
                    updateState = {
                        reason: 1 /* TelemetryUpdateReason.ConfigurationChanged */,
                        cfg: _configHandler.cfg,
                        oldCfg: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.deepExtend)({}, _configHandler.cfg),
                        newConfig: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.deepExtend)({}, newConfig),
                        merge: mergeExisting
                    };
                    newConfig = updateState.newConfig;
                    var cfg = _configHandler.cfg;
                    // replace the immutable (if initialized) values
                    // We don't currently allow updating the extensions and channels via the update config
                    // So overwriting any user provided values to reuse the existing values
                    newConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EXTENSIONS /* @min:%2eextensions */] = cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EXTENSIONS /* @min:%2eextensions */];
                    newConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CHANNELS /* @min:%2echannels */] = cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CHANNELS /* @min:%2echannels */];
                }
                // Explicitly blocking any previous config watchers so that they don't get called because
                // of this bulk update (Probably not necessary)
                _configHandler._block(function (details) {
                    // Lets assign the new values to the existing config either overwriting or re-assigning
                    var theConfig = details.cfg;
                    _deepMergeConfig(details, theConfig, newConfig, mergeExisting);
                    if (!mergeExisting) {
                        // Remove (unassign) the values "missing" from the newConfig and also not in the default config
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objForEachKey)(theConfig, function (key) {
                            if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objHasOwn)(newConfig, key)) {
                                // Set the value to undefined
                                details.set(theConfig, key, _InternalConstants__WEBPACK_IMPORTED_MODULE_14__.UNDEFINED_VALUE);
                            }
                        });
                    }
                    // Apply defaults to the new config
                    details.setDf(theConfig, defaultConfig);
                }, true);
                // Now execute all of the listeners (synchronously) so they update their values immediately
                _configHandler.notify();
                if (updateState) {
                    _doUpdate(updateState);
                }
            };
            _self.evtNamespace = function () {
                return _evtNamespace;
            };
            _self.flush = _flushChannels;
            _self.getTraceCtx = function (createNew) {
                if (!_traceCtx) {
                    _traceCtx = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__.createDistributedTraceContext)();
                }
                return _traceCtx;
            };
            _self.setTraceCtx = function (traceCtx) {
                _traceCtx = traceCtx || null;
            };
            _self.addUnloadHook = _addUnloadHook;
            // Create the addUnloadCb
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_13__.proxyFunctionAs)(_self, "addUnloadCb", function () { return _unloadHandlers; }, "add");
            _self.onCfgChange = function (handler) {
                var unloadHook;
                if (!_isInitialized) {
                    unloadHook = _addDelayedCfgListener(_cfgListeners, handler);
                }
                else {
                    unloadHook = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_4__.onConfigChange)(_configHandler.cfg, handler, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */]);
                }
                return _createUnloadHook(unloadHook);
            };
            _self.getWParam = function () {
                return ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.hasDocument)() || !!_configHandler.cfg.enableWParam) ? 0 : -1;
            };
            function _setPluginVersions() {
                var thePlugins = {};
                _pluginVersionStringArr = [];
                var _addPluginVersions = function (plugins) {
                    if (plugins) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(plugins, function (plugin) {
                            if (plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IDENTIFIER /* @min:%2eidentifier */] && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_VERSION /* @min:%2eversion */] && !thePlugins[plugin.identifier]) {
                                var ver = plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IDENTIFIER /* @min:%2eidentifier */] + "=" + plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_VERSION /* @min:%2eversion */];
                                _pluginVersionStringArr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](ver);
                                thePlugins[plugin.identifier] = plugin;
                            }
                        });
                    }
                };
                _addPluginVersions(_channels);
                if (_channelConfig) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(_channelConfig, function (channels) {
                        _addPluginVersions(channels);
                    });
                }
                _addPluginVersions(_configExtensions);
            }
            function _initDefaults() {
                _isInitialized = false;
                // Use a default logger so initialization errors are not dropped on the floor with full logging
                _configHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_4__.createDynamicConfig)({}, defaultConfig, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */]);
                // Set the logging level to critical so that any critical initialization failures are displayed on the console
                _configHandler.cfg[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGING_LEVEL_CONSOL4 /* @min:%2eloggingLevelConsole */] = 1 /* eLoggingSeverity.CRITICAL */;
                // Define _self.config
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objDefine)(_self, "config", {
                    g: function () { return _configHandler.cfg; },
                    s: function (newValue) {
                        _self.updateCfg(newValue, false);
                    }
                });
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objDefine)(_self, "pluginVersionStringArr", {
                    g: function () {
                        if (!_pluginVersionStringArr) {
                            _setPluginVersions();
                        }
                        return _pluginVersionStringArr;
                    }
                });
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objDefine)(_self, "pluginVersionString", {
                    g: function () {
                        if (!_pluginVersionString) {
                            if (!_pluginVersionStringArr) {
                                _setPluginVersions();
                            }
                            _pluginVersionString = _pluginVersionStringArr.join(";");
                        }
                        return _pluginVersionString || _InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EMPTY;
                    }
                });
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objDefine)(_self, "logger", {
                    g: function () {
                        if (!_logger) {
                            _logger = new _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__.DiagnosticLogger(_configHandler.cfg);
                            _configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */] = _logger;
                        }
                        return _logger;
                    },
                    s: function (newLogger) {
                        _configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */] = newLogger;
                        if (_logger !== newLogger) {
                            (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_7__.runTargetUnload)(_logger, false);
                            _logger = newLogger;
                        }
                    }
                });
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */] = new _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__.DiagnosticLogger(_configHandler.cfg);
                _extensions = [];
                var cfgExtensions = _self.config[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EXTENSIONS /* @min:%2eextensions */] || [];
                cfgExtensions.splice(0, cfgExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */]);
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrAppend)(cfgExtensions, _extensions);
                _telemetryInitializerPlugin = new _TelemetryInitializerPlugin__WEBPACK_IMPORTED_MODULE_19__.TelemetryInitializerPlugin();
                _eventQueue = [];
                (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_7__.runTargetUnload)(_notificationManager, false);
                _notificationManager = null;
                _perfManager = null;
                // _statsBeat = null;
                _cfgPerfManager = null;
                (0,_AsyncUtils__WEBPACK_IMPORTED_MODULE_7__.runTargetUnload)(_cookieManager, false);
                _cookieManager = null;
                _pluginChain = null;
                _configExtensions = [];
                _channelConfig = null;
                _channels = null;
                _isUnloading = false;
                _internalLogsEventName = null;
                _evtNamespace = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_10__.createUniqueNamespace)("AIBaseCore", true);
                _unloadHandlers = (0,_UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_20__.createUnloadHandlerContainer)();
                _traceCtx = null;
                _instrumentationKey = null;
                _hookContainer = (0,_UnloadHookContainer__WEBPACK_IMPORTED_MODULE_21__.createUnloadHookContainer)();
                _cfgListeners = [];
                _pluginVersionString = null;
                _pluginVersionStringArr = null;
                _forceStopInternalLogPoller = false;
                _internalLogPoller = null;
                _internalLogPollerListening = false;
                _activeStatus = 0 /* eActiveStatus.NONE */; // default is None
                _endpoint = null;
                _initInMemoMaxSize = null;
                _isStatusSet = false;
                _initTimer = null;
                // if (_statsBeat) {
                //     // Unload and disable any statsbeat instance
                //     _statsBeat.enabled = false;
                // }
                // _statsBeat = null;
            }
            function _createTelCtx() {
                var theCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_17__.createProcessTelemetryContext)(_getPluginChain(), _configHandler.cfg, _self);
                theCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ON_COMPLETE /* @min:%2eonComplete */](_startLogPoller);
                return theCtx;
            }
            // Initialize or Re-initialize the plugins
            function _initPluginChain(updateState) {
                // Extension validation
                var theExtensions = _validateExtensions(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */], _Constants__WEBPACK_IMPORTED_MODULE_8__.ChannelControllerPriority, _configExtensions);
                _pluginChain = null;
                _pluginVersionString = null;
                _pluginVersionStringArr = null;
                // Get the primary channel queue and include as part of the normal extensions
                _channels = (_channelConfig || [])[0] || [];
                // Add any channels provided in the extensions and sort them
                _channels = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__.sortPlugins)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrAppend)(_channels, theExtensions[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CHANNELS /* @min:%2echannels */]));
                // Create an array of all extensions, including the _channels
                var allExtensions = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrAppend)((0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__.sortPlugins)(theExtensions[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CORE /* @min:%2ecore */]), _channels);
                // Required to allow plugins to call core.getPlugin() during their own initialization
                _extensions = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.objFreeze)(allExtensions);
                // This has a side effect of adding the extensions passed during initialization
                // into the config.extensions, so you can see all of the extensions loaded.
                // This will also get updated by the addPlugin() and remove plugin code.
                var cfgExtensions = _self.config[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EXTENSIONS /* @min:%2eextensions */] || [];
                cfgExtensions.splice(0, cfgExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */]);
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrAppend)(cfgExtensions, _extensions);
                var rootCtx = _createTelCtx();
                // Initializing the channels first
                if (_channels && _channels[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__.initializePlugins)(rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CREATE_NEW /* @min:%2ecreateNew */](_channels), allExtensions);
                }
                // Now initialize the normal extensions (explicitly not including the _channels as this can cause duplicate initialization)
                (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__.initializePlugins)(rootCtx, allExtensions);
                if (updateState) {
                    _doUpdate(updateState);
                }
            }
            function _getPlugin(pluginIdentifier) {
                var theExt = null;
                var thePlugin = null;
                var channelHosts = [];
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(_extensions, function (ext) {
                    if (ext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_IDENTIFIER /* @min:%2eidentifier */] === pluginIdentifier && ext !== _telemetryInitializerPlugin) {
                        thePlugin = ext;
                        return -1;
                    }
                    if (ext.getChannel) {
                        channelHosts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](ext);
                    }
                });
                if (!thePlugin && channelHosts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(channelHosts, function (host) {
                        thePlugin = host.getChannel(pluginIdentifier);
                        if (!thePlugin) {
                            return -1;
                        }
                    });
                }
                if (thePlugin) {
                    theExt = {
                        plugin: thePlugin,
                        setEnabled: function (enabled) {
                            (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__._getPluginState)(thePlugin)[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_DISABLED] = !enabled;
                        },
                        isEnabled: function () {
                            var pluginState = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__._getPluginState)(thePlugin);
                            return !pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_TEARDOWN /* @min:%2eteardown */] && !pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_DISABLED];
                        },
                        remove: function (isAsync, removeCb) {
                            if (isAsync === void 0) { isAsync = true; }
                            var pluginsToRemove = [thePlugin];
                            var unloadState = {
                                reason: 1 /* TelemetryUnloadReason.PluginUnload */,
                                isAsync: isAsync
                            };
                            _removePlugins(pluginsToRemove, unloadState, function (removed) {
                                if (removed) {
                                    // Re-Initialize the plugin chain
                                    _initPluginChain({
                                        reason: 32 /* TelemetryUpdateReason.PluginRemoved */,
                                        removed: pluginsToRemove
                                    });
                                }
                                removeCb && removeCb(removed);
                            });
                        }
                    };
                }
                return theExt;
            }
            function _getPluginChain() {
                if (!_pluginChain) {
                    // copy the collection of extensions
                    var extensions = (_extensions || []).slice();
                    // During add / remove this may get called again, so don't read if already present
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrIndexOf)(extensions, _telemetryInitializerPlugin) === -1) {
                        extensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](_telemetryInitializerPlugin);
                    }
                    _pluginChain = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_17__.createTelemetryProxyChain)((0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_18__.sortPlugins)(extensions), _configHandler.cfg, _self);
                }
                return _pluginChain;
            }
            function _removePlugins(thePlugins, unloadState, removeComplete) {
                if (thePlugins && thePlugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var unloadChain = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_17__.createTelemetryProxyChain)(thePlugins, _configHandler.cfg, _self);
                    var unloadCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_17__.createProcessTelemetryUnloadContext)(unloadChain, _self);
                    unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {
                        var removed = false;
                        // Remove the listed config extensions
                        var newConfigExtensions = [];
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(_configExtensions, function (plugin, idx) {
                            if (!_isPluginPresent(plugin, thePlugins)) {
                                newConfigExtensions[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](plugin);
                            }
                            else {
                                removed = true;
                            }
                        });
                        _configExtensions = newConfigExtensions;
                        _pluginVersionString = null;
                        _pluginVersionStringArr = null;
                        // Re-Create the channel config
                        var newChannelConfig = [];
                        if (_channelConfig) {
                            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(_channelConfig, function (queue, idx) {
                                var newQueue = [];
                                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(queue, function (channel) {
                                    if (!_isPluginPresent(channel, thePlugins)) {
                                        newQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](channel);
                                    }
                                    else {
                                        removed = true;
                                    }
                                });
                                newChannelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PUSH /* @min:%2epush */](newQueue);
                            });
                            _channelConfig = newChannelConfig;
                        }
                        removeComplete && removeComplete(removed);
                        _startLogPoller();
                    });
                    unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);
                }
                else {
                    removeComplete(false);
                }
            }
            function _flushInternalLogs() {
                if (_logger && _logger.queue) {
                    var queue = _logger.queue.slice(0);
                    _logger.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] = 0;
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.arrForEach)(queue, function (logMessage) {
                        var item = {
                            name: _internalLogsEventName ? _internalLogsEventName : "InternalMessageId: " + logMessage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_MESSAGE_ID /* @min:%2emessageId */],
                            iKey: _instrumentationKey,
                            time: (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_13__.toISOString)(new Date()),
                            baseType: _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__._InternalLogMessage.dataType,
                            baseData: { message: logMessage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_MESSAGE /* @min:%2emessage */] }
                        };
                        _self.track(item);
                    });
                }
            }
            function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
                // Setting waiting to one so that we don't call the callBack until we finish iterating
                var waiting = 1;
                var doneIterating = false;
                var cbTimer = null;
                cbTimeout = cbTimeout || 5000;
                function doCallback() {
                    waiting--;
                    if (doneIterating && waiting === 0) {
                        cbTimer && cbTimer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CANCEL /* @min:%2ecancel */]();
                        cbTimer = null;
                        callBack && callBack(doneIterating);
                        callBack = null;
                    }
                }
                if (_channels && _channels[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var flushCtx = _createTelCtx()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CREATE_NEW /* @min:%2ecreateNew */](_channels);
                    flushCtx.iterate(function (plugin) {
                        if (plugin.flush) {
                            waiting++;
                            var handled_1 = false;
                            // Not all channels will call this callback for every scenario
                            if (!plugin.flush(isAsync, function () {
                                handled_1 = true;
                                doCallback();
                            }, sendReason)) {
                                if (!handled_1) {
                                    // If any channel doesn't return true and it didn't call the callback, then we should assume that the callback
                                    // will never be called, so use a timeout to allow the channel(s) some time to "finish" before triggering any
                                    // followup function (such as unloading)
                                    if (isAsync && cbTimer == null) {
                                        cbTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.scheduleTimeout)(function () {
                                            cbTimer = null;
                                            doCallback();
                                        }, cbTimeout);
                                    }
                                    else {
                                        doCallback();
                                    }
                                }
                            }
                        }
                    });
                }
                doneIterating = true;
                doCallback();
                return true;
            }
            function _initPerfManager() {
                // Save the previous config based performance manager creator to avoid creating new perf manager instances if unchanged
                var prevCfgPerfMgr;
                // Will get recalled if any referenced config values are changed
                _addUnloadHook(_configHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_WATCH /* @min:%2ewatch */](function (details) {
                    var enablePerfMgr = details.cfg.enablePerfMgr;
                    if (enablePerfMgr) {
                        var createPerfMgr = details.cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CREATE_PERF_MGR /* @min:%2ecreatePerfMgr */];
                        // for preCfgPerfMgr = createPerfMgr = null
                        // initial createPerfMgr function should be _createPerfManager
                        if ((prevCfgPerfMgr !== createPerfMgr) || !prevCfgPerfMgr) {
                            if (!createPerfMgr) {
                                createPerfMgr = _createPerfManager;
                            }
                            // Set the performance manager creation function if not defined
                            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_13__.getSetValue)(details.cfg, _InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_CREATE_PERF_MGR, createPerfMgr);
                            prevCfgPerfMgr = createPerfMgr;
                            // Remove any existing config based performance manager
                            _cfgPerfManager = null;
                        }
                        // Only create the performance manager if it's not already created or manually set
                        if (!_perfManager && !_cfgPerfManager && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(createPerfMgr)) {
                            // Create a new config based performance manager
                            _cfgPerfManager = createPerfMgr(_self, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]());
                        }
                    }
                    else {
                        // Remove any existing config based performance manager
                        _cfgPerfManager = null;
                        // Clear the previous cached value so it can be GC'd
                        prevCfgPerfMgr = null;
                    }
                }));
            }
            function _doUpdate(updateState) {
                var updateCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_17__.createProcessTelemetryUpdateContext)(_getPluginChain(), _self);
                updateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_ON_COMPLETE /* @min:%2eonComplete */](_startLogPoller);
                if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {
                    updateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);
                }
            }
            function _logOrThrowError(message) {
                var logger = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LOGGER /* @min:%2elogger */];
                if (logger) {
                    // there should always be a logger
                    (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_12__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, message);
                    _startLogPoller();
                }
                else {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_3__.throwError)(message);
                }
            }
            function _notifyInvalidEvent(telemetryItem) {
                var manager = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]();
                if (manager) {
                    manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_14__.STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */]([telemetryItem], 2 /* eEventsDiscardedReason.InvalidEvent */);
                }
            }
            function _addUnloadHook(hooks) {
                _hookContainer.add(hooks);
            }
        });
    }
// Removed Stub for AppInsightsCore.prototype.initialize.
// Removed Stub for AppInsightsCore.prototype.getChannels.
// Removed Stub for AppInsightsCore.prototype.track.
// Removed Stub for AppInsightsCore.prototype.getProcessTelContext.
// Removed Stub for AppInsightsCore.prototype.getNotifyMgr.
// Removed Stub for AppInsightsCore.prototype.addNotificationListener.
// Removed Stub for AppInsightsCore.prototype.removeNotificationListener.
// Removed Stub for AppInsightsCore.prototype.getCookieMgr.
// Removed Stub for AppInsightsCore.prototype.setCookieMgr.
// Removed Stub for AppInsightsCore.prototype.getPerfMgr.
    // public getStatsBeat(statsBeatState: IStatsBeatState): IStatsBeat {
    //     // @ DynamicProtoStub -- DO NOT add any code as this will be removed during packaging
    //     return null;
    // }
    // public setStatsMgr(statsMgr?: IStatsMgr): void {
    //     // @ DynamicProtoStub -- DO NOT add any code as this will be removed during packaging
    // }
// Removed Stub for AppInsightsCore.prototype.setPerfMgr.
// Removed Stub for AppInsightsCore.prototype.eventCnt.
// Removed Stub for AppInsightsCore.prototype.pollInternalLogs.
// Removed Stub for AppInsightsCore.prototype.stopPollingInternalLogs.
// Removed Stub for AppInsightsCore.prototype.addTelemetryInitializer.
// Removed Stub for AppInsightsCore.prototype.unload.
// Removed Stub for AppInsightsCore.prototype.getPlugin.
// Removed Stub for AppInsightsCore.prototype.addPlugin.
// Removed Stub for AppInsightsCore.prototype.updateCfg.
// Removed Stub for AppInsightsCore.prototype.evtNamespace.
// Removed Stub for AppInsightsCore.prototype.addUnloadCb.
// Removed Stub for AppInsightsCore.prototype.flush.
// Removed Stub for AppInsightsCore.prototype.getTraceCtx.
// Removed Stub for AppInsightsCore.prototype.setTraceCtx.
// Removed Stub for AppInsightsCore.prototype.addUnloadHook.
// Removed Stub for AppInsightsCore.prototype.onCfgChange.
// Removed Stub for AppInsightsCore.prototype.activeStatus.
// Removed Stub for AppInsightsCore.prototype._setPendingStatus.
// Removed Stub for AppInsightsCore.prototype.releaseQueue.
// Removed Stub for AppInsightsCore.prototype._updateHook.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    AppInsightsCore.__ieDyn=1;

    return AppInsightsCore;
}());

//# sourceMappingURL=AppInsightsCore.js.map

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PolyPromise: () => (/* binding */ PolyPromise),
/* harmony export */   arrForEachAsync: () => (/* binding */ arrForEachAsync),
/* harmony export */   createAllPromise: () => (/* binding */ createAllPromise),
/* harmony export */   createAllSettledPromise: () => (/* binding */ createAllSettledPromise),
/* harmony export */   createAnyPromise: () => (/* binding */ createAnyPromise),
/* harmony export */   createAsyncAllPromise: () => (/* binding */ createAsyncAllPromise),
/* harmony export */   createAsyncAllSettledPromise: () => (/* binding */ createAsyncAllSettledPromise),
/* harmony export */   createAsyncAnyPromise: () => (/* binding */ createAsyncAnyPromise),
/* harmony export */   createAsyncPromise: () => (/* binding */ createAsyncPromise),
/* harmony export */   createAsyncRacePromise: () => (/* binding */ createAsyncRacePromise),
/* harmony export */   createAsyncRejectedPromise: () => (/* binding */ createAsyncRejectedPromise),
/* harmony export */   createAsyncResolvedPromise: () => (/* binding */ createAsyncResolvedPromise),
/* harmony export */   createIdleAllPromise: () => (/* binding */ createIdleAllPromise),
/* harmony export */   createIdleAllSettledPromise: () => (/* binding */ createIdleAllSettledPromise),
/* harmony export */   createIdleAnyPromise: () => (/* binding */ createIdleAnyPromise),
/* harmony export */   createIdlePromise: () => (/* binding */ createIdlePromise),
/* harmony export */   createIdleRacePromise: () => (/* binding */ createIdleRacePromise),
/* harmony export */   createIdleRejectedPromise: () => (/* binding */ createIdleRejectedPromise),
/* harmony export */   createIdleResolvedPromise: () => (/* binding */ createIdleResolvedPromise),
/* harmony export */   createNativeAllPromise: () => (/* binding */ createNativeAllPromise),
/* harmony export */   createNativeAllSettledPromise: () => (/* binding */ createNativeAllSettledPromise),
/* harmony export */   createNativeAnyPromise: () => (/* binding */ createNativeAnyPromise),
/* harmony export */   createNativePromise: () => (/* binding */ createNativePromise),
/* harmony export */   createNativeRacePromise: () => (/* binding */ createNativeRacePromise),
/* harmony export */   createNativeRejectedPromise: () => (/* binding */ createNativeRejectedPromise),
/* harmony export */   createNativeResolvedPromise: () => (/* binding */ createNativeResolvedPromise),
/* harmony export */   createPromise: () => (/* binding */ createPromise),
/* harmony export */   createRacePromise: () => (/* binding */ createRacePromise),
/* harmony export */   createRejectedPromise: () => (/* binding */ createRejectedPromise),
/* harmony export */   createResolvedPromise: () => (/* binding */ createResolvedPromise),
/* harmony export */   createSyncAllPromise: () => (/* binding */ createSyncAllPromise),
/* harmony export */   createSyncAllSettledPromise: () => (/* binding */ createSyncAllSettledPromise),
/* harmony export */   createSyncAnyPromise: () => (/* binding */ createSyncAnyPromise),
/* harmony export */   createSyncPromise: () => (/* binding */ createSyncPromise),
/* harmony export */   createSyncRacePromise: () => (/* binding */ createSyncRacePromise),
/* harmony export */   createSyncRejectedPromise: () => (/* binding */ createSyncRejectedPromise),
/* harmony export */   createSyncResolvedPromise: () => (/* binding */ createSyncResolvedPromise),
/* harmony export */   createTaskScheduler: () => (/* binding */ createTaskScheduler),
/* harmony export */   createTimeoutPromise: () => (/* binding */ createTimeoutPromise),
/* harmony export */   doAwait: () => (/* binding */ doAwait),
/* harmony export */   doAwaitResponse: () => (/* binding */ doAwaitResponse),
/* harmony export */   doFinally: () => (/* binding */ doFinally),
/* harmony export */   doWhileAsync: () => (/* binding */ doWhileAsync),
/* harmony export */   iterForOfAsync: () => (/* binding */ iterForOfAsync),
/* harmony export */   setCreatePromiseImpl: () => (/* binding */ setCreatePromiseImpl),
/* harmony export */   setDefaultIdlePromiseTimeout: () => (/* binding */ setDefaultIdlePromiseTimeout),
/* harmony export */   setDefaultIdleTimeout: () => (/* binding */ setDefaultIdleTimeout),
/* harmony export */   setPromiseDebugState: () => (/* binding */ setPromiseDebugState)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/*!
 * NevWare21 Solutions LLC - ts-async, 0.5.5
 * https://github.com/nevware21/ts-async
 * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.
 * Licensed under the MIT license.
 */


var STR_PROMISE = "Promise";
var DONE = "done";
var VALUE = "value";
var RETURN = "return";
var REJECTED = "rejected";

function doAwaitResponse(value, cb) {
    return doAwait(value, function (value) {
        return cb ? cb({
            status: "fulfilled",
            rejected: false,
            value: value
        }) : value;
    }, function (reason) {
        return cb ? cb({
            status: REJECTED,
            rejected: true,
            reason: reason
        }) : reason;
    });
}
function doAwait(value, resolveFn, rejectFn, finallyFn) {
    var result = value;
    try {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {
            if (resolveFn || rejectFn) {
                result = value.then(resolveFn, rejectFn);
            }
        }
        else {
            try {
                if (resolveFn) {
                    result = resolveFn(value);
                }
            }
            catch (err) {
                if (rejectFn) {
                    result = rejectFn(err);
                }
                else {
                    throw err;
                }
            }
        }
    }
    finally {
        if (finallyFn) {
            doFinally(result, finallyFn);
        }
    }
    return result;
}
function doFinally(value, finallyFn) {
    var result = value;
    if (finallyFn) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {
            if (value.finally) {
                result = value.finally(finallyFn);
            }
            else {
                result = value.then(function (value) {
                    finallyFn();
                    return value;
                }, function (reason) {
                    finallyFn();
                    throw reason;
                });
            }
        }
        else {
            finallyFn();
        }
    }
    return result;
}

/*#__NO_SIDE_EFFECTS__*/
function _pureAssign(func1, func2) {
    return func1 || func2;
}

var _debugState;
var _debugResult;
var _debugHandled;
var _promiseDebugEnabled = false;
function _addDebugState$1(thePromise, stateFn, resultFn, handledFn) {
    _debugState = _debugState || { toString: function () { return "[[PromiseState]]"; } };
    _debugResult = _debugResult || { toString: function () { return "[[PromiseResult]]"; } };
    _debugHandled = _debugHandled || { toString: function () { return "[[PromiseIsHandled]]"; } };
    var props = {};
    props[_debugState] = { get: stateFn };
    props[_debugResult] = { get: resultFn };
    props[_debugHandled] = { get: handledFn };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProperties)(thePromise, props);
}
function setPromiseDebugState(enabled, logger) {
    _promiseDebugEnabled = enabled;
}

var STRING_STATES = [
    "pending", "resolving", "resolved", REJECTED
];

var DISPATCH_EVENT = "dispatchEvent";
var _hasInitEvent;
function _hasInitEventFn(doc) {
    var evt;
    if (doc && doc.createEvent) {
        evt = doc.createEvent("Event");
    }
    return (!!evt && evt.initEvent);
}
function emitEvent(target, evtName, populateEvent, useNewEvent) {
    var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    !_hasInitEvent && (_hasInitEvent = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(!!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_hasInitEventFn, [doc]).v));
    var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : (useNewEvent ? new Event(evtName) : {});
    populateEvent && populateEvent(theEvt);
    if (_hasInitEvent.v) {
        theEvt.initEvent(evtName, false, true);
    }
    if (theEvt && target[DISPATCH_EVENT]) {
        target[DISPATCH_EVENT](theEvt);
    }
    else {
        var handler = target["on" + evtName];
        if (handler) {
            handler(theEvt);
        }
        else {
            var theConsole = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst)("console");
            theConsole && (theConsole["error"] || theConsole["log"])(evtName, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(theEvt));
        }
    }
}

var NODE_UNHANDLED_REJECTION = "unhandledRejection";
var UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();
var _currentPromiseId = [];
var _uniquePromiseId = 0;
var _unhandledRejectionTimeout = 10;
var _aggregationError;
var _hasPromiseRejectionEvent;
function dumpFnObj(value) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) {
        return value.toString();
    }
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(value);
}
/*#__NO_SIDE_EFFECTS__*/
function _createAggregationError(values) {
    !_aggregationError && (_aggregationError = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, ["AggregationError"]).v || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomError)("AggregationError", function (self, args) {
        self.errors = args[0];
    })));
    return new _aggregationError.v(values);
}
function _createPromise(newPromise, processor, executor) {
    var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 3);
    var _state = 0 ;
    var _hasResolved = false;
    var _settledValue;
    var _queue = [];
    var _id = _uniquePromiseId++;
    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;
    var _handled = false;
    var _unHandledRejectionHandler = null;
    var _thePromise;
    function _then(onResolved, onRejected) {
        try {
            _currentPromiseId.push(_id);
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            var thenPromise = newPromise(function (resolve, reject) {
                _queue.push(function () {
                    try {
                        var handler = _state === 2  ? onResolved : onRejected;
                        var value = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(handler) ? _settledValue : ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(handler) ? handler(_settledValue) : handler);
                        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {
                            value.then(resolve, reject);
                        }
                        else if (handler) {
                            resolve(value);
                        }
                        else if (_state === 3 ) {
                            reject(value);
                        }
                        else {
                            resolve(value);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
                if (_hasResolved) {
                    _processQueue();
                }
            }, additionalArgs);
            return thenPromise;
        }
        finally {
            _currentPromiseId.pop();
        }
    }
    function _catch(onRejected) {
        return _then(undefined, onRejected);
    }
    function _finally(onFinally) {
        var thenFinally = onFinally;
        var catchFinally = onFinally;
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(onFinally)) {
            thenFinally = function (value) {
                onFinally && onFinally();
                return value;
            };
            catchFinally = function (reason) {
                onFinally && onFinally();
                throw reason;
            };
        }
        return _then(thenFinally, catchFinally);
    }
    function _strState() {
        return STRING_STATES[_state];
    }
    function _processQueue() {
        if (_queue.length > 0) {
            var pending = _queue.slice();
            _queue = [];
            _handled = true;
            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();
            _unHandledRejectionHandler = null;
            processor(pending);
        }
    }
    function _createSettleIfFn(newState, allowState) {
        return function (theValue) {
            if (_state === allowState) {
                if (newState === 2  && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(theValue)) {
                    _state = 1 ;
                    theValue.then(_createSettleIfFn(2 , 1 ), _createSettleIfFn(3 , 1 ));
                    return;
                }
                _state = newState;
                _hasResolved = true;
                _settledValue = theValue;
                _processQueue();
                if (!_handled && newState === 3  && !_unHandledRejectionHandler) {
                    _unHandledRejectionHandler = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(_notifyUnhandledRejection, _unhandledRejectionTimeout);
                }
            }
        };
    }
    function _notifyUnhandledRejection() {
        if (!_handled) {
            _handled = true;
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNode)()) {
                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);
            }
            else {
                var gbl = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)() || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getGlobal)();
                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)((_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst), [STR_PROMISE + "RejectionEvent"]).v));
                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(theEvt, "promise", { g: function () { return _thePromise; } });
                    theEvt.reason = _settledValue;
                    return theEvt;
                }, !!_hasPromiseRejectionEvent.v);
            }
        }
    }
    _thePromise = {
        then: _then,
        "catch": _catch,
        finally: _finally
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(_thePromise, "state", {
        get: _strState
    });
    if (_promiseDebugEnabled) {
        _addDebugState$1(_thePromise, _strState, function () { return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objToString)(_settledValue); }, function () { return _handled; });
    }
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.hasSymbol)()) {
        _thePromise[(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(11 )] = "IPromise";
    }
    function _toString() {
        return "IPromise" + (_promiseDebugEnabled ? "[" + _id + (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(_parentId) ? (":" + _parentId) : "") + "]" : "") + " " + _strState() + (_hasResolved ? (" - " + dumpFnObj(_settledValue)) : "") + ("");
    }
    _thePromise.toString = _toString;
    (function _initialize() {
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(executor)) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
        }
        var _rejectFn = _createSettleIfFn(3 , 0 );
        try {
            executor.call(_thePromise, _createSettleIfFn(2 , 0 ), _rejectFn);
        }
        catch (e) {
            _rejectFn(e);
        }
    })();
    return _thePromise;
}
/*#__NO_SIDE_EFFECTS__*/
function _createAllPromise(newPromise) {
    return function (input) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (resolve, reject) {
            try {
                var values_1 = [];
                var pending_1 = 1;
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, function (item, idx) {
                    if (item) {
                        pending_1++;
                        doAwait(item, function (value) {
                            values_1[idx] = value;
                            if (--pending_1 === 0) {
                                resolve(values_1);
                            }
                        }, reject);
                    }
                });
                pending_1--;
                if (pending_1 === 0) {
                    resolve(values_1);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createResolvedPromise(newPromise) {
    return function (value) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(value)) {
            return value;
        }
        return newPromise(function (resolve) {
            resolve(value);
        }, additionalArgs);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createRejectedPromise(newPromise) {
    return function (reason) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (_resolve, reject) {
            reject(reason);
        }, additionalArgs);
    };
}
/*#__NO_SIDE_EFFECTS__*/
function _createAllSettledPromise(newPromise) {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (resolve, reject) {
            var values = [];
            var pending = 1;
            function processItem(item, idx) {
                pending++;
                doAwaitResponse(item, function (value) {
                    if (value.rejected) {
                        values[idx] = {
                            status: REJECTED,
                            reason: value.reason
                        };
                    }
                    else {
                        values[idx] = {
                            status: "fulfilled",
                            value: value.value
                        };
                    }
                    if (--pending === 0) {
                        resolve(values);
                    }
                });
            }
            try {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);
                }
                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);
                }
                else {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("Input is not an iterable");
                }
                pending--;
                if (pending === 0) {
                    resolve(values);
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}
/*#__NO_SIDE_EFFECTS__*/
function _createRacePromise(newPromise) {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (resolve, reject) {
            var isDone = false;
            function processItem(item) {
                doAwaitResponse(item, function (value) {
                    if (!isDone) {
                        isDone = true;
                        if (value.rejected) {
                            reject(value.reason);
                        }
                        else {
                            resolve(value.value);
                        }
                    }
                });
            }
            try {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);
                }
                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);
                }
                else {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("Input is not an iterable");
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}
/*#__NO_SIDE_EFFECTS__*/
function _createAnyPromise(newPromise) {
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input) {
        var additionalArgs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrSlice)(arguments, 1);
        return newPromise(function (resolve, reject) {
            var theErros = [];
            var pending = 1;
            var isDone = false;
            function processItem(item, idx) {
                pending++;
                doAwaitResponse(item, function (value) {
                    if (!value.rejected) {
                        isDone = true;
                        resolve(value.value);
                        return;
                    }
                    else {
                        theErros[idx] = value.reason;
                    }
                    if (--pending === 0 && !isDone) {
                        reject(_createAggregationError(theErros));
                    }
                });
            }
            try {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(input, processItem);
                }
                else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterable)(input)) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.iterForOf)(input, processItem);
                }
                else {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("Input is not an iterable");
                }
                pending--;
                if (pending === 0 && !isDone) {
                    reject(_createAggregationError(theErros));
                }
            }
            catch (e) {
                reject(e);
            }
        }, additionalArgs);
    });
}

function syncItemProcessor(pending) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(pending, function (fn) {
        try {
            fn();
        }
        catch (e) {
        }
    });
}
function timeoutItemProcessor(timeout) {
    var callbackTimeout = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNumber)(timeout) ? timeout : 0;
    return function (pending) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
            syncItemProcessor(pending);
        }, callbackTimeout);
    };
}
function idleItemProcessor(timeout) {
    var options;
    if (timeout >= 0) {
        options = {
            timeout: +timeout
        };
    }
    return function (pending) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleIdleCallback)(function (deadline) {
            syncItemProcessor(pending);
        }, options);
    };
}

var _allAsyncSettledCreator;
var _raceAsyncCreator;
var _anyAsyncCreator;
function createAsyncPromise(executor, timeout) {
    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
}
var createAsyncAllPromise = ( /*#__PURE__*/_createAllPromise(createAsyncPromise));
var createAsyncResolvedPromise = ( /*#__PURE__*/_createResolvedPromise(createAsyncPromise));
var createAsyncRejectedPromise = ( /*#__PURE__*/_createRejectedPromise(createAsyncPromise));
function createAsyncAllSettledPromise(input, timeout) {
    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));
    return _allAsyncSettledCreator.v(input, timeout);
}
function createAsyncRacePromise(values, timeout) {
    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));
    return _raceAsyncCreator.v(values, timeout);
}
function createAsyncAnyPromise(values, timeout) {
    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));
    return _anyAsyncCreator.v(values, timeout);
}

var _promiseCls;
var _allCreator;
var _allNativeSettledCreator;
var _raceNativeCreator;
var _anyNativeCreator;
/*#__NO_SIDE_EFFECTS__*/
function _createNativePromiseHelper(name, func) {
    !_promiseCls && (_promiseCls = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, [STR_PROMISE]).v) || null));
    if (_promiseCls.v && _promiseCls.v[name]) {
        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(function (input, timeout) {
            return createNativePromise(function (resolve, reject) {
                _promiseCls.v[name](input).then(resolve, reject);
            });
        });
    }
    return func();
}
function createNativePromise(executor, timeout) {
    !_promiseCls && (_promiseCls = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.safe)(_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst, [STR_PROMISE]).v) || null));
    var PrmCls = _promiseCls.v;
    if (!PrmCls) {
        return createAsyncPromise(executor);
    }
    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(executor)) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)(STR_PROMISE + ": executor is not a function - " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(executor));
    }
    var _state = 0 ;
    function _strState() {
        return STRING_STATES[_state];
    }
    var thePromise = new PrmCls(function (resolve, reject) {
        function _resolve(value) {
            _state = 2 ;
            resolve(value);
        }
        function _reject(reason) {
            _state = 3 ;
            reject(reason);
        }
        executor(_resolve, _reject);
    });
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(thePromise, "state", {
        get: _strState
    });
    return thePromise;
}
function createNativeAllPromise(input, timeout) {
    !_allCreator && (_allCreator = _createNativePromiseHelper("all", function () { return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(_createAllPromise(createNativePromise)); }));
    return _allCreator.v(input, timeout);
}
var createNativeResolvedPromise = ( /*#__PURE__*/_createResolvedPromise(createNativePromise));
var createNativeRejectedPromise = ( /*#__PURE__*/_createRejectedPromise(createNativePromise));
function createNativeAllSettledPromise(input, timeout) {
    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper("allSettled", function () { return _createAllSettledPromise(createNativePromise); }));
    return _allNativeSettledCreator.v(input, timeout);
}
function createNativeRacePromise(values, timeout) {
    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper("race", function () { return _createRacePromise(createNativePromise); }));
    return _raceNativeCreator.v(values, timeout);
}
function createNativeAnyPromise(values, timeout) {
    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper("any", function () { return _createAnyPromise(createNativePromise); }));
    return _anyNativeCreator.v(values, timeout);
}

var _allSyncSettledCreator;
var _raceSyncCreator;
var _anySyncCreator;
function createSyncPromise(executor) {
    return _createPromise(createSyncPromise, syncItemProcessor, executor);
}
var createSyncAllPromise = ( /*#__PURE__*/_createAllPromise(createSyncPromise));
var createSyncResolvedPromise = ( /*#__PURE__*/_createResolvedPromise(createSyncPromise));
var createSyncRejectedPromise = ( /*#__PURE__*/_createRejectedPromise(createSyncPromise));
function createSyncAllSettledPromise(input, timeout) {
    !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));
    return _allSyncSettledCreator.v(input, timeout);
}
function createSyncRacePromise(values, timeout) {
    !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));
    return _raceSyncCreator.v(values, timeout);
}
function createSyncAnyPromise(values, timeout) {
    !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));
    return _anySyncCreator.v(values, timeout);
}

var _defaultIdleTimeout;
var _allIdleSettledCreator;
var _raceIdleCreator;
var _anyIdleCreator;
function setDefaultIdlePromiseTimeout(idleDeadline) {
    _defaultIdleTimeout = idleDeadline;
}
var setDefaultIdleTimeout = ( /*#__PURE__*/_pureAssign(setDefaultIdlePromiseTimeout));
function createIdlePromise(executor, timeout) {
    var theTimeout = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(timeout) ? _defaultIdleTimeout : timeout;
    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);
}
var createIdleAllPromise = ( /*#__PURE__*/_createAllPromise(createIdlePromise));
var createIdleResolvedPromise = ( /*#__PURE__*/_createResolvedPromise(createIdlePromise));
var createIdleRejectedPromise = ( /*#__PURE__*/_createRejectedPromise(createIdlePromise));
function createIdleAllSettledPromise(input, timeout) {
    !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));
    return _allIdleSettledCreator.v(input, timeout);
}
function createIdleRacePromise(values, timeout) {
    !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));
    return _raceIdleCreator.v(values, timeout);
}
function createIdleAnyPromise(values, timeout) {
    !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));
    return _anyIdleCreator.v(values, timeout);
}

var _promiseCreator;
var _allSettledCreator;
var _raceCreator;
var _anyCreator;
function setCreatePromiseImpl(creator) {
    _promiseCreator = creator ? (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(creator) : null;
}
function createPromise(executor, timeout) {
    !_promiseCreator && (_promiseCreator = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)(createNativePromise));
    return _promiseCreator.v.call(this, executor, timeout);
}
var createAllPromise = ( /*#__PURE__*/_createAllPromise(createPromise));
var createResolvedPromise = ( /*#__PURE__*/_createResolvedPromise(createPromise));
var createRejectedPromise = ( /*#__PURE__*/_createRejectedPromise(createPromise));
function createAllSettledPromise(input, timeout) {
    !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));
    return _allSettledCreator.v(input, timeout);
}
function createRacePromise(values, timeout) {
    !_raceCreator && (_raceCreator = _createRacePromise(createPromise));
    return _raceCreator.v(values, timeout);
}
function createAnyPromise(values, timeout) {
    !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));
    return _anyCreator.v(values, timeout);
}

function createTimeoutPromise(timeout, resolveReject, message) {
    return createPromise(function (resolve, reject) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
            (resolveReject ? resolve : reject)(!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(message) ? message : "Timeout of " + timeout + "ms exceeded");
        }, timeout);
    });
}

function _doneChk(isDone, state, value, thisArg) {
    var result = isDone;
    state.res = value;
    if (!result) {
        if (state.isDone && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(state.isDone)) {
            return doAwait(state.isDone.call(thisArg, state), function (done) {
                state.iter++;
                return !!done;
            });
        }
        else {
            result = !!state.isDone;
        }
    }
    state.iter++;
    return result;
}
function doWhileAsync(callbackFn, isDoneFn, thisArg) {
    var promise;
    var resolve;
    var reject = function (reason) {
        isDone = true;
        throw reason;
    };
    var isDone = false;
    var state = {
        st: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)(),
        iter: 0,
        isDone: isDoneFn || false
    };
    if (callbackFn) {
        var _createPromise_1 = function () {
            return createPromise(function (res, rej) {
                resolve = res;
                reject = rej;
            });
        };
        var _handleAsyncDone_1 = function (done) {
            isDone = !!done;
            if (!isDone) {
                _processNext_1();
            }
            else {
                resolve(state.res);
            }
        };
        var _processNext_1 = function () {
            while (!isDone) {
                try {
                    var cbResult = callbackFn.call(thisArg, state);
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(cbResult)) {
                        promise = promise || _createPromise_1();
                        doAwait(cbResult, function (res) {
                            try {
                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone_1, reject);
                            }
                            catch (e) {
                                reject(e);
                            }
                        }, reject);
                        return promise;
                    }
                    else {
                        var dnRes = _doneChk(isDone, state, cbResult, thisArg);
                        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(dnRes)) {
                            promise = promise || _createPromise_1();
                            doAwait(dnRes, _handleAsyncDone_1, reject);
                            return promise;
                        }
                        else {
                            isDone = !!dnRes;
                        }
                    }
                }
                catch (e) {
                    reject(e);
                    return promise;
                }
            }
            if (isDone && resolve) {
                resolve(state.res);
            }
            return promise || state.res;
        };
        return _processNext_1();
    }
}

function arrForEachAsync(theArray, callbackFn, thisArg) {
    if (theArray) {
        var len_1 = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(theArray);
        if (len_1) {
            var isDone = function (state) {
                if (state.iter >= len_1 || state.res === -1) {
                    return true;
                }
            };
            return doWhileAsync(function (state) {
                var idx = state.iter;
                if (idx in theArray) {
                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);
                }
            }, isDone);
        }
    }
}

var _iterSymbol;
var _iterAsyncSymbol;
function iterForOfAsync(iter, callbackFn, thisArg) {
    var err;
    var iterResult;
    var theIter = iter;
    function onFailed(failed) {
        err = { e: failed };
        if (theIter.throw) {
            iterResult = null;
            theIter.throw(err);
        }
        throw failed;
    }
    function onFinally() {
        try {
            if (iterResult && !iterResult[DONE]) {
                theIter[RETURN] && theIter[RETURN](iterResult);
            }
        }
        finally {
            if (err) {
                throw err.e;
            }
        }
    }
    if (iter) {
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterator)(iter)) {
            !_iterAsyncSymbol && (_iterAsyncSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(0 )));
            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;
            if (!theIter) {
                !_iterSymbol && (_iterSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCachedValue)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(3 )));
                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;
            }
        }
        if (theIter && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isIterator)(theIter)) {
            var result = void 0;
            try {
                result = doWhileAsync(function (state) {
                    return doAwait(theIter.next(), function (res) {
                        iterResult = res;
                        if (!res[DONE]) {
                            return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.fnCall)(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);
                        }
                    }, function (reason) {
                        state.isDone = true;
                        onFailed(reason);
                    });
                }, function (state) {
                    if (!iterResult || iterResult[DONE] || state.res === -1) {
                        onFinally();
                        return true;
                    }
                }, thisArg || theIter);
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(result)) {
                    result = doFinally(result.catch(onFailed), onFinally);
                }
                return result;
            }
            catch (failed) {
                onFailed(failed);
            }
            finally {
                if (result && !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(result)) {
                    onFinally();
                }
            }
        }
    }
}

var REJECT = "reject";
var REJECTED_ERROR = "Rejected";
var _schedulerId = 0;
var _debugName;
var _debugIntState;
var _customErrors = {};
function _rejectDone() {
}
function _createError(type, evt, message) {
    !_customErrors[type] && (_customErrors[type] = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomError)(type));
    var now = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
    return new (_customErrors[type])("Task [".concat(evt.id, "] ").concat(message || "", "- ").concat((evt.st ? "Running" : "Waiting"), ": ").concat(_calcTime(now, evt.st || evt.cr)));
}
function _calcTime(now, start) {
    return ((now - start) || "0") + " ms";
}
function _abortStaleTasks(taskQueue, staleTimeoutPeriod) {
    var now = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
    var expired = now - staleTimeoutPeriod;
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(taskQueue, function (evt) {
        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {
            evt && evt[REJECT](evt.rj || _createError("Aborted", evt, "Stale "));
        }
    });
}
function _removeTask(queue, taskDetail) {
    var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(queue, taskDetail);
    if (idx !== -1) {
        queue.splice(idx, 1);
    }
}
function _addDebugState(theScheduler, nameFn, stateFn) {
    _debugName = _debugName || { toString: function () { return "[[SchedulerName]]"; } };
    _debugIntState = _debugIntState || { toString: function () { return "[[SchedulerState]]"; } };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(theScheduler, _debugName, { get: nameFn });
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(theScheduler, _debugIntState, { get: stateFn });
}
function createTaskScheduler(newPromise, name) {
    var _theTask;
    var _running = [];
    var _waiting = [];
    var _staleTimeoutPeriod = 600000;
    var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;
    var _taskCount = 0;
    var _schedulerName = (name ? (name + ".") : "") + _schedulerId++;
    var _blockedTimer;
    newPromise = newPromise || createPromise;
    var _startBlockedTimer = function () {
        var hasTasks = ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting)) > 0;
        if (_staleTimeoutPeriod > 0) {
            if (!_blockedTimer) {
                _blockedTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                    _abortStaleTasks(_running, _staleTimeoutPeriod);
                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);
                    _blockedTimer && (_blockedTimer.enabled = (((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting)) > 0));
                }, _staleTimeoutCheckPeriod);
                _blockedTimer.unref();
            }
            _blockedTimer && (_blockedTimer.enabled = hasTasks);
        }
    };
    var _queueTask = function (startAction, taskName, timeout) {
        var _a;
        var taskId = _schedulerName + "." + _taskCount++;
        if (taskName) {
            taskId += "-(" + taskName + ")";
        }
        var newTask = (_a = {
                id: taskId,
                cr: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)(),
                to: timeout
            },
            _a[REJECT] = function (reason) {
                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);
                newTask[REJECT] = _rejectDone;
            },
            _a);
        if (!_theTask) {
            newTask.p = newPromise(_runTask(newTask, startAction));
        }
        else {
            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);
        }
        _theTask = newTask;
        return newTask.p;
    };
    var _runTask = function (taskDetail, startAction) {
        taskDetail.st = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
        _running.push(taskDetail);
        _startBlockedTimer();
        return function (onTaskResolve, onTaskReject) {
            var _promiseReject = function (reason) {
                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);
                taskDetail[REJECT] = _rejectDone;
                _doCleanup(taskDetail);
                onTaskResolve = null;
                onTaskReject && onTaskReject(reason);
                onTaskReject = null;
            };
            var taskId = taskDetail.id;
            if (taskDetail.rj) {
                _promiseReject(taskDetail.rj);
            }
            else {
                taskDetail[REJECT] = _promiseReject;
                try {
                    var startResult = startAction(taskId);
                    if (taskDetail.to && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPromiseLike)(startResult)) {
                        taskDetail.t = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                            _promiseReject(_createError("Timeout", taskDetail));
                        }, taskDetail.to);
                    }
                    doAwait(startResult, function (theResult) {
                        _doCleanup(taskDetail);
                        try {
                            onTaskResolve && onTaskResolve(theResult);
                        }
                        catch (e) {
                            onTaskReject && onTaskReject(e);
                        }
                        onTaskReject = null;
                        onTaskResolve = null;
                    }, _promiseReject);
                }
                catch (e) {
                    _promiseReject(e);
                }
            }
        };
    };
    var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {
        _waiting.push(taskDetail);
        _startBlockedTimer();
        return newPromise(function (onWaitResolve, onWaitReject) {
            doAwaitResponse(prevTask.p, function () {
                _removeTask(_waiting, taskDetail);
                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);
            });
        });
    };
    var _doCleanup = function (taskDetail) {
        _removeTask(_running, taskDetail);
        taskDetail.t && taskDetail.t.cancel();
        taskDetail.t = null;
        if (_theTask && _theTask === taskDetail) {
            _theTask = null;
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting) === 0) {
                _blockedTimer && _blockedTimer.cancel();
                _blockedTimer = null;
            }
        }
    };
    var theScheduler = {
        idle: true,
        queue: _queueTask,
        setStaleTimeout: function (staleTimeout, staleCheckPeriod) {
            _blockedTimer && _blockedTimer.cancel();
            _blockedTimer = null;
            _staleTimeoutPeriod = staleTimeout;
            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;
            _startBlockedTimer();
        }
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(theScheduler, "idle", {
        g: function () {
            return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_running) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLength)(_waiting) === 0;
        }
    });
    _addDebugState(theScheduler, function () { return _schedulerName; }, function () {
        return {
            l: _theTask,
            r: _running,
            w: _waiting
        };
    });
    return theScheduler;
}

var toStringTagSymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getKnownSymbol)(11 );
var PolyPromise = ( /*#__PURE__*/(function () {
    function PolyPromiseImpl(executor) {
        this._$ = createAsyncPromise(executor);
        if (toStringTagSymbol) {
            this[toStringTagSymbol] = "Promise";
        }
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(this, "state", {
            get: function () {
                return this._$.state;
            }
        });
    }
    PolyPromiseImpl.all = createAsyncAllPromise;
    PolyPromiseImpl.race = createAsyncRacePromise;
    PolyPromiseImpl.any = createAsyncAnyPromise;
    PolyPromiseImpl.reject = createAsyncRejectedPromise;
    PolyPromiseImpl.resolve = createAsyncResolvedPromise;
    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;
    var theProto = PolyPromiseImpl.prototype;
    theProto.then = function (onResolved, onRejected) {
        return this._$.then(onResolved, onRejected);
    };
    theProto.catch = function (onRejected) {
        return this._$.catch(onRejected);
    };
    theProto.finally = function (onfinally) {
        return this._$.finally(onfinally);
    };
    return PolyPromiseImpl;
}()));


//# sourceMappingURL=ts-async.js.map


/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDynamicConfig: () => (/* binding */ createDynamicConfig),
/* harmony export */   onConfigChange: () => (/* binding */ onConfigChange)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _JavaScriptSDK_DataCacheHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _ConfigDefaults__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29);
/* harmony import */ var _DynamicProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30);
/* harmony import */ var _DynamicState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(32);
/* harmony import */ var _DynamicSupport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(31);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */










/**
 * Identifies a function which will be re-called whenever any of it's accessed configuration values
 * change.
 * @param configHandler - The callback that will be called for the initial request and then whenever any
 * accessed configuration changes are identified.
 */
function _createAndUseHandler(state, configHandler) {
    var handler = {
        fn: configHandler,
        rm: function () {
            // Clear all references to the handler so it can be garbage collected
            // This will also cause this handler to never get called and eventually removed
            handler.fn = null;
            state = null;
            configHandler = null;
        }
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(handler, "toJSON", { v: function () { return "WatcherHandler" + (handler.fn ? "" : "[X]"); } });
    state.use(handler, configHandler);
    return handler;
}
/**
 * Creates the dynamic config handler and associates with the target config as the root object
 * @param target - The config that you want to be root of the dynamic config
 * @param inPlace - Should the passed config be converted in-place or a new proxy returned
 * @returns The existing dynamic handler or a new instance with the provided config values
 */
function _createDynamicHandler(logger, target, inPlace) {
    var dynamicHandler = (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_7__.getDynamicConfigHandler)(target);
    if (dynamicHandler) {
        // The passed config is already dynamic so return it's tracker
        return dynamicHandler;
    }
    var uid = (0,_JavaScriptSDK_DataCacheHelper__WEBPACK_IMPORTED_MODULE_1__.createUniqueNamespace)("dyncfg", true);
    var newTarget = (target && inPlace !== false) ? target : (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_7__._cfgDeepCopy)(target);
    var theState;
    function _notifyWatchers() {
        theState.notify();
    }
    function _setValue(target, name, value) {
        try {
            target = (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_5__._setDynamicProperty)(theState, target, name, value);
        }
        catch (e) {
            // Unable to convert to dynamic property so just leave as non-dynamic
            (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_5__._throwDynamicError)(logger, name, "Setting value", e);
        }
        return target[name];
    }
    function _watch(configHandler) {
        return _createAndUseHandler(theState, configHandler);
    }
    function _block(configHandler, allowUpdate) {
        theState.use(null, function (details) {
            var prevUpd = theState.upd;
            try {
                if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(allowUpdate)) {
                    theState.upd = allowUpdate;
                }
                configHandler(details);
            }
            finally {
                theState.upd = prevUpd;
            }
        });
    }
    function _ref(target, name) {
        var _a;
        // Make sure it's dynamic and mark as referenced with it's current value
        return (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_5__._setDynamicPropertyState)(theState, target, name, (_a = {}, _a[0 /* _eSetDynamicPropertyFlags.inPlace */] = true, _a))[name];
    }
    function _rdOnly(target, name) {
        var _a;
        // Make sure it's dynamic and mark as readonly with it's current value
        return (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_5__._setDynamicPropertyState)(theState, target, name, (_a = {}, _a[1 /* _eSetDynamicPropertyFlags.readOnly */] = true, _a))[name];
    }
    function _blkPropValue(target, name) {
        var _a;
        // Make sure it's dynamic and mark as readonly with it's current value
        return (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_5__._setDynamicPropertyState)(theState, target, name, (_a = {}, _a[2 /* _eSetDynamicPropertyFlags.blockDynamicProperty */] = true, _a))[name];
    }
    function _applyDefaults(theConfig, defaultValues) {
        if (defaultValues) {
            // Resolve/apply the defaults
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(defaultValues, function (name, value) {
                // Sets the value and makes it dynamic (if it doesn't already exist)
                (0,_ConfigDefaults__WEBPACK_IMPORTED_MODULE_4__._applyDefaultValue)(cfgHandler, theConfig, name, value);
            });
        }
        return theConfig;
    }
    var cfgHandler = {
        uid: null,
        cfg: newTarget,
        logger: logger,
        notify: _notifyWatchers,
        set: _setValue,
        setDf: _applyDefaults,
        watch: _watch,
        ref: _ref,
        rdOnly: _rdOnly,
        blkVal: _blkPropValue,
        _block: _block
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(cfgHandler, "uid", {
        c: false,
        e: false,
        w: false,
        v: uid
    });
    theState = (0,_DynamicState__WEBPACK_IMPORTED_MODULE_6__._createState)(cfgHandler);
    // Setup tracking for all defined default keys
    (0,_DynamicProperty__WEBPACK_IMPORTED_MODULE_5__._makeDynamicObject)(theState, newTarget, "config", "Creating");
    return cfgHandler;
}
/**
 * Log an invalid access message to the console
 */
function _logInvalidAccess(logger, message) {
    if (logger) {
        logger[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);
        logger[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](2 /* eLoggingSeverity.WARNING */, 108 /* _eInternalMessageId.DynamicConfigException */, message);
    }
    else {
        // We don't have a logger so just throw an exception
        (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_7__.throwInvalidAccess)(message);
    }
}
/**
 * Create or return a dynamic version of the passed config, if it is not already dynamic
 * @param config - The config to be converted into a dynamic config
 * @param defaultConfig - The default values to apply on the config if the properties don't already exist
 * @param inPlace - Should the config be converted in-place into a dynamic config or a new instance returned, defaults to true
 * @returns The dynamic config handler for the config (whether new or existing)
 */
function createDynamicConfig(config, defaultConfig, logger, inPlace) {
    var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
    if (defaultConfig) {
        dynamicHandler.setDf(dynamicHandler.cfg, defaultConfig);
    }
    return dynamicHandler;
}
/**
 * Watch and track changes for accesses to the current config, the provided config MUST already be
 * a dynamic config or a child accessed via the dynamic config
 * @param logger - The logger instance to use if there is no existing handler
 * @returns A watcher handler instance that can be used to remove itself when being unloaded
 * @throws TypeError if the provided config is not a dynamic config instance
 */
function onConfigChange(config, configHandler, logger) {
    var handler = config[_DynamicSupport__WEBPACK_IMPORTED_MODULE_7__.CFG_HANDLER_LINK] || config;
    if (handler.cfg && (handler.cfg === config || handler.cfg[_DynamicSupport__WEBPACK_IMPORTED_MODULE_7__.CFG_HANDLER_LINK] === handler)) {
        return handler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:%2ewatch */](configHandler);
    }
    _logInvalidAccess(logger, _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_NOT_DYNAMIC_ERROR + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(config));
    return createDynamicConfig(config, null, logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WATCH /* @min:%2ewatch */](configHandler);
}
//# sourceMappingURL=DynamicConfig.js.map

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createElmNodeData: () => (/* binding */ createElmNodeData),
/* harmony export */   createUniqueNamespace: () => (/* binding */ createUniqueNamespace)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _RandomHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var version = '3.3.11';
var instanceName = "." + (0,_RandomHelper__WEBPACK_IMPORTED_MODULE_3__.newId)(6);
var _dataUid = 0;
// Accepts only:
//  - Node
//    - Node.ELEMENT_NODE
//    - Node.DOCUMENT_NODE
//  - Object
//    - Any
function _canAcceptData(target) {
    return target.nodeType === 1 || target.nodeType === 9 || !(+target.nodeType);
}
function _getCache(data, target) {
    var theCache = target[data.id];
    if (!theCache) {
        theCache = {};
        try {
            if (_canAcceptData(target)) {
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(target, data.id, {
                    e: false,
                    v: theCache
                });
            }
        }
        catch (e) {
            // Not all environments allow extending all objects, so just ignore the cache in those cases
        }
    }
    return theCache;
}
function createUniqueNamespace(name, includeVersion) {
    if (includeVersion === void 0) { includeVersion = false; }
    return (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.normalizeJsName)(name + (_dataUid++) + (includeVersion ? "." + version : _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY) + instanceName);
}
function createElmNodeData(name) {
    var data = {
        id: createUniqueNamespace("_aiData-" + (name || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY) + "." + version),
        accept: function (target) {
            return _canAcceptData(target);
        },
        get: function (target, name, defValue, addDefault) {
            var theCache = target[data.id];
            if (!theCache) {
                if (addDefault) {
                    // Side effect is adds the cache
                    theCache = _getCache(data, target);
                    theCache[(0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.normalizeJsName)(name)] = defValue;
                }
                return defValue;
            }
            return theCache[(0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.normalizeJsName)(name)];
        },
        kill: function (target, name) {
            if (target && target[name]) {
                try {
                    delete target[name];
                }
                catch (e) {
                    // Just cleaning up, so if this fails -- ignore
                }
            }
        }
    };
    return data;
}
//# sourceMappingURL=DataCacheHelper.js.map

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _appendHeader: () => (/* binding */ _appendHeader),
/* harmony export */   _getAllResponseHeaders: () => (/* binding */ _getAllResponseHeaders),
/* harmony export */   _getObjProto: () => (/* binding */ _getObjProto),
/* harmony export */   asString: () => (/* binding */ asString),
/* harmony export */   convertAllHeadersToMap: () => (/* binding */ convertAllHeadersToMap),
/* harmony export */   createClassFromInterface: () => (/* binding */ createClassFromInterface),
/* harmony export */   deepFreeze: () => (/* binding */ deepFreeze),
/* harmony export */   formatErrorMessageXdr: () => (/* binding */ formatErrorMessageXdr),
/* harmony export */   formatErrorMessageXhr: () => (/* binding */ formatErrorMessageXhr),
/* harmony export */   getExceptionName: () => (/* binding */ getExceptionName),
/* harmony export */   getResponseText: () => (/* binding */ getResponseText),
/* harmony export */   getSetValue: () => (/* binding */ getSetValue),
/* harmony export */   isFeatureEnabled: () => (/* binding */ isFeatureEnabled),
/* harmony export */   isNotNullOrUndefined: () => (/* binding */ isNotNullOrUndefined),
/* harmony export */   isNotUndefined: () => (/* binding */ isNotUndefined),
/* harmony export */   normalizeJsName: () => (/* binding */ normalizeJsName),
/* harmony export */   objExtend: () => (/* binding */ objExtend),
/* harmony export */   openXhr: () => (/* binding */ openXhr),
/* harmony export */   optimizeObject: () => (/* binding */ optimizeObject),
/* harmony export */   prependTransports: () => (/* binding */ prependTransports),
/* harmony export */   proxyAssign: () => (/* binding */ proxyAssign),
/* harmony export */   proxyFunctionAs: () => (/* binding */ proxyFunctionAs),
/* harmony export */   proxyFunctions: () => (/* binding */ proxyFunctions),
/* harmony export */   setValue: () => (/* binding */ setValue),
/* harmony export */   strContains: () => (/* binding */ strContains),
/* harmony export */   toISOString: () => (/* binding */ toISOString)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






// RESTRICT and AVOID circular dependencies you should not import other contained modules or export the contents of this file directly
// Added to help with minification
var strGetPrototypeOf = "getPrototypeOf";
var rCamelCase = /-([a-z])/g;
var rNormalizeInvalid = /([^\w\d_$])/g;
var rLeadingNumeric = /^(\d+[\w\d_$])/;
var _getObjProto = Object[strGetPrototypeOf];
function isNotUndefined(value) {
    return !(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(value);
}
function isNotNullOrUndefined(value) {
    return !(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(value);
}
/**
 * Validates that the string name conforms to the JS IdentifierName specification and if not
 * normalizes the name so that it would. This method does not identify or change any keywords
 * meaning that if you pass in a known keyword the same value will be returned.
 * This is a simplified version
 * @param name - The name to validate
 */
function normalizeJsName(name) {
    var value = name;
    if (value && (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
        // CamelCase everything after the "-" and remove the dash
        value = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_REPLACE /* @min:%2ereplace */](rCamelCase, function (_all, letter) {
            return letter.toUpperCase();
        });
        value = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_REPLACE /* @min:%2ereplace */](rNormalizeInvalid, "_");
        value = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_REPLACE /* @min:%2ereplace */](rLeadingNumeric, function (_all, match) {
            return "_" + match;
        });
    }
    return value;
}
/**
 * A simple wrapper (for minification support) to check if the value contains the search string.
 * @param value - The string value to check for the existence of the search value
 * @param search - The value search within the value
 */
function strContains(value, search) {
    if (value && search) {
        return (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(value, search) !== -1;
    }
    return false;
}
/**
 * Convert a date to I.S.O. format in IE8
 */
function toISOString(date) {
    return date && date.toISOString() || "";
}
var deepFreeze = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.objDeepFreeze;
/**
 * Returns the name of object if it's an Error. Otherwise, returns empty string.
 */
function getExceptionName(object) {
    if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isError)(object)) {
        return object[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */];
    }
    return _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY;
}
/**
 * Sets the provided value on the target instance using the field name when the provided chk function returns true, the chk
 * function will only be called if the new value is no equal to the original value.
 * @param target - The target object
 * @param field - The key of the target
 * @param value - The value to set
 * @param valChk - [Optional] Callback to check the value that if supplied will be called check if the new value can be set
 * @param srcChk - [Optional] Callback to check to original value that if supplied will be called if the new value should be set (if allowed)
 * @returns The existing or new value, depending what was set
 */
function setValue(target, field, value, valChk, srcChk) {
    var theValue = value;
    if (target) {
        theValue = target[field];
        if (theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value))) {
            theValue = value;
            target[field] = theValue;
        }
    }
    return theValue;
}
/**
 * Returns the current value from the target object if not null or undefined otherwise sets the new value and returns it
 * @param target - The target object to return or set the default value
 * @param field - The key for the field to set on the target
 * @param defValue - [Optional] The value to set if not already present, when not provided a empty object will be added
 */
function getSetValue(target, field, defValue) {
    var theValue;
    if (target) {
        theValue = target[field];
        if (!theValue && (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(theValue)) {
            // Supports having the default as null
            theValue = !(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(defValue) ? defValue : {};
            target[field] = theValue;
        }
    }
    else {
        // Expanded for performance so we only check defValue if required
        theValue = !(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(defValue) ? defValue : {};
    }
    return theValue;
}
function _createProxyFunction(source, funcName) {
    var srcFunc = null;
    var src = null;
    if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
        srcFunc = source;
    }
    else {
        src = source;
    }
    return function () {
        // Capture the original arguments passed to the method
        var originalArguments = arguments;
        if (srcFunc) {
            src = srcFunc();
        }
        if (src) {
            return src[funcName][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_APPLY /* @min:%2eapply */](src, originalArguments);
        }
    };
}
/**
 * Effectively assigns all enumerable properties (not just own properties) and functions (including inherited prototype) from
 * the source object to the target, it attempts to use proxy getters / setters (if possible) and proxy functions to avoid potential
 * implementation issues by assigning prototype functions as instance ones
 *
 * This method is the primary method used to "update" the snippet proxy with the ultimate implementations.
 *
 * Special ES3 Notes:
 * Updates (setting) of direct property values on the target or indirectly on the source object WILL NOT WORK PROPERLY, updates to the
 * properties of "referenced" object will work (target.context.newValue = 10 =\> will be reflected in the source.context as it's the
 * same object). ES3 Failures: assigning target.myProp = 3 -\> Won't change source.myProp = 3, likewise the reverse would also fail.
 * @param target - The target object to be assigned with the source properties and functions
 * @param source - The source object which will be assigned / called by setting / calling the targets proxies
 * @param chkSet - An optional callback to determine whether a specific property/function should be proxied
 */
function proxyAssign(target, source, chkSet) {
    if (target && source && (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isObject)(target) && (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
        var _loop_1 = function (field) {
            if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isString)(field)) {
                var value = source[field];
                if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
                    if (!chkSet || chkSet(field, true, source, target)) {
                        // Create a proxy function rather than just copying the (possible) prototype to the new object as an instance function
                        target[field] = _createProxyFunction(source, field);
                    }
                }
                else if (!chkSet || chkSet(field, false, source, target)) {
                    if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.objHasOwn)(target, field)) {
                        // Remove any previous instance property
                        delete target[field];
                    }
                    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.objDefine)(target, field, {
                        g: function () {
                            return source[field];
                        },
                        s: function (theValue) {
                            source[field] = theValue;
                        }
                    });
                }
            }
        };
        // effectively apply/proxy full source to the target instance
        for (var field in source) {
            _loop_1(field);
        }
    }
    return target;
}
/**
 * Creates a proxy function on the target which internally will call the source version with all arguments passed to the target method.
 *
 * @param target - The target object to be assigned with the source properties and functions
 * @param name - The function name that will be added on the target
 * @param source - The source object which will be assigned / called by setting / calling the targets proxies
 * @param theFunc - The function name on the source that will be proxied on the target
 * @param overwriteTarget - If `false` this will not replace any pre-existing name otherwise (the default) it will overwrite any existing name
 */
function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
    if (target && name && source) {
        if (overwriteTarget !== false || (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(target[name])) {
            target[name] = _createProxyFunction(source, theFunc);
        }
    }
}
/**
 * Creates proxy functions on the target which internally will call the source version with all arguments passed to the target method.
 *
 * @param target - The target object to be assigned with the source properties and functions
 * @param source - The source object which will be assigned / called by setting / calling the targets proxies
 * @param functionsToProxy - An array of function names that will be proxied on the target
 * @param overwriteTarget - If false this will not replace any pre-existing name otherwise (the default) it will overwrite any existing name
 */
function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
    if (target && source && (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isObject)(target) && (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isArray)(functionsToProxy)) {
        (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(functionsToProxy, function (theFuncName) {
            if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isString)(theFuncName)) {
                proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
            }
        });
    }
    return target;
}
/**
 * Simpler helper to create a dynamic class that implements the interface and populates the values with the defaults.
 * Only instance properties (hasOwnProperty) values are copied from the defaults to the new instance
 * @param defaults - Simple helper
 */
function createClassFromInterface(defaults) {
    return /** @class */ (function () {
        function class_1() {
            var _this = this;
            if (defaults) {
                (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(defaults, function (field, value) {
                    _this[field] = value;
                });
            }
        }
        return class_1;
    }());
}
/**
 * A helper function to assist with JIT performance for objects that have properties added / removed dynamically
 * this is primarily for chromium based browsers and has limited effects on Firefox and none of IE. Only call this
 * function after you have finished "updating" the object, calling this within loops reduces or defeats the benefits.
 * This helps when iterating using for..in, objKeys() and objForEach()
 * @param theObject - The object to be optimized if possible
 */
function optimizeObject(theObject) {
    // V8 Optimization to cause the JIT compiler to create a new optimized object for looking up the own properties
    // primarily for object with <= 19 properties for >= 20 the effect is reduced or non-existent
    if (theObject && _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.objAssign) {
        theObject = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.ObjClass)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.objAssign)({}, theObject));
    }
    return theObject;
}
function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
    // Variables
    var theArgs = arguments;
    var extended = theArgs[0] || {};
    var argLen = theArgs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */];
    var deep = false;
    var idx = 1;
    // Check for "Deep" flag
    if (argLen > 0 && (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(extended)) {
        deep = extended;
        extended = theArgs[idx] || {};
        idx++;
    }
    // Handle case when target is a string or something (possible in deep copy)
    if (!(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isObject)(extended)) {
        extended = {};
    }
    // Loop through each remaining object and conduct a merge
    for (; idx < argLen; idx++) {
        var arg = theArgs[idx];
        var isArgArray = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isArray)(arg);
        var isArgObj = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isObject)(arg);
        for (var prop in arg) {
            var propOk = (isArgArray && (prop in arg)) || (isArgObj && (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.objHasOwn)(arg, prop));
            if (!propOk) {
                continue;
            }
            var newValue = arg[prop];
            var isNewArray = void 0;
            // If deep merge and property is an object, merge properties
            if (deep && newValue && ((isNewArray = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isArray)(newValue)) || (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(newValue))) {
                // Grab the current value of the extended object
                var clone = extended[prop];
                if (isNewArray) {
                    if (!(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isArray)(clone)) {
                        // We can't "merge" an array with a non-array so overwrite the original
                        clone = [];
                    }
                }
                else if (!(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(clone)) {
                    // We can't "merge" an object with a non-object
                    clone = {};
                }
                // Never move the original objects always clone them
                newValue = objExtend(deep, clone, newValue);
            }
            // Assign the new (or previous) value (unless undefined)
            if (newValue !== undefined) {
                extended[prop] = newValue;
            }
        }
    }
    return extended;
}
var asString = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.asString;
/**
 * Checks if the feature is enabled on not. If the feature is not defined, it will return the default state if provided or undefined.
 * If the feature is defined, it will check the mode and return true if the mode is enable or false if the mode is disable.
 * @param feature - The feature name to check
 * @param cfg - The configuration object to check the feature state against
 * @param sdkDefaultState - Optional default state to return if the feature is not defined
 * @returns True if the feature is enabled, false if the feature is disabled, or undefined if the feature is not defined and no default state is provided.
 */
function isFeatureEnabled(feature, cfg, sdkDefaultState) {
    var ft = cfg && cfg.featureOptIn && cfg.featureOptIn[feature];
    if (feature && ft) {
        var mode = ft.mode;
        // NOTE: None will be considered as true
        if (mode === 3 /* FeatureOptInMode.enable */) {
            return true;
        }
        else if (mode === 2 /* FeatureOptInMode.disable */) {
            return false;
        }
    }
    // Return the default state if provided or undefined
    return sdkDefaultState;
}
function getResponseText(xhr) {
    try {
        return xhr.responseText;
    }
    catch (e) {
        // Best effort, as XHR may throw while XDR wont so just ignore
    }
    return null;
}
function formatErrorMessageXdr(xdr, message) {
    if (xdr) {
        return "XDomainRequest,Response:" + getResponseText(xdr) || 0;
    }
    return message;
}
function formatErrorMessageXhr(xhr, message) {
    if (xhr) {
        return "XMLHttpRequest,Status:" + xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_STATUS /* @min:%2estatus */] + ",Response:" + getResponseText(xhr) || 0 || 0;
    }
    return message;
}
function prependTransports(theTransports, newTransports) {
    if (newTransports) {
        if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isNumber)(newTransports)) {
            theTransports = [newTransports].concat(theTransports);
        }
        else if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isArray)(newTransports)) {
            theTransports = newTransports.concat(theTransports);
        }
    }
    return theTransports;
}
var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
var strWithCredentials = "withCredentials";
var strTimeout = "timeout";
/**
 * Create and open an XMLHttpRequest object
 * @param method - The request method
 * @param urlString - The url
 * @param withCredentials - Option flag indicating that credentials should be sent
 * @param disabled - Optional flag indicating that the XHR object should be marked as disabled and not tracked (default is false)
 * @param isSync - Optional flag indicating if the instance should be a synchronous request (defaults to false)
 * @param timeout - Optional value identifying the timeout value that should be assigned to the XHR request
 * @returns A new opened XHR request
 */
function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
    if (disabled === void 0) { disabled = false; }
    if (isSync === void 0) { isSync = false; }
    function _wrapSetXhrProp(xhr, prop, value) {
        try {
            xhr[prop] = value;
        }
        catch (e) {
            // - Wrapping as depending on the environment setting the property may fail (non-terminally)
        }
    }
    var xhr = new XMLHttpRequest();
    if (disabled) {
        // Tag the instance so it's not tracked (trackDependency)
        // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would
        // cause the request to fail and we no telemetry would be sent
        _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
    }
    if (withCredentials) {
        // Some libraries require that the withCredentials flag is set "before" open and
        // - Wrapping as IE 10 has started throwing when setting before open
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    xhr.open(method, urlString, !isSync);
    if (withCredentials) {
        // withCredentials should be set AFTER open (https://xhr.spec.whatwg.org/#the-withcredentials-attribute)
        // And older firefox instances from 11+ will throw for sync events (current versions don't) which happens during unload processing
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    // Only set the timeout for asynchronous requests as
    // "Timeout shouldn't be used for synchronous XMLHttpRequests requests used in a document environment or it will throw an InvalidAccessError exception.""
    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout
    if (!isSync && timeout) {
        _wrapSetXhrProp(xhr, strTimeout, timeout);
    }
    return xhr;
}
/**
* Converts the XHR getAllResponseHeaders to a map containing the header key and value.
* @internal
*/
// tslint:disable-next-line: align
function convertAllHeadersToMap(headersString) {
    var headers = {};
    if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isString)(headersString)) {
        var headersArray = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strTrim)(headersString)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](/[\r\n]+/);
        (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(headersArray, function (headerEntry) {
            if (headerEntry) {
                var idx = headerEntry[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INDEX_OF /* @min:%2eindexOf */](": ");
                if (idx !== -1) {
                    // The new spec has the headers returning all as lowercase -- but not all browsers do this yet
                    var header = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strTrim)(headerEntry.substring(0, idx))[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
                    var value = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strTrim)(headerEntry[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SUBSTRING /* @min:%2esubstring */](idx + 1));
                    headers[header] = value;
                }
                else {
                    headers[(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strTrim)(headerEntry)] = 1;
                }
            }
        });
    }
    return headers;
}
/**
* append the XHR headers.
* @internal
*/
function _appendHeader(theHeaders, xhr, name) {
    if (!theHeaders[name] && xhr && xhr.getResponseHeader) {
        var value = xhr.getResponseHeader(name);
        if (value) {
            theHeaders[name] = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strTrim)(value);
        }
    }
    return theHeaders;
}
var STR_KILL_DURATION_HEADER = "kill-duration";
var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
var STR_TIME_DELTA_HEADER = "time-delta-millis";
/**
* get the XHR getAllResponseHeaders.
* @internal
*/
function _getAllResponseHeaders(xhr, isOneDs) {
    var theHeaders = {};
    if (!xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_ALL_RESPONSE_HEA5 /* @min:%2egetAllResponseHeaders */]) {
        // Firefox 2-63 doesn't have getAllResponseHeaders function but it does have getResponseHeader
        // Only call these if getAllResponseHeaders doesn't exist, otherwise we can get invalid response errors
        // as collector is not currently returning the correct header to allow JS to access these headers
        if (!!isOneDs) {
            theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER);
            theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
        }
    }
    else {
        theHeaders = convertAllHeadersToMap(xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_ALL_RESPONSE_HEA5 /* @min:%2egetAllResponseHeaders */]());
    }
    return theHeaders;
}
//# sourceMappingURL=HelperFuncs.js.map

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _DYN_ADD_NOTIFICATION_LIS1: () => (/* binding */ _DYN_ADD_NOTIFICATION_LIS1),
/* harmony export */   _DYN_APPLY: () => (/* binding */ _DYN_APPLY),
/* harmony export */   _DYN_CANCEL: () => (/* binding */ _DYN_CANCEL),
/* harmony export */   _DYN_CREATE_NEW: () => (/* binding */ _DYN_CREATE_NEW),
/* harmony export */   _DYN_DATA: () => (/* binding */ _DYN_DATA),
/* harmony export */   _DYN_DIAG_LOG: () => (/* binding */ _DYN_DIAG_LOG),
/* harmony export */   _DYN_ENABLED: () => (/* binding */ _DYN_ENABLED),
/* harmony export */   _DYN_EVT_NAME: () => (/* binding */ _DYN_EVT_NAME),
/* harmony export */   _DYN_EXCEPTION: () => (/* binding */ _DYN_EXCEPTION),
/* harmony export */   _DYN_FAILURE: () => (/* binding */ _DYN_FAILURE),
/* harmony export */   _DYN_GET_ALL_RESPONSE_HEA5: () => (/* binding */ _DYN_GET_ALL_RESPONSE_HEA5),
/* harmony export */   _DYN_GET_ATTRIBUTE: () => (/* binding */ _DYN_GET_ATTRIBUTE),
/* harmony export */   _DYN_GET_CTX: () => (/* binding */ _DYN_GET_CTX),
/* harmony export */   _DYN_GET_NEXT: () => (/* binding */ _DYN_GET_NEXT),
/* harmony export */   _DYN_GET_NOTIFY_MGR: () => (/* binding */ _DYN_GET_NOTIFY_MGR),
/* harmony export */   _DYN_GET_PLUGIN: () => (/* binding */ _DYN_GET_PLUGIN),
/* harmony export */   _DYN_GET_PROCESS_TEL_CONT2: () => (/* binding */ _DYN_GET_PROCESS_TEL_CONT2),
/* harmony export */   _DYN_HEADERS: () => (/* binding */ _DYN_HEADERS),
/* harmony export */   _DYN_IDENTIFIER: () => (/* binding */ _DYN_IDENTIFIER),
/* harmony export */   _DYN_INDEX_OF: () => (/* binding */ _DYN_INDEX_OF),
/* harmony export */   _DYN_INITIALIZE: () => (/* binding */ _DYN_INITIALIZE),
/* harmony export */   _DYN_IS_CHILD_EVT: () => (/* binding */ _DYN_IS_CHILD_EVT),
/* harmony export */   _DYN_IS_INITIALIZED: () => (/* binding */ _DYN_IS_INITIALIZED),
/* harmony export */   _DYN_ITEMS_RECEIVED: () => (/* binding */ _DYN_ITEMS_RECEIVED),
/* harmony export */   _DYN_LENGTH: () => (/* binding */ _DYN_LENGTH),
/* harmony export */   _DYN_LOGGER: () => (/* binding */ _DYN_LOGGER),
/* harmony export */   _DYN_LOGGING_LEVEL_CONSOL4: () => (/* binding */ _DYN_LOGGING_LEVEL_CONSOL4),
/* harmony export */   _DYN_MESSAGE: () => (/* binding */ _DYN_MESSAGE),
/* harmony export */   _DYN_MESSAGE_ID: () => (/* binding */ _DYN_MESSAGE_ID),
/* harmony export */   _DYN_NAME: () => (/* binding */ _DYN_NAME),
/* harmony export */   _DYN_ON_COMPLETE: () => (/* binding */ _DYN_ON_COMPLETE),
/* harmony export */   _DYN_PROCESS_NEXT: () => (/* binding */ _DYN_PROCESS_NEXT),
/* harmony export */   _DYN_PUSH: () => (/* binding */ _DYN_PUSH),
/* harmony export */   _DYN_REMOVE_NOTIFICATION_0: () => (/* binding */ _DYN_REMOVE_NOTIFICATION_0),
/* harmony export */   _DYN_REPLACE: () => (/* binding */ _DYN_REPLACE),
/* harmony export */   _DYN_REQUEST_DURATION: () => (/* binding */ _DYN_REQUEST_DURATION),
/* harmony export */   _DYN_SET_CTX: () => (/* binding */ _DYN_SET_CTX),
/* harmony export */   _DYN_SET_NEXT_PLUGIN: () => (/* binding */ _DYN_SET_NEXT_PLUGIN),
/* harmony export */   _DYN_SPLICE: () => (/* binding */ _DYN_SPLICE),
/* harmony export */   _DYN_SPLIT: () => (/* binding */ _DYN_SPLIT),
/* harmony export */   _DYN_STATUS: () => (/* binding */ _DYN_STATUS),
/* harmony export */   _DYN_STOP_POLLING_INTERNA3: () => (/* binding */ _DYN_STOP_POLLING_INTERNA3),
/* harmony export */   _DYN_SUBSTRING: () => (/* binding */ _DYN_SUBSTRING),
/* harmony export */   _DYN_TEARDOWN: () => (/* binding */ _DYN_TEARDOWN),
/* harmony export */   _DYN_THROTTLE: () => (/* binding */ _DYN_THROTTLE),
/* harmony export */   _DYN_THROW_INTERNAL: () => (/* binding */ _DYN_THROW_INTERNAL),
/* harmony export */   _DYN_TIMEOUT: () => (/* binding */ _DYN_TIMEOUT),
/* harmony export */   _DYN_TOTAL_REQUEST: () => (/* binding */ _DYN_TOTAL_REQUEST),
/* harmony export */   _DYN_TO_LOWER_CASE: () => (/* binding */ _DYN_TO_LOWER_CASE),
/* harmony export */   _DYN_TRACE_FLAGS: () => (/* binding */ _DYN_TRACE_FLAGS),
/* harmony export */   _DYN_TYPE: () => (/* binding */ _DYN_TYPE),
/* harmony export */   _DYN_UNLOAD: () => (/* binding */ _DYN_UNLOAD),
/* harmony export */   _DYN_UPDATE: () => (/* binding */ _DYN_UPDATE),
/* harmony export */   _DYN_URL_STRING: () => (/* binding */ _DYN_URL_STRING),
/* harmony export */   _DYN_USER_AGENT: () => (/* binding */ _DYN_USER_AGENT),
/* harmony export */   _DYN_VALUE: () => (/* binding */ _DYN_VALUE),
/* harmony export */   _DYN_VERSION: () => (/* binding */ _DYN_VERSION),
/* harmony export */   _DYN_WARN_TO_CONSOLE: () => (/* binding */ _DYN_WARN_TO_CONSOLE),
/* harmony export */   _DYN_WATCH: () => (/* binding */ _DYN_WATCH),
/* harmony export */   _DYN__DO_TEARDOWN: () => (/* binding */ _DYN__DO_TEARDOWN)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES5 which can result in a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_TO_LOWER_CASE = "toLowerCase"; // Count: 11
var _DYN_LENGTH = "length"; // Count: 64
var _DYN_WARN_TO_CONSOLE = "warnToConsole"; // Count: 4
var _DYN_THROW_INTERNAL = "throwInternal"; // Count: 5
var _DYN_WATCH = "watch"; // Count: 7
var _DYN_APPLY = "apply"; // Count: 7
var _DYN_PUSH = "push"; // Count: 42
var _DYN_SPLICE = "splice"; // Count: 9
var _DYN_LOGGER = "logger"; // Count: 20
var _DYN_CANCEL = "cancel"; // Count: 9
var _DYN_INITIALIZE = "initialize"; // Count: 5
var _DYN_IDENTIFIER = "identifier"; // Count: 8
var _DYN_REMOVE_NOTIFICATION_0 = "removeNotificationListener"; // Count: 4
var _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener"; // Count: 4
var _DYN_IS_INITIALIZED = "isInitialized"; // Count: 11
var _DYN_GET_NOTIFY_MGR = "getNotifyMgr"; // Count: 5
var _DYN_GET_PLUGIN = "getPlugin"; // Count: 5
var _DYN_NAME = "name"; // Count: 9
var _DYN_PROCESS_NEXT = "processNext"; // Count: 15
var _DYN_GET_PROCESS_TEL_CONT2 = "getProcessTelContext"; // Count: 2
var _DYN_VALUE = "value"; // Count: 7
var _DYN_ENABLED = "enabled"; // Count: 6
var _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs"; // Count: 2
var _DYN_UNLOAD = "unload"; // Count: 7
var _DYN_ON_COMPLETE = "onComplete"; // Count: 4
var _DYN_VERSION = "version"; // Count: 4
var _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole"; // Count: 2
var _DYN_CREATE_NEW = "createNew"; // Count: 7
var _DYN_TEARDOWN = "teardown"; // Count: 9
var _DYN_MESSAGE_ID = "messageId"; // Count: 4
var _DYN_MESSAGE = "message"; // Count: 7
var _DYN_DIAG_LOG = "diagLog"; // Count: 9
var _DYN__DO_TEARDOWN = "_doTeardown"; // Count: 5
var _DYN_UPDATE = "update"; // Count: 5
var _DYN_GET_NEXT = "getNext"; // Count: 10
var _DYN_SET_NEXT_PLUGIN = "setNextPlugin"; // Count: 5
var _DYN_USER_AGENT = "userAgent"; // Count: 5
var _DYN_SPLIT = "split"; // Count: 8
var _DYN_REPLACE = "replace"; // Count: 9
var _DYN_SUBSTRING = "substring"; // Count: 4
var _DYN_INDEX_OF = "indexOf"; // Count: 5
var _DYN_TYPE = "type"; // Count: 17
var _DYN_EVT_NAME = "evtName"; // Count: 4
var _DYN_STATUS = "status"; // Count: 9
var _DYN_GET_ALL_RESPONSE_HEA5 = "getAllResponseHeaders"; // Count: 2
var _DYN_IS_CHILD_EVT = "isChildEvt"; // Count: 3
var _DYN_DATA = "data"; // Count: 11
var _DYN_GET_CTX = "getCtx"; // Count: 6
var _DYN_SET_CTX = "setCtx"; // Count: 10
var _DYN_ITEMS_RECEIVED = "itemsReceived"; // Count: 3
var _DYN_HEADERS = "headers"; // Count: 6
var _DYN_URL_STRING = "urlString"; // Count: 5
var _DYN_TIMEOUT = "timeout"; // Count: 6
var _DYN_TOTAL_REQUEST = "totalRequest"; // Count: 4
var _DYN_REQUEST_DURATION = "requestDuration"; // Count: 3
var _DYN_FAILURE = "failure"; // Count: 4
var _DYN_EXCEPTION = "exception"; // Count: 4
var _DYN_THROTTLE = "throttle"; // Count: 4
var _DYN_TRACE_FLAGS = "traceFlags"; // Count: 5
var _DYN_GET_ATTRIBUTE = "getAttribute"; // Count: 3
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_SENSITIVE_PARAMS: () => (/* binding */ DEFAULT_SENSITIVE_PARAMS),
/* harmony export */   STR_CHANNELS: () => (/* binding */ STR_CHANNELS),
/* harmony export */   STR_CORE: () => (/* binding */ STR_CORE),
/* harmony export */   STR_CREATE_PERF_MGR: () => (/* binding */ STR_CREATE_PERF_MGR),
/* harmony export */   STR_DISABLED: () => (/* binding */ STR_DISABLED),
/* harmony export */   STR_DOMAIN: () => (/* binding */ STR_DOMAIN),
/* harmony export */   STR_EMPTY: () => (/* binding */ STR_EMPTY),
/* harmony export */   STR_EVENTS_DISCARDED: () => (/* binding */ STR_EVENTS_DISCARDED),
/* harmony export */   STR_EVENTS_SEND_REQUEST: () => (/* binding */ STR_EVENTS_SEND_REQUEST),
/* harmony export */   STR_EVENTS_SENT: () => (/* binding */ STR_EVENTS_SENT),
/* harmony export */   STR_EXTENSIONS: () => (/* binding */ STR_EXTENSIONS),
/* harmony export */   STR_EXTENSION_CONFIG: () => (/* binding */ STR_EXTENSION_CONFIG),
/* harmony export */   STR_GET_PERF_MGR: () => (/* binding */ STR_GET_PERF_MGR),
/* harmony export */   STR_NOT_DYNAMIC_ERROR: () => (/* binding */ STR_NOT_DYNAMIC_ERROR),
/* harmony export */   STR_OFFLINE_DROP: () => (/* binding */ STR_OFFLINE_DROP),
/* harmony export */   STR_OFFLINE_SENT: () => (/* binding */ STR_OFFLINE_SENT),
/* harmony export */   STR_OFFLINE_STORE: () => (/* binding */ STR_OFFLINE_STORE),
/* harmony export */   STR_PATH: () => (/* binding */ STR_PATH),
/* harmony export */   STR_PERF_EVENT: () => (/* binding */ STR_PERF_EVENT),
/* harmony export */   STR_PRIORITY: () => (/* binding */ STR_PRIORITY),
/* harmony export */   STR_PROCESS_TELEMETRY: () => (/* binding */ STR_PROCESS_TELEMETRY),
/* harmony export */   STR_REDACTED: () => (/* binding */ STR_REDACTED),
/* harmony export */   UNDEFINED_VALUE: () => (/* binding */ UNDEFINED_VALUE)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// ###################################################################################################################################################
// Note: DON'T Export these const from the package as we are still targeting IE/ES5 this will export a mutable variables that someone could change ###
// ###################################################################################################################################################
var UNDEFINED_VALUE = undefined;
var STR_EMPTY = "";
var STR_CHANNELS = "channels";
var STR_CORE = "core";
var STR_CREATE_PERF_MGR = "createPerfMgr";
var STR_DISABLED = "disabled";
var STR_EXTENSION_CONFIG = "extensionConfig";
var STR_EXTENSIONS = "extensions";
var STR_PROCESS_TELEMETRY = "processTelemetry";
var STR_PRIORITY = "priority";
var STR_EVENTS_SENT = "eventsSent";
var STR_EVENTS_DISCARDED = "eventsDiscarded";
var STR_EVENTS_SEND_REQUEST = "eventsSendRequest";
var STR_PERF_EVENT = "perfEvent";
var STR_OFFLINE_STORE = "offlineEventsStored";
var STR_OFFLINE_SENT = "offlineBatchSent";
var STR_OFFLINE_DROP = "offlineBatchDrop";
var STR_GET_PERF_MGR = "getPerfMgr";
var STR_DOMAIN = "domain";
var STR_PATH = "path";
var STR_NOT_DYNAMIC_ERROR = "Not dynamic - ";
var STR_REDACTED = "REDACTED";
var DEFAULT_SENSITIVE_PARAMS = ["sig", "Signature", "AWSAccessKeyId", "X-Goog-Signature"];
//# sourceMappingURL=InternalConstants.js.map

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mwcRandom32: () => (/* binding */ mwcRandom32),
/* harmony export */   mwcRandomSeed: () => (/* binding */ mwcRandomSeed),
/* harmony export */   newId: () => (/* binding */ newId),
/* harmony export */   random32: () => (/* binding */ random32),
/* harmony export */   randomValue: () => (/* binding */ randomValue)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var UInt32Mask = 0x100000000;
var MaxUInt32 = 0xffffffff;
var SEED1 = 123456789;
var SEED2 = 987654321;
// MWC based Random generator (for IE)
var _mwcSeeded = false;
var _mwcW = SEED1;
var _mwcZ = SEED2;
// Takes any integer
function _mwcSeed(seedValue) {
    if (seedValue < 0) {
        // Make sure we end up with a positive number and not -ve one.
        seedValue >>>= 0;
    }
    _mwcW = (SEED1 + seedValue) & MaxUInt32;
    _mwcZ = (SEED2 - seedValue) & MaxUInt32;
    _mwcSeeded = true;
}
function _autoSeedMwc() {
    // Simple initialization using default Math.random() - So we inherit any entropy from the browser
    // and bitwise XOR with the current milliseconds
    try {
        var now = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)() & 0x7fffffff;
        _mwcSeed(((Math.random() * UInt32Mask) ^ now) + now);
    }
    catch (e) {
        // Don't crash if something goes wrong
    }
}
/**
 * Generate a random value between 0 and maxValue, max value should be limited to a 32-bit maximum.
 * So maxValue(16) will produce a number from 0..16 (range of 17)
 * @param maxValue - The max value for the range
 */
function randomValue(maxValue) {
    if (maxValue > 0) {
        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mathFloor)((random32() / MaxUInt32) * (maxValue + 1)) >>> 0;
    }
    return 0;
}
/**
 * generate a random 32-bit number (0x000000..0xFFFFFFFF) or (-0x80000000..0x7FFFFFFF), defaults un-unsigned.
 * @param signed - True to return a signed 32-bit number (-0x80000000..0x7FFFFFFF) otherwise an unsigned one (0x000000..0xFFFFFFFF)
 */
function random32(signed) {
    var value = 0;
    var c = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_2__.getCrypto)() || (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_2__.getMsCrypto)();
    if (c && c.getRandomValues) {
        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
        value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
    }
    if (value === 0 && (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_2__.isIE)()) {
        // For IE 6, 7, 8 (especially on XP) Math.random is not very random
        if (!_mwcSeeded) {
            // Set the seed for the Mwc algorithm
            _autoSeedMwc();
        }
        // Don't use Math.random for IE
        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
        value = mwcRandom32() & MaxUInt32;
    }
    if (value === 0) {
        // Make sure the number is converted into the specified range (-0x80000000..0x7FFFFFFF)
        value = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mathFloor)((UInt32Mask * Math.random()) | 0);
    }
    if (!signed) {
        // Make sure we end up with a positive number and not -ve one.
        value >>>= 0;
    }
    return value;
}
/**
 * Seed the MWC random number generator with the specified seed or a random value
 * @param value - optional the number to used as the seed, if undefined, null or zero a random value will be chosen
 */
function mwcRandomSeed(value) {
    if (!value) {
        _autoSeedMwc();
    }
    else {
        _mwcSeed(value);
    }
}
/**
 * Generate a random 32-bit number between (0x000000..0xFFFFFFFF) or (-0x80000000..0x7FFFFFFF), using MWC (Multiply with carry)
 * instead of Math.random() defaults to un-signed.
 * Used as a replacement random generator for IE to avoid issues with older IE instances.
 * @param signed - True to return a signed 32-bit number (-0x80000000..0x7FFFFFFF) otherwise an unsigned one (0x000000..0xFFFFFFFF)
 */
function mwcRandom32(signed) {
    _mwcZ = (36969 * (_mwcZ & 0xFFFF) + (_mwcZ >> 16)) & MaxUInt32;
    _mwcW = (18000 * (_mwcW & 0xFFFF) + (_mwcW >> 16)) & MaxUInt32;
    var value = (((_mwcZ << 16) + (_mwcW & 0xFFFF)) >>> 0) & MaxUInt32 | 0;
    if (!signed) {
        // Make sure we end up with a positive number and not -ve one.
        value >>>= 0;
    }
    return value;
}
/**
 * Generate random base64 id string.
 * The default length is 22 which is 132-bits so almost the same as a GUID but as base64 (the previous default was 5)
 * @param maxLength - Optional value to specify the length of the id to be generated, defaults to 22
 */
function newId(maxLength) {
    if (maxLength === void 0) { maxLength = 22; }
    var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    // Start with an initial random number, consuming the value in reverse byte order
    var number = random32() >>> 0; // Make sure it's a +ve number
    var chars = 0;
    var result = _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY;
    while (result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] < maxLength) {
        chars++;
        result += base64chars.charAt(number & 0x3F);
        number >>>= 6; // Zero fill with right shift
        if (chars === 5) {
            // 5 base64 characters === 30 bits so we don't have enough bits for another base64 char
            // So add on another 30 bits and make sure it's +ve
            number = (((random32() << 2) & 0xFFFFFFFF) | (number & 0x03)) >>> 0;
            chars = 0; // We need to reset the number every 5 chars (30 bits)
        }
    }
    return result;
}
//# sourceMappingURL=RandomHelper.js.map

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCustomDomEvent: () => (/* binding */ createCustomDomEvent),
/* harmony export */   dispatchEvent: () => (/* binding */ dispatchEvent),
/* harmony export */   fieldRedaction: () => (/* binding */ fieldRedaction),
/* harmony export */   findMetaTag: () => (/* binding */ findMetaTag),
/* harmony export */   findNamedServerTiming: () => (/* binding */ findNamedServerTiming),
/* harmony export */   getConsole: () => (/* binding */ getConsole),
/* harmony export */   getCrypto: () => (/* binding */ getCrypto),
/* harmony export */   getIEVersion: () => (/* binding */ getIEVersion),
/* harmony export */   getJSON: () => (/* binding */ getJSON),
/* harmony export */   getLocation: () => (/* binding */ getLocation),
/* harmony export */   getMsCrypto: () => (/* binding */ getMsCrypto),
/* harmony export */   hasJSON: () => (/* binding */ hasJSON),
/* harmony export */   isBeaconsSupported: () => (/* binding */ isBeaconsSupported),
/* harmony export */   isFetchSupported: () => (/* binding */ isFetchSupported),
/* harmony export */   isIE: () => (/* binding */ isIE),
/* harmony export */   isReactNative: () => (/* binding */ isReactNative),
/* harmony export */   isSafari: () => (/* binding */ isSafari),
/* harmony export */   isXhrSupported: () => (/* binding */ isXhrSupported),
/* harmony export */   sendCustomEvent: () => (/* binding */ sendCustomEvent),
/* harmony export */   setEnableEnvMocks: () => (/* binding */ setEnableEnvMocks),
/* harmony export */   useXDomainRequest: () => (/* binding */ useXDomainRequest)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








/**
 * This file exists to hold environment utilities that are required to check and
 * validate the current operating environment. Unless otherwise required, please
 * only use defined methods (functions) in this class so that users of these
 * functions/properties only need to include those that are used within their own modules.
 */
var strDocumentMode = "documentMode";
var strLocation = "location";
var strConsole = "console";
var strJSON = "JSON";
var strCrypto = "crypto";
var strMsCrypto = "msCrypto";
var strReactNative = "ReactNative";
var strMsie = "msie";
var strTrident = "trident/";
var strXMLHttpRequest = "XMLHttpRequest";
var _isTrident = null;
var _navUserAgentCheck = null;
var _enableMocks = false;
var _useXDomainRequest = null;
var _beaconsSupported = null;
function _hasProperty(theClass, property) {
    var supported = false;
    if (theClass) {
        try {
            supported = property in theClass;
            if (!supported) {
                var proto = theClass[_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimPrototype];
                if (proto) {
                    supported = property in proto;
                }
            }
        }
        catch (e) {
            // Do Nothing
        }
        if (!supported) {
            try {
                var tmp = new theClass();
                supported = !(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(tmp[property]);
            }
            catch (e) {
                // Do Nothing
            }
        }
    }
    return supported;
}
/**
 * Enable the lookup of test mock objects if requested
 * @param enabled - A flag to enable or disable the mock
 */
function setEnableEnvMocks(enabled) {
    _enableMocks = enabled;
}
/**
 * Returns the global location object if it is present otherwise null.
 * This helper is used to access the location object without causing an exception
 * "Uncaught ReferenceError: location is not defined"
 */
function getLocation(checkForMock) {
    if (checkForMock && _enableMocks) {
        var mockLocation = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)("__mockLocation");
        if (mockLocation) {
            return mockLocation;
        }
    }
    if (typeof location === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimObject && location) {
        return location;
    }
    return (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)(strLocation);
}
/**
 * Returns the global console object
 */
function getConsole() {
    if (typeof console !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimUndefined) {
        return console;
    }
    return (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)(strConsole);
}
/**
 * Checks if JSON object is available, this is required as we support the API running without a
 * window /document (eg. Node server, electron webworkers) and if we attempt to assign a history
 * object to a local variable or pass as an argument an "Uncaught ReferenceError: JSON is not defined"
 * exception will be thrown.
 * Defined as a function to support lazy / late binding environments.
 */
function hasJSON() {
    return Boolean((typeof JSON === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimObject && JSON) || (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)(strJSON) !== null);
}
/**
 * Returns the global JSON object if it is present otherwise null.
 * This helper is used to access the JSON object without causing an exception
 * "Uncaught ReferenceError: JSON is not defined"
 */
function getJSON() {
    if (hasJSON()) {
        return JSON || (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)(strJSON);
    }
    return null;
}
/**
 * Returns the crypto object if it is present otherwise null.
 * This helper is used to access the crypto object from the current
 * global instance which could be window or globalThis for a web worker
 */
function getCrypto() {
    return (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)(strCrypto);
}
/**
 * Returns the crypto object if it is present otherwise null.
 * This helper is used to access the crypto object from the current
 * global instance which could be window or globalThis for a web worker
 */
function getMsCrypto() {
    return (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)(strMsCrypto);
}
/**
 * Returns whether the environment is reporting that we are running in a React Native Environment
 */
function isReactNative() {
    // If running in React Native, navigator.product will be populated
    var nav = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getNavigator)();
    if (nav && nav.product) {
        return nav.product === strReactNative;
    }
    return false;
}
/**
 * Identifies whether the current environment appears to be IE
 */
function isIE() {
    var nav = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getNavigator)();
    if (nav && (nav[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_USER_AGENT /* @min:%2euserAgent */] !== _navUserAgentCheck || _isTrident === null)) {
        // Added to support test mocking of the user agent
        _navUserAgentCheck = nav[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_USER_AGENT /* @min:%2euserAgent */];
        var userAgent = (_navUserAgentCheck || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
        _isTrident = ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.strContains)(userAgent, strMsie) || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.strContains)(userAgent, strTrident));
    }
    return _isTrident;
}
/**
 * Gets IE version returning the document emulation mode if we are running on IE, or null otherwise
 */
function getIEVersion(userAgentStr) {
    if (userAgentStr === void 0) { userAgentStr = null; }
    if (!userAgentStr) {
        var navigator_1 = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getNavigator)() || {};
        userAgentStr = navigator_1 ? (navigator_1.userAgent || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY;
    }
    var ua = (userAgentStr || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
    // Also check for documentMode in case X-UA-Compatible meta tag was included in HTML.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.strContains)(ua, strMsie)) {
        var doc = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getDocument)() || {};
        return (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.mathMax)(parseInt(ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](strMsie)[1]), (doc[strDocumentMode] || 0));
    }
    else if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_3__.strContains)(ua, strTrident)) {
        var tridentVer = parseInt(ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](strTrident)[1]);
        if (tridentVer) {
            return tridentVer + 4;
        }
    }
    return null;
}
function isSafari(userAgentStr) {
    if (!userAgentStr || !(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isString)(userAgentStr)) {
        var navigator_2 = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getNavigator)() || {};
        userAgentStr = navigator_2 ? (navigator_2.userAgent || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() : _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY;
    }
    var ua = (userAgentStr || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
    return ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(ua, "safari") >= 0);
}
/**
 * Checks if HTML5 Beacons are supported in the current environment.
 * @param useCached - [Optional] used for testing to bypass the cached lookup, when `true` this will
 * cause the cached global to be reset.
 * @returns True if supported, false otherwise.
 */
function isBeaconsSupported(useCached) {
    if (_beaconsSupported === null || useCached === false) {
        _beaconsSupported = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.hasNavigator)() && Boolean((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getNavigator)().sendBeacon);
    }
    return _beaconsSupported;
}
/**
 * Checks if the Fetch API is supported in the current environment.
 * @param withKeepAlive - [Optional] If True, check if fetch is available and it supports the keepalive feature, otherwise only check if fetch is supported
 * @returns True if supported, otherwise false
 */
function isFetchSupported(withKeepAlive) {
    var isSupported = false;
    try {
        isSupported = !!(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)("fetch");
        var request = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)("Request");
        if (isSupported && withKeepAlive && request) {
            isSupported = _hasProperty(request, "keepalive");
        }
    }
    catch (e) {
        // Just Swallow any failure during availability checks
    }
    return isSupported;
}
function useXDomainRequest() {
    if (_useXDomainRequest === null) {
        _useXDomainRequest = (typeof XDomainRequest !== _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimUndefined);
        if (_useXDomainRequest && isXhrSupported()) {
            _useXDomainRequest = _useXDomainRequest && !_hasProperty((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)(strXMLHttpRequest), "withCredentials");
        }
    }
    return _useXDomainRequest;
}
/**
 * Checks if XMLHttpRequest is supported
 * @returns True if supported, otherwise false
 */
function isXhrSupported() {
    var isSupported = false;
    try {
        var xmlHttpRequest = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getInst)(strXMLHttpRequest);
        isSupported = !!xmlHttpRequest;
    }
    catch (e) {
        // Just Swallow any failure during availability checks
    }
    return isSupported;
}
function _getNamedValue(values, name) {
    if (values) {
        for (var i = 0; i < values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; i++) {
            var value = values[i];
            if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */]) {
                if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */] === name) {
                    return value;
                }
            }
        }
    }
    return {};
}
/**
 * Helper function to fetch the named meta-tag from the page.
 * @param name - The name of the meta-tag to find.
 */
function findMetaTag(name) {
    var doc = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getDocument)();
    if (doc && name) {
        // Look for a meta-tag
        return _getNamedValue(doc.querySelectorAll("meta"), name).content;
    }
    return null;
}
/**
 * Helper function to fetch the named server timing value from the page response (first navigation event).
 * @param name - The name of the server timing value to find.
 */
function findNamedServerTiming(name) {
    var value;
    var perf = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getPerformance)();
    if (perf) {
        // Try looking for a server-timing header
        var navPerf = perf.getEntriesByType("navigation") || [];
        value = _getNamedValue((navPerf[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > 0 ? navPerf[0] : {}).serverTiming, name).description;
    }
    return value;
}
// TODO: should reuse this method for analytics plugin
function dispatchEvent(target, evnt) {
    if (target && target.dispatchEvent && evnt) {
        target.dispatchEvent(evnt);
        return true;
    }
    return false;
}
function createCustomDomEvent(eventName, details) {
    var event = null;
    var detail = { detail: details || null };
    if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isFunction)(CustomEvent)) { // Use CustomEvent constructor when available
        event = new CustomEvent(eventName, detail);
    }
    else { // CustomEvent has no constructor in IE
        var doc = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getDocument)();
        if (doc && doc.createEvent) {
            event = doc.createEvent("CustomEvent");
            event.initCustomEvent(eventName, true, true, detail);
        }
    }
    return event;
}
function sendCustomEvent(evtName, cfg, customDetails) {
    var global = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.getGlobal)();
    if (global && global.CustomEvent) {
        try {
            var details = { cfg: cfg || null, customDetails: customDetails || null };
            return dispatchEvent(global, createCustomDomEvent(evtName, details));
        }
        catch (e) {
            // eslint-disable-next-line no-empty
        }
    }
    return false;
}
/**
 * Redacts user information from a URL
 * @param url - The URL string to redact
 * @returns The URL with user information redacted
 */
function redactUserInfo(url) {
    return url.replace(/^([a-zA-Z][a-zA-Z0-9+.-]*:\/\/)([^:@]{1,200}):([^@]{1,200})@(.*)$/, "$1REDACTED:REDACTED@$4");
}
/**
 * Redacts sensitive query parameters from a URL
 * @param url - The URL string to redact
 * @returns The URL with sensitive query parameters redacted
 */
function redactQueryParameters(url, config) {
    var sensitiveParams;
    var questionMarkIndex = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(url, "?");
    if (questionMarkIndex === -1) {
        return url;
    }
    if (config && config.redactQueryParams) {
        sensitiveParams = _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_SENSITIVE_PARAMS.concat(config.redactQueryParams);
    }
    else {
        sensitiveParams = _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_SENSITIVE_PARAMS;
    }
    var baseUrl = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(url, 0, questionMarkIndex + 1);
    var queryString = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(url, questionMarkIndex + 1);
    var fragment = _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY;
    var hashIndex = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(queryString, "#");
    if (hashIndex !== -1) {
        fragment = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(queryString, hashIndex);
        queryString = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(queryString, 0, hashIndex);
    }
    var hasPotentialSensitiveParam = false;
    for (var i = 0; i < sensitiveParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; i++) {
        var paramCheck = sensitiveParams[i] + "=";
        if ((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(queryString, paramCheck) !== -1) {
            hasPotentialSensitiveParam = true;
            break;
        }
    }
    if (!hasPotentialSensitiveParam) {
        return url;
    }
    var resultParts = [];
    var anyParamRedacted = false;
    if (queryString && queryString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]) {
        var pairs = queryString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */]("&");
        for (var i = 0; i < pairs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; i++) {
            var pair = pairs[i];
            if (!pair) {
                continue;
            }
            var equalsIndex = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(pair, "=");
            if (equalsIndex === -1) {
                // Parameter without value
                resultParts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](pair);
            }
            else {
                var paramName = pair[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SUBSTRING /* @min:%2esubstring */](0, equalsIndex);
                var paramValue = pair[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SUBSTRING /* @min:%2esubstring */](equalsIndex + 1);
                if (paramValue === _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY) {
                    resultParts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](pair);
                }
                else {
                    var shouldRedact = false;
                    for (var j = 0; j < sensitiveParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; j++) {
                        if (paramName === sensitiveParams[j]) {
                            shouldRedact = true;
                            anyParamRedacted = true;
                            break;
                        }
                    }
                    if (shouldRedact) {
                        resultParts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](paramName + "=" + _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_REDACTED);
                    }
                    else {
                        resultParts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](pair);
                    }
                }
            }
        }
    }
    // If no parameters were redacted, return the original URL
    if (!anyParamRedacted) {
        return url;
    }
    return baseUrl + resultParts.join("&") + fragment;
}
/**
 * Redacts sensitive information from a URL string, including credentials and specific query parameters.
 * @param input - The URL string to be redacted.
 * @param config - Configuration object that contain redactUrls setting.
 * @returns The redacted URL string or the original string if no redaction was needed or possible.
 */
function fieldRedaction(input, config) {
    if (!input || !(0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.isString)(input) || input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INDEX_OF /* @min:%2eindexOf */](" ") !== -1) {
        return input;
    }
    var isRedactionDisabled = config && config.redactUrls === false;
    if (isRedactionDisabled) {
        return input;
    }
    var hasCredentials = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(input, "@") !== -1;
    var hasQueryParams = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(input, "?") !== -1;
    // If no credentials and no query params, return original
    if (!hasCredentials && !hasQueryParams) {
        return input;
    }
    try {
        var result = input;
        if (hasCredentials) {
            result = redactUserInfo(input);
        }
        if (hasQueryParams) {
            result = redactQueryParameters(result, config);
        }
        return result;
    }
    catch (e) {
        return input;
    }
}
//# sourceMappingURL=EnvUtils.js.map

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _applyDefaultValue: () => (/* binding */ _applyDefaultValue)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




function _isConfigDefaults(value) {
    return (value && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) && (value.isVal || value.fb || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(value, "v") || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(value, "mrg") || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objHasOwn)(value, "ref") || value.set));
}
function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
    var defValue;
    var isDefaultValid = cfgDefaults.dfVal || _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isDefined;
    // There is a fallback config key so try and grab that first
    if (theConfig && cfgDefaults.fb) {
        var fallbacks = cfgDefaults.fb;
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(fallbacks)) {
            fallbacks = [fallbacks];
        }
        for (var lp = 0; lp < fallbacks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
            var fallback = fallbacks[lp];
            var fbValue = theConfig[fallback];
            if (isDefaultValid(fbValue)) {
                defValue = fbValue;
            }
            else if (dynamicHandler) {
                // Needed to ensure that the fallback value (and potentially) new field is also dynamic even if null/undefined
                fbValue = dynamicHandler.cfg[fallback];
                if (isDefaultValid(fbValue)) {
                    defValue = fbValue;
                }
                // Needed to ensure that the fallback value (and potentially) new field is also dynamic even if null/undefined
                dynamicHandler.set(dynamicHandler.cfg, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.asString)(fallback), fbValue);
            }
            if (isDefaultValid(defValue)) {
                // We have a valid default so break out of the look
                break;
            }
        }
    }
    // If the value is still not defined and we have a default value then use that
    if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {
        defValue = cfgDefaults.v;
    }
    return defValue;
}
/**
 * Recursively resolve the default value
 * @param dynamicHandler
 * @param theConfig
 * @param cfgDefaults
 * @returns
 */
function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
    var theValue = cfgDefaults;
    if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {
        theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
    }
    if (theValue) {
        if (_isConfigDefaults(theValue)) {
            theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);
        }
        var newValue_1;
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(theValue)) {
            newValue_1 = [];
            newValue_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] = theValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
        }
        else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(theValue)) {
            newValue_1 = {};
        }
        if (newValue_1) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(theValue, function (key, value) {
                if (value && _isConfigDefaults(value)) {
                    value = _resolveDefaultValue(dynamicHandler, theConfig, value);
                }
                newValue_1[key] = value;
            });
            theValue = newValue_1;
        }
    }
    return theValue;
}
/**
 * Applies the default value on the config property and makes sure that it's dynamic
 * @param theConfig
 * @param name
 * @param defaultValue
 */
function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
    // Resolve the initial config value from the provided value or use the defined default
    var isValid;
    var setFn;
    var defValue;
    var cfgDefaults = defaultValue;
    var mergeDf;
    var reference;
    var readOnly;
    var blkDynamicValue;
    if (_isConfigDefaults(cfgDefaults)) {
        // looks like a IConfigDefault
        isValid = cfgDefaults.isVal;
        setFn = cfgDefaults.set;
        readOnly = cfgDefaults.rdOnly;
        blkDynamicValue = cfgDefaults.blkVal;
        mergeDf = cfgDefaults.mrg;
        reference = cfgDefaults.ref;
        if (!reference && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(reference)) {
            reference = !!mergeDf;
        }
        defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);
    }
    else {
        defValue = defaultValue;
    }
    if (blkDynamicValue) {
        // Mark the property so that any value assigned will be blocked from conversion, we need to do this
        // before assigning or fetching the value to ensure it's not converted
        dynamicHandler.blkVal(theConfig, name);
    }
    // Set the value to the default value;
    var theValue;
    var usingDefault = true;
    var cfgValue = theConfig[name];
    // try and get and user provided values
    if (cfgValue || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(cfgValue)) {
        // Use the defined theConfig[name] value
        theValue = cfgValue;
        usingDefault = false;
        // The values are different and we have a special default value check, which is used to
        // override config values like empty strings to continue using the default
        if (isValid && theValue !== defValue && !isValid(theValue)) {
            theValue = defValue;
            usingDefault = true;
        }
        if (setFn) {
            theValue = setFn(theValue, defValue, theConfig);
            usingDefault = theValue === defValue;
        }
    }
    if (!usingDefault) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(theValue) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(defValue)) {
            // we are using the user supplied value and it's an object
            if (mergeDf && defValue && ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(defValue) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(defValue))) {
                // Resolve/apply the defaults
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(defValue, function (dfName, dfValue) {
                    // Sets the value and makes it dynamic (if it doesn't already exist)
                    _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
                });
            }
        }
    }
    else if (defValue) {
        // Just resolve the default
        theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);
    }
    else {
        theValue = defValue;
    }
    // if (theValue && usingDefault && (isPlainObject(theValue) || isArray(theValue))) {
    //     theValue = _cfgDeepCopy(theValue);
    // }
    // Needed to ensure that the (potentially) new field is dynamic even if null/undefined
    dynamicHandler.set(theConfig, name, theValue);
    if (reference) {
        dynamicHandler.ref(theConfig, name);
    }
    if (readOnly) {
        dynamicHandler.rdOnly(theConfig, name);
    }
}
//# sourceMappingURL=ConfigDefaults.js.map

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _makeDynamicObject: () => (/* binding */ _makeDynamicObject),
/* harmony export */   _setDynamicProperty: () => (/* binding */ _setDynamicProperty),
/* harmony export */   _setDynamicPropertyState: () => (/* binding */ _setDynamicPropertyState),
/* harmony export */   _throwDynamicError: () => (/* binding */ _throwDynamicError)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _DynamicSupport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var arrayMethodsToPatch = [
    "push",
    "pop",
    "shift",
    "unshift",
    "splice"
];
var _throwDynamicError = function (logger, name, desc, e) {
    logger && logger[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](3 /* eLoggingSeverity.DEBUG */, 108 /* _eInternalMessageId.DynamicConfigException */, "".concat(desc, " [").concat(name, "] failed - ") + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e));
};
function _patchArray(state, target, name) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
        // Monkey Patch the methods that might change the array
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(arrayMethodsToPatch, function (method) {
            var orgMethod = target[method];
            target[method] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var result = orgMethod[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_APPLY /* @min:%2eapply */](this, args);
                // items may be added, removed or moved so need to make some new dynamic properties
                _makeDynamicObject(state, target, name, "Patching");
                return result;
            };
        });
    }
}
function _getOwnPropGetter(target, name) {
    var propDesc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objGetOwnPropertyDescriptor)(target, name);
    return propDesc && propDesc.get;
}
function _createDynamicProperty(state, theConfig, name, value) {
    // Does not appear to be dynamic so lets make it so
    var detail = {
        n: name,
        h: [],
        trk: function (handler) {
            if (handler && handler.fn) {
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(detail.h, handler) === -1) {
                    // Add this handler to the collection that should be notified when the value changes
                    detail.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](handler);
                }
                state.trk(handler, detail);
            }
        },
        clr: function (handler) {
            var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(detail.h, handler);
            if (idx !== -1) {
                detail.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLICE /* @min:%2esplice */](idx, 1);
            }
        }
    };
    // Flag to optimize lookup response time by avoiding additional function calls
    var checkDynamic = true;
    var isObjectOrArray = false;
    function _getProperty() {
        if (checkDynamic) {
            isObjectOrArray = isObjectOrArray || (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_3__._canMakeDynamic)(_getProperty, state, value);
            // Make sure that if it's an object that we make it dynamic
            if (value && !value[_DynamicSupport__WEBPACK_IMPORTED_MODULE_3__.CFG_HANDLER_LINK] && isObjectOrArray) {
                // It doesn't look like it's already dynamic so lets make sure it's converted the object into a dynamic Config as well
                value = _makeDynamicObject(state, value, name, "Converting");
            }
            // If it needed to be converted it now has been
            checkDynamic = false;
        }
        // If there is an active handler then add it to the tracking set of handlers
        var activeHandler = state.act;
        if (activeHandler) {
            detail.trk(activeHandler);
        }
        return value;
    }
    // Tag this getter as our dynamic property and provide shortcut for notifying a change
    _getProperty[state.prop] = {
        chng: function () {
            state.add(detail);
        }
    };
    function _setProperty(newValue) {
        if (value !== newValue) {
            if (!!_getProperty[state.ro] && !state.upd) {
                // field is marked as readonly so return false
                (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_3__.throwInvalidAccess)("[" + name + "] is read-only:" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(theConfig));
            }
            if (checkDynamic) {
                isObjectOrArray = isObjectOrArray || (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_3__._canMakeDynamic)(_getProperty, state, value);
                checkDynamic = false;
            }
            // The value must be a plain object or an array to enforce the reference (in-place updates)
            var isReferenced = isObjectOrArray && _getProperty[state.rf];
            if (isObjectOrArray) {
                // We are about to replace a plain object or an array
                if (isReferenced) {
                    // Reassign the properties from the current value to the same properties from the newValue
                    // This will set properties not in the newValue to undefined
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(value, function (key) {
                        value[key] = newValue ? newValue[key] : _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED_VALUE;
                    });
                    // Now assign / re-assign value with all of the keys from newValue
                    try {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(newValue, function (key, theValue) {
                            _setDynamicProperty(state, value, key, theValue);
                        });
                        // Now drop newValue so when we assign value later it keeps the existing reference
                        newValue = value;
                    }
                    catch (e) {
                        // Unable to convert to dynamic property so just leave as non-dynamic
                        _throwDynamicError((state.hdlr || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LOGGER /* @min:%2elogger */], name, "Assigning", e);
                        // Mark as not an object or array so we don't try and do this again
                        isObjectOrArray = false;
                    }
                }
                else if (value && value[_DynamicSupport__WEBPACK_IMPORTED_MODULE_3__.CFG_HANDLER_LINK]) {
                    // As we are replacing the value, if it's already dynamic then we need to notify the listeners
                    // for every property it has already
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(value, function (key) {
                        // Check if the value is dynamic
                        var getter = _getOwnPropGetter(value, key);
                        if (getter) {
                            // And if it is tell it's listeners that the value has changed
                            var valueState = getter[state.prop];
                            valueState && valueState.chng();
                        }
                    });
                }
            }
            if (newValue !== value) {
                var newIsObjectOrArray = newValue && (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_3__._canMakeDynamic)(_getProperty, state, newValue);
                if (!isReferenced && newIsObjectOrArray) {
                    // As the newValue is an object/array lets preemptively make it dynamic
                    newValue = _makeDynamicObject(state, newValue, name, "Converting");
                }
                // Now assign the internal "value" to the newValue
                value = newValue;
                isObjectOrArray = newIsObjectOrArray;
            }
            // Cause any listeners to be scheduled for notification
            state.add(detail);
        }
    }
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefine)(theConfig, detail.n, { g: _getProperty, s: _setProperty });
}
function _setDynamicProperty(state, target, name, value) {
    if (target) {
        // To be a dynamic property it needs to have a get function
        var getter = _getOwnPropGetter(target, name);
        var isDynamic = getter && !!getter[state.prop];
        if (!isDynamic) {
            _createDynamicProperty(state, target, name, value);
        }
        else {
            // Looks like it's already dynamic just assign the new value
            target[name] = value;
        }
    }
    return target;
}
function _setDynamicPropertyState(state, target, name, flags) {
    if (target) {
        // To be a dynamic property it needs to have a get function
        var getter = _getOwnPropGetter(target, name);
        var isDynamic = getter && !!getter[state.prop];
        var inPlace = flags && flags[0 /* _eSetDynamicPropertyFlags.inPlace */];
        var rdOnly = flags && flags[1 /* _eSetDynamicPropertyFlags.readOnly */];
        var blkProp = flags && flags[2 /* _eSetDynamicPropertyFlags.blockDynamicProperty */];
        if (!isDynamic) {
            if (blkProp) {
                try {
                    // Attempt to mark the target as blocked from conversion
                    (0,_DynamicSupport__WEBPACK_IMPORTED_MODULE_3__.blockDynamicConversion)(target);
                }
                catch (e) {
                    _throwDynamicError((state.hdlr || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LOGGER /* @min:%2elogger */], name, "Blocking", e);
                }
            }
            try {
                // Make sure it's dynamic so that we can tag the property as per the state
                _setDynamicProperty(state, target, name, target[name]);
                getter = _getOwnPropGetter(target, name);
            }
            catch (e) {
                // Unable to convert to dynamic property so just leave as non-dynamic
                _throwDynamicError((state.hdlr || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LOGGER /* @min:%2elogger */], name, "State", e);
            }
        }
        // Assign the optional flags if true
        if (inPlace) {
            getter[state.rf] = inPlace;
        }
        if (rdOnly) {
            getter[state.ro] = rdOnly;
        }
        if (blkProp) {
            getter[state.blkVal] = true;
        }
    }
    return target;
}
function _makeDynamicObject(state, target, name, desc) {
    try {
        // Assign target with new value properties (converting into dynamic properties in the process)
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(target, function (key, value) {
            // Assign and/or make the property dynamic
            _setDynamicProperty(state, target, key, value);
        });
        if (!target[_DynamicSupport__WEBPACK_IMPORTED_MODULE_3__.CFG_HANDLER_LINK]) {
            // Link the config back to the dynamic config details
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objDefineProp)(target, _DynamicSupport__WEBPACK_IMPORTED_MODULE_3__.CFG_HANDLER_LINK, {
                get: function () {
                    return state.hdlr;
                }
            });
            _patchArray(state, target, name);
        }
    }
    catch (e) {
        // Unable to convert to dynamic property so just leave as non-dynamic
        _throwDynamicError((state.hdlr || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LOGGER /* @min:%2elogger */], name, desc, e);
    }
    return target;
}
//# sourceMappingURL=DynamicProperty.js.map

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CFG_HANDLER_LINK: () => (/* binding */ CFG_HANDLER_LINK),
/* harmony export */   _canMakeDynamic: () => (/* binding */ _canMakeDynamic),
/* harmony export */   _cfgDeepCopy: () => (/* binding */ _cfgDeepCopy),
/* harmony export */   blockDynamicConversion: () => (/* binding */ blockDynamicConversion),
/* harmony export */   forceDynamicConversion: () => (/* binding */ forceDynamicConversion),
/* harmony export */   getDynamicConfigHandler: () => (/* binding */ getDynamicConfigHandler),
/* harmony export */   throwInvalidAccess: () => (/* binding */ throwInvalidAccess)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




// Using Symbol.for so that if the same symbol was already created it would be returned
// To handle multiple instances using potentially different versions we are not using
// createUniqueNamespace()
var CFG_HANDLER_LINK = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.symbolFor)("[[ai_dynCfg_1]]");
/**
 * @internal
 * @ignore
 * The symbol to tag objects / arrays with if they should not be converted
 */
var BLOCK_DYNAMIC = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.symbolFor)("[[ai_blkDynCfg_1]]");
/**
 * @internal
 * @ignore
 * The symbol to tag objects to indicate that when included into the configuration that
 * they should be converted into a trackable dynamic object.
 */
var FORCE_DYNAMIC = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.symbolFor)("[[ai_frcDynCfg_1]]");
function _cfgDeepCopy(source) {
    if (source) {
        var target_1;
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(source)) {
            target_1 = [];
            target_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] = source[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
        }
        else if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(source)) {
            target_1 = {};
        }
        if (target_1) {
            // Copying index values by property name as the extensionConfig can be an array or object
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(source, function (key, value) {
                // Perform a deep copy of the object
                target_1[key] = _cfgDeepCopy(value);
            });
            return target_1;
        }
    }
    return source;
}
/**
 * @internal
 * Get the dynamic config handler if the value is already dynamic
 * @returns
 */
function getDynamicConfigHandler(value) {
    if (value) {
        var handler = value[CFG_HANDLER_LINK] || value;
        if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {
            return handler;
        }
    }
    return null;
}
/**
 * Mark the provided value so that if it's included into the configuration it will NOT have
 * its properties converted into a dynamic (reactive) object. If the object is not a plain object
 * or an array (ie. a class) this function has not affect as only Objects and Arrays are converted
 * into dynamic objects in the dynamic configuration.
 *
 * When you have tagged a value as both {@link forceDynamicConversion} and blocked force will take precedence.
 *
 * You should only need to use this function, if you are creating dynamic "classes" from objects
 * which confirm to the require interface. A common case for this is during unit testing where it's
 * easier to create mock extensions.
 *
 * If `value` is falsy (null / undefined / 0 / empty string etc) it will not be tagged and
 * if there is an exception adding the property to the value (because its frozen etc) the
 * exception will be swallowed
 *
 * @example
 * ```ts
 * // This is a valid "extension", but it is technically an object
 * // So when included in the config.extensions it WILL be cloned and then
 * // converted into a dynamic object, where all of its properties will become
 * // get/set object properties and will be tracked. While this WILL still
 * // function, when attempt to use a mocking framework on top of this the
 * // functions are now technically get accessors which return a function
 * // and this can cause some mocking frameworks to fail.
 * let mockChannel = {
 *      pause: () => { },
*      resume: () => { },
*      teardown: () => { },
*      flush: (async: any, callBack: any) => { },
*      processTelemetry: (env: any) => { },
*      setNextPlugin: (next: any) => { },
*      initialize: (config: any, core: any, extensions: any) => { },
*      identifier: "testChannel",
*      priority: 1003
* };
 * ```
 * @param value - The object that you want to block from being converted into a
 * trackable dynamic object
 * @returns The original value
 */
function blockDynamicConversion(value) {
    if (value && ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(value))) {
        try {
            value[BLOCK_DYNAMIC] = true;
        }
        catch (e) {
            // Don't throw for this case as it's an ask only
        }
    }
    return value;
}
/**
 * This is the reverse case of {@link blockDynamicConversion} in that this will tag an
 * object to indicate that it should always be converted into a dynamic trackable object
 * even when not an object or array. So all properties of this object will become
 * get / set accessor functions.
 *
 * When you have tagged a value as both {@link forceDynamicConversion} and blocked force will take precedence.
 *
 * If `value` is falsy (null / undefined / 0 / empty string etc) it will not be tagged and
 * if there is an exception adding the property to the value (because its frozen etc) the
 * exception will be swallowed.
 * @param value - The object that should be tagged and converted if included into a dynamic
 * configuration.
 * @returns The original value
 */
function forceDynamicConversion(value) {
    if (value) {
        try {
            value[FORCE_DYNAMIC] = true;
        }
        catch (e) {
            // Don't throw for this case as it's an ask only
        }
    }
    return value;
}
/**
 * @internal
 * @ignore
 * Helper function to check whether an object can or should be converted into a dynamic
 * object.
 * @param value - The object to check whether it should be converted
 * @returns `true` if the value should be converted otherwise `false`.
 */
function _canMakeDynamic(getFunc, state, value) {
    var result = false;
    // Object must exist and be truthy
    if (value && !getFunc[state.blkVal]) {
        // Tagged as always convert
        result = value[FORCE_DYNAMIC];
        // Check that it's not explicitly tagged as blocked
        if (!result && !value[BLOCK_DYNAMIC]) {
            // Only convert plain objects or arrays by default
            result = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(value);
        }
    }
    return result;
}
/**
 * Throws an invalid access exception
 * @param message - The message to include in the exception
 */
function throwInvalidAccess(message) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.throwTypeError)("InvalidAccess:" + message);
}
//# sourceMappingURL=DynamicSupport.js.map

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _createState: () => (/* binding */ _createState)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _JavaScriptSDK_AggregationError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var symPrefix = "[[ai_";
var symPostfix = "]]";
function _createState(cfgHandler) {
    var dynamicPropertySymbol = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "get" + cfgHandler.uid + symPostfix);
    var dynamicPropertyReadOnly = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "ro" + cfgHandler.uid + symPostfix);
    var dynamicPropertyReferenced = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "rf" + cfgHandler.uid + symPostfix);
    var dynamicPropertyBlockValue = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "blkVal" + cfgHandler.uid + symPostfix);
    var dynamicPropertyDetail = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.newSymbol)(symPrefix + "dtl" + cfgHandler.uid + symPostfix);
    var _waitingHandlers = null;
    var _watcherTimer = null;
    var theState;
    function _useHandler(activeHandler, callback) {
        var prevWatcher = theState.act;
        try {
            theState.act = activeHandler;
            if (activeHandler && activeHandler[dynamicPropertyDetail]) {
                // Clear out the previously tracked details for this handler, so that access are re-evaluated
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(activeHandler[dynamicPropertyDetail], function (detail) {
                    detail.clr(activeHandler);
                });
                activeHandler[dynamicPropertyDetail] = [];
            }
            callback({
                cfg: cfgHandler.cfg,
                set: cfgHandler.set.bind(cfgHandler),
                setDf: cfgHandler.setDf.bind(cfgHandler),
                ref: cfgHandler.ref.bind(cfgHandler),
                rdOnly: cfgHandler.rdOnly.bind(cfgHandler)
            });
        }
        catch (e) {
            var logger = cfgHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LOGGER /* @min:%2elogger */];
            if (logger) {
                // Don't let one individual failure break everyone
                logger[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](1 /* eLoggingSeverity.CRITICAL */, 107 /* _eInternalMessageId.ConfigWatcherException */, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e));
            }
            // Re-throw the exception so that any true "error" is reported back to the called
            throw e;
        }
        finally {
            theState.act = prevWatcher || null;
        }
    }
    function _notifyWatchers() {
        if (_waitingHandlers) {
            var notifyHandlers = _waitingHandlers;
            _waitingHandlers = null;
            // Stop any timer as we are running them now anyway
            _watcherTimer && _watcherTimer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_CANCEL /* @min:%2ecancel */]();
            _watcherTimer = null;
            var watcherFailures_1 = [];
            // Now run the handlers
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(notifyHandlers, function (handler) {
                if (handler) {
                    if (handler[dynamicPropertyDetail]) {
                        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(handler[dynamicPropertyDetail], function (detail) {
                            // Clear out this handler from  previously tracked details, so that access are re-evaluated
                            detail.clr(handler);
                        });
                        handler[dynamicPropertyDetail] = null;
                    }
                    // The handler may have self removed as part of another handler so re-check
                    if (handler.fn) {
                        try {
                            _useHandler(handler, handler.fn);
                        }
                        catch (e) {
                            // Don't let a single failing watcher cause other watches to fail
                            watcherFailures_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](e);
                        }
                    }
                }
            });
            // During notification we may have had additional updates -- so notify those updates as well
            if (_waitingHandlers) {
                try {
                    _notifyWatchers();
                }
                catch (e) {
                    watcherFailures_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](e);
                }
            }
            if (watcherFailures_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > 0) {
                (0,_JavaScriptSDK_AggregationError__WEBPACK_IMPORTED_MODULE_1__.throwAggregationError)("Watcher error(s): ", watcherFailures_1);
            }
        }
    }
    function _addWatcher(detail) {
        if (detail && detail.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > 0) {
            if (!_waitingHandlers) {
                _waitingHandlers = [];
            }
            if (!_watcherTimer) {
                _watcherTimer = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeout)(function () {
                    _watcherTimer = null;
                    _notifyWatchers();
                }, 0);
            }
            // Add all of the handlers for this detail (if not already present) - using normal for-loop for performance
            for (var idx = 0; idx < detail.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; idx++) {
                var handler = detail.h[idx];
                // Add this handler to the collection of handlers to re-execute
                if (handler && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_waitingHandlers, handler) === -1) {
                    _waitingHandlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](handler);
                }
            }
        }
    }
    function _trackHandler(handler, detail) {
        if (handler) {
            var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(details, detail) === -1) {
                // If this detail is not already listed as tracked then add it so that we re-evaluate it's usage
                details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](detail);
            }
        }
    }
    theState = {
        prop: dynamicPropertySymbol,
        ro: dynamicPropertyReadOnly,
        rf: dynamicPropertyReferenced,
        blkVal: dynamicPropertyBlockValue,
        hdlr: cfgHandler,
        add: _addWatcher,
        notify: _notifyWatchers,
        use: _useHandler,
        trk: _trackHandler
    };
    return theState;
}
//# sourceMappingURL=DynamicState.js.map

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   throwAggregationError: () => (/* binding */ throwAggregationError)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var aggregationErrorType;
/**
 * Throws an Aggregation Error which includes all of the errors that led to this error occurring
 * @param message - The message describing the aggregation error (the sourceError details are added to this)
 * @param sourceErrors - An array of the errors that caused this situation
 */
function throwAggregationError(message, sourceErrors) {
    if (!aggregationErrorType) {
        aggregationErrorType = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createCustomError)("AggregationError", function (self, args) {
            if (args[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 1) {
                // Save the provided errors
                self.errors = args[1];
            }
        });
    }
    var theMessage = message || "One or more errors occurred.";
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(sourceErrors, function (srcError, idx) {
        theMessage += "\n".concat(idx, " > ").concat((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(srcError));
    });
    throw new aggregationErrorType(theMessage, sourceErrors || []);
}
//# sourceMappingURL=AggregationError.js.map

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActiveStatus: () => (/* binding */ ActiveStatus)
/* harmony export */ });
/* harmony import */ var _EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */

var ActiveStatus = ( /* @__PURE__ */(0,_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    NONE: 0 /* eActiveStatus.NONE */,
    PENDING: 3 /* eActiveStatus.PENDING */,
    INACTIVE: 1 /* eActiveStatus.INACTIVE */,
    ACTIVE: 2 /* eActiveStatus.ACTIVE */
}));
//# sourceMappingURL=InitActiveStatusEnum.js.map

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createEnumStyle: () => (/* binding */ createEnumStyle),
/* harmony export */   createValueMap: () => (/* binding */ createValueMap)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



/**
 * Create an enum style object which has both the key \=\> value and value \=\> key mappings
 * @param values - The values to populate on the new object
 * @returns
 */
var createEnumStyle = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createEnum;
/**
 * Create a 2 index map that maps an enum's key and value to the defined map value, X["key"] \=\> mapValue and X[0] \=\> mapValue.
 * Generic values
 * - E = the const enum type (typeof eRequestHeaders);
 * - V = Identifies the valid values for the keys, this should include both the enum numeric and string key of the type. The
 * resulting "Value" of each entry identifies the valid values withing the assignments.
 * @param values - The values to populate on the new object
 * @returns
 */
var createValueMap = _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.createTypeMap;
//# sourceMappingURL=EnumHelperFuncs.js.map

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   doUnloadAll: () => (/* binding */ doUnloadAll),
/* harmony export */   runTargetUnload: () => (/* binding */ runTargetUnload)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





/**
 * Run the unload function of the target object if it exists
 * @param target - The target object that contains the unload function
 * @param isAsync - The caller identifies whether it is expecting the operation to complete synchronously or asynchronously. Even
 * if the caller is not waiting the operation may still be performed asynchronously depending on the component and the reverse is
 * also true.
 * @returns The result of the target function
 */
function runTargetUnload(target, isAsync) {
    if (target && target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_UNLOAD /* @min:%2eunload */]) {
        return target[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_UNLOAD /* @min:%2eunload */](isAsync);
    }
}
/**
 * Call the unload function on all targets handling any returned [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)
 * / Promise before calling the next targets unload
 * @param targets - An array of the targets to unload
 * @param isAsync - The caller identifies whether it is expecting the operations to complete synchronously or asynchronously.  Even
 * if the caller is not waiting the operation may still be performed asynchronously depending on the component and the reverse is
 * also true.
 * @param done - Optional callback function to call once all of the unload functions have been called.
 */
function doUnloadAll(targets, isAsync, done) {
    var result;
    if (!done) {
        result = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_0__.createPromise)(function (resolved) {
            done = resolved;
        });
    }
    if (targets && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.getLength)(targets) > 0) {
        (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_0__.doAwaitResponse)(runTargetUnload(targets[0], isAsync), function () {
            doUnloadAll((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.arrSlice)(targets, 1), isAsync, done);
        });
    }
    else {
        done();
    }
    return result;
}
//# sourceMappingURL=AsyncUtils.js.map

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChannelControllerPriority: () => (/* binding */ ChannelControllerPriority),
/* harmony export */   DisabledPropertyName: () => (/* binding */ DisabledPropertyName)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


var ChannelControllerPriority = 500;
var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
// export const SampleRate = "sampleRate";
// export const ProcessLegacy = "ProcessLegacy";
// export const HttpMethod = "http.method";
// export const DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
// export const DEFAULT_BREEZE_PATH = "/v2/track";
// export const strNotSpecified = "not_specified";
// export const strIkey = "iKey";
//# sourceMappingURL=Constants.js.map

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   areCookiesSupported: () => (/* binding */ areCookiesSupported),
/* harmony export */   createCookieMgr: () => (/* binding */ createCookieMgr),
/* harmony export */   safeGetCookieMgr: () => (/* binding */ safeGetCookieMgr),
/* harmony export */   uaDisallowsSameSiteNone: () => (/* binding */ uaDisallowsSameSiteNone)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _Config_ConfigDefaultHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(24);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
var _a, _b;








var strToGMTString = "toGMTString";
var strToUTCString = "toUTCString";
var strCookie = "cookie";
var strExpires = "expires";
var strIsCookieUseDisabled = "isCookieUseDisabled";
var strDisableCookiesUsage = "disableCookiesUsage";
var strConfigCookieMgr = "_ckMgr";
var _supportsCookies = null;
var _allowUaSameSite = null;
var _parsedCookieValue = null;
var _doc;
var _cookieCache = {};
var _globalCookieConfig = {};
// // `isCookieUseDisabled` is deprecated, so explicitly casting as a key of IConfiguration to avoid typing error
// // when both isCookieUseDisabled and disableCookiesUsage are used disableCookiesUsage will take precedent, which is
// // why its listed first
/**
 * Set the supported dynamic config values as undefined (or an empty object) so that
 * any listeners will be informed of any changes.
 * Explicitly NOT including the deprecated `isCookieUseDisabled` as we don't want to support
 * the v1 deprecated field as dynamic for updates
 */
var rootDefaultConfig = (_a = {
        cookieCfg: (0,_Config_ConfigDefaultHelpers__WEBPACK_IMPORTED_MODULE_1__.cfgDfMerge)((_b = {},
            _b[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_DOMAIN] = { fb: "cookieDomain", dfVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.isNotNullOrUndefined },
            _b.path = { fb: "cookiePath", dfVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.isNotNullOrUndefined },
            _b.enabled = _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED_VALUE,
            _b.ignoreCookies = _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED_VALUE,
            _b.blockedCookies = _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED_VALUE,
            _b.disableCookieDefer = false,
            _b)),
        cookieDomain: _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED_VALUE,
        cookiePath: _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED_VALUE
    },
    _a[strDisableCookiesUsage] = _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.UNDEFINED_VALUE,
    _a);
function _getDoc() {
    !_doc && (_doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getLazy)(function () { return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)(); }));
}
/**
 * @ignore
 * DO NOT USE or export from the module, this is exposed as public to support backward compatibility of previous static utility methods only.
 * If you want to manager cookies either use the ICookieMgr available from the core instance via getCookieMgr() or create
 * your own instance of the CookieMgr and use that.
 * Using this directly for enabling / disabling cookie handling will not only affect your usage but EVERY user of cookies.
 * Example, if you are using a shared component that is also using Application Insights you will affect their cookie handling.
 * @param logger - The DiagnosticLogger to use for reporting errors.
 */
function _gblCookieMgr(config, logger) {
    // Stash the global instance against the BaseCookieMgr class
    var inst = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
    if (!inst) {
        // Note: not using the getSetValue() helper as that would require always creating a temporary cookieMgr
        // that ultimately is never used
        inst = createCookieMgr[strConfigCookieMgr] = createCookieMgr(config, logger);
        _globalCookieConfig[strConfigCookieMgr] = inst;
    }
    return inst;
}
function _isMgrEnabled(cookieMgr) {
    if (cookieMgr) {
        return cookieMgr.isEnabled();
    }
    return true;
}
function _isIgnoredCookie(cookieMgrCfg, name) {
    if (name && cookieMgrCfg && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(cookieMgrCfg.ignoreCookies)) {
        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(cookieMgrCfg.ignoreCookies, name) !== -1;
    }
    return false;
}
function _isBlockedCookie(cookieMgrCfg, name) {
    if (name && cookieMgrCfg && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(cookieMgrCfg.blockedCookies)) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(cookieMgrCfg.blockedCookies, name) !== -1) {
            return true;
        }
    }
    return _isIgnoredCookie(cookieMgrCfg, name);
}
function _isCfgEnabled(rootConfig, cookieMgrConfig) {
    var isCfgEnabled = cookieMgrConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLED /* @min:%2eenabled */];
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(isCfgEnabled)) {
        // Set the enabled from the provided setting or the legacy root values
        var cookieEnabled = void 0;
        // This field is deprecated and dynamic updates will not be fully supported
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(rootConfig[strIsCookieUseDisabled])) {
            cookieEnabled = !rootConfig[strIsCookieUseDisabled];
        }
        // If this value is defined it takes precedent over the above
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(rootConfig[strDisableCookiesUsage])) {
            cookieEnabled = !rootConfig[strDisableCookiesUsage];
        }
        // Not setting the cookieMgrConfig.enabled as that will update (set) the global dynamic config
        // So future "updates" then may not be as expected
        isCfgEnabled = cookieEnabled;
    }
    return isCfgEnabled;
}
/**
 * Helper to return the ICookieMgr from the core (if not null/undefined) or a default implementation
 * associated with the configuration or a legacy default.
 * @param core - The AppInsightsCore instance to get the cookie manager from
 * @param config - The config to use if the core is not available
 * @returns
 */
function safeGetCookieMgr(core, config) {
    var cookieMgr;
    if (core) {
        // Always returns an instance
        cookieMgr = core.getCookieMgr();
    }
    else if (config) {
        var cookieCfg = config.cookieCfg;
        if (cookieCfg && cookieCfg[strConfigCookieMgr]) {
            cookieMgr = cookieCfg[strConfigCookieMgr];
        }
        else {
            cookieMgr = createCookieMgr(config);
        }
    }
    if (!cookieMgr) {
        // Get or initialize the default global (legacy) cookie manager if we couldn't find one
        cookieMgr = _gblCookieMgr(config, (core || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */]);
    }
    return cookieMgr;
}
function createCookieMgr(rootConfig, logger) {
    var cookieMgrConfig;
    var _path;
    var _domain;
    var unloadHandler;
    // Explicitly checking against false, so that setting to undefined will === true
    var _enabled;
    var _getCookieFn;
    var _setCookieFn;
    var _delCookieFn;
    // Buffer for storing cookie operations when cookies are disabled
    // null = deferral disabled, array = deferral enabled with pending operations
    var _pendingCookies = [];
    // Helper function to format deletion cookie value
    function _formatDeletionValue(path) {
        var _a;
        var values = (_a = {},
            _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_PATH] = path ? path : "/",
            _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT",
            _a);
        if (!(0,_EnvUtils__WEBPACK_IMPORTED_MODULE_5__.isIE)()) {
            // Set max age to expire now
            values["max-age"] = "0";
        }
        return _formatCookieValue(_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY, values);
    }
    // Helper function to format a cookie value with all attributes
    function _formatSetCookieValue(value, maxAgeSec, domain, path) {
        var values = {};
        var theValue = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(value || _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY);
        var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strIndexOf)(theValue, ";");
        if (idx !== -1) {
            theValue = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strLeft)(value, idx));
            values = _extractParts((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strSubstring)(value, idx + 1));
        }
        // Only update domain if not already present (isUndefined) and the value is truthy (not null, undefined or empty string)
        (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.setValue)(values, _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_DOMAIN, domain || _domain, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isTruthy, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined);
        if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(maxAgeSec)) {
            var _isIE = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_5__.isIE)();
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(values[strExpires])) {
                var nowMs = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
                // Only add expires if not already present
                var expireMs = nowMs + (maxAgeSec * 1000);
                // Sanity check, if zero or -ve then ignore
                if (expireMs > 0) {
                    var expiry = new Date();
                    expiry.setTime(expireMs);
                    (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.setValue)(values, strExpires, _formatDate(expiry, !_isIE ? strToUTCString : strToGMTString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isTruthy);
                }
            }
            if (!_isIE) {
                // Only replace if not already present
                (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.setValue)(values, "max-age", _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY + maxAgeSec, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined);
            }
        }
        var location = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_5__.getLocation)();
        if (location && location.protocol === "https:") {
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.setValue)(values, "secure", null, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined);
            // Only set same site if not also secure
            if (_allowUaSameSite === null) {
                _allowUaSameSite = !uaDisallowsSameSiteNone(((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getNavigator)() || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_USER_AGENT /* @min:%2euserAgent */]);
            }
            if (_allowUaSameSite) {
                (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.setValue)(values, "SameSite", "None", null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined);
            }
        }
        (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.setValue)(values, _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_PATH, path || _path, null, _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined);
        return _formatCookieValue(theValue, values);
    }
    // Helper function to remove any existing pending operations for a cookie name
    function _removePendingCookie(name) {
        if (_pendingCookies) {
            // Remove all existing entries for this cookie name (iterate backwards to handle multiple entries safely)
            for (var i = _pendingCookies[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] - 1; i >= 0; i--) {
                if (_pendingCookies[i].n === name) {
                    _pendingCookies[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SPLICE /* @min:%2esplice */](i, 1);
                }
            }
        }
    }
    // Helper function to flush pending cookies when cookies become enabled
    function _flushPendingCookies() {
        if (areCookiesSupported(logger) && _pendingCookies) {
            // Process all pending cookie operations in order
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_pendingCookies, function (pendingData) {
                if (!_isBlockedCookie(cookieMgrConfig, pendingData.n)) {
                    if (pendingData.o === 0 /* ePendingOp.Set */) {
                        // Apply the cached cookie value directly
                        _setCookieFn(pendingData.n, pendingData.v);
                    }
                    else if (pendingData.o === 1 /* ePendingOp.Purge */) {
                        // Apply the cached deletion
                        _delCookieFn(pendingData.n, pendingData.v);
                    }
                }
            });
            // Clear the cache after flushing
            _pendingCookies = [];
        }
    }
    // Make sure the root config is dynamic as it may be the global config
    rootConfig = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.createDynamicConfig)(rootConfig || _globalCookieConfig, null, logger).cfg;
    // Will get recalled if the referenced configuration is changed
    unloadHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.onConfigChange)(rootConfig, function (details) {
        // Make sure the root config has all of the the defaults to the root config to ensure they are dynamic
        details.setDf(details.cfg, rootDefaultConfig);
        // Create and apply the defaults to the cookieCfg element
        cookieMgrConfig = details.ref(details.cfg, "cookieCfg"); // details.setDf(details.cfg.cookieCfg, defaultConfig);
        _path = cookieMgrConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_PATH /* @min:%2epath */] || "/";
        _domain = cookieMgrConfig[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_DOMAIN /* @min:%2edomain */];
        // Handle deferral state changes based on disableCookieDefer setting
        if (cookieMgrConfig.disableCookieDefer) {
            // When deferral is disabled, set to null to disable any deferral behavior
            // All pending operations are dropped
            _pendingCookies = null;
        }
        else if (_pendingCookies === null) {
            // When deferral is enabled and was previously disabled, initialize empty buffer
            _pendingCookies = [];
        }
        // Check if enabled state is changing
        var wasEnabled = _enabled;
        // Explicitly checking against false, so that setting to undefined will === true
        _enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false;
        _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue;
        _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
        _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
        // If cookies were just enabled via config change and we have pending cookies, flush them
        if (!wasEnabled && _enabled && _pendingCookies) {
            _flushPendingCookies();
        }
    }, logger);
    var cookieMgr = {
        isEnabled: function () {
            var enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== false && _enabled && areCookiesSupported(logger);
            // Using an indirect lookup for any global cookie manager to support tree shaking for SDK's
            // that don't use the "applicationinsights-core" version of the default cookie function
            var gblManager = _globalCookieConfig[strConfigCookieMgr];
            if (enabled && gblManager && cookieMgr !== gblManager) {
                // Make sure the GlobalCookie Manager instance (if not this instance) is also enabled.
                // As the global (deprecated) functions may have been called (for backward compatibility)
                enabled = _isMgrEnabled(gblManager);
            }
            return enabled;
        },
        setEnabled: function (value) {
            // Change the default config and allow the asynchronous dynamic config logic
            // to process all of the changes at once (like handling change to the enabled and
            // disabling caching at the same time)
            cookieMgrConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ENABLED /* @min:%2eenabled */] = value;
            // If this value is defined someone else might be listening to it so also update it,
            // this also handles the edge case if the default above is not dynamic
            if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(rootConfig[strDisableCookiesUsage])) {
                rootConfig[strDisableCookiesUsage] = !value;
            }
        },
        set: function (name, value, maxAgeSec, domain, path) {
            var result = false;
            var isBlocked = _isBlockedCookie(cookieMgrConfig, name);
            if (!isBlocked) {
                var cookieValue = _formatSetCookieValue(value, maxAgeSec, domain, path);
                if (_isMgrEnabled(cookieMgr)) {
                    _setCookieFn(name, cookieValue);
                    result = true;
                }
                else if (_pendingCookies) {
                    // Defer the fully formatted cookie value if cookies are disabled and deferral is enabled
                    // Remove any previous operation for this cookie name (latest operation wins)
                    _removePendingCookie(name);
                    // Append new operation to the array
                    _pendingCookies[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */]({
                        n: name,
                        o: 0 /* ePendingOp.Set */,
                        v: cookieValue
                    });
                    result = true; // Return true to indicate the operation was "successful" (deferred)
                }
            }
            return result;
        },
        get: function (name) {
            var value = _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY;
            var isIgnored = _isIgnoredCookie(cookieMgrConfig, name);
            if (!isIgnored) {
                if (_isMgrEnabled(cookieMgr)) {
                    value = _getCookieFn(name);
                }
                else if (_pendingCookies) {
                    // Search for the most recent operation for this cookie (search backwards through array)
                    for (var i = _pendingCookies[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] - 1; i >= 0; i--) {
                        var pendingData = _pendingCookies[i];
                        if (pendingData.n === name) {
                            // Found the most recent operation for this cookie name
                            if (pendingData.o === 0 /* ePendingOp.Set */) {
                                // Return deferred value if it was a set operation
                                // Extract the value part from the formatted cookie string (before first semicolon)
                                var cookieValue = pendingData.v;
                                var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strIndexOf)(cookieValue, ";");
                                value = idx !== -1 ? (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strLeft)(cookieValue, idx)) : (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(cookieValue);
                            }
                            // If it was a Purge operation, value remains empty (STR_EMPTY)
                            break;
                        }
                    }
                }
            }
            return value;
        },
        del: function (name, path) {
            var result = false;
            if (_isMgrEnabled(cookieMgr)) {
                // Only remove the cookie if the manager and cookie support has not been disabled
                result = cookieMgr.purge(name, path);
            }
            else if (_pendingCookies) {
                // Defer the deletion operation when cookies are disabled and deferral is enabled
                // Remove any previous operation for this cookie name (latest operation wins)
                _removePendingCookie(name);
                // Append new deletion operation to the array
                _pendingCookies[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */]({
                    n: name,
                    o: 1 /* ePendingOp.Purge */,
                    v: _formatDeletionValue(path)
                });
                result = true;
            }
            return result;
        },
        purge: function (name, path) {
            var result = false;
            if (areCookiesSupported(logger)) {
                // Setting the expiration date in the past immediately removes the cookie
                _delCookieFn(name, _formatDeletionValue(path));
                result = true;
            }
            return result;
        },
        unload: function (isAsync) {
            unloadHandler && unloadHandler.rm();
            unloadHandler = null;
            // Clear any pending cookies on unload
            _pendingCookies = null;
        }
    };
    // Associated this cookie manager with the config
    cookieMgr[strConfigCookieMgr] = cookieMgr;
    return cookieMgr;
}
/*
* Helper method to tell if document.cookie object is supported by the runtime
*/
function areCookiesSupported(logger) {
    if (_supportsCookies === null) {
        _supportsCookies = false;
        !_doc && _getDoc();
        try {
            var doc = _doc.v || {};
            _supportsCookies = doc[strCookie] !== undefined;
        }
        catch (e) {
            (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 68 /* _eInternalMessageId.CannotAccessCookie */, "Cannot access document.cookie - " + (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
        }
    }
    return _supportsCookies;
}
function _extractParts(theValue) {
    var values = {};
    if (theValue && theValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
        var parts = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(theValue)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SPLIT /* @min:%2esplit */](";");
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(parts, function (thePart) {
            thePart = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(thePart || _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY);
            if (thePart) {
                var idx = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strIndexOf)(thePart, "=");
                if (idx === -1) {
                    values[thePart] = null;
                }
                else {
                    values[(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strLeft)(thePart, idx))] = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strSubstring)(thePart, idx + 1));
                }
            }
        });
    }
    return values;
}
function _formatDate(theDate, func) {
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(theDate[func])) {
        return theDate[func]();
    }
    return null;
}
function _formatCookieValue(value, values) {
    var cookieValue = value || _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY;
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(values, function (name, theValue) {
        cookieValue += "; " + name + (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(theValue) ? "=" + theValue : _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY);
    });
    return cookieValue;
}
function _getCookieValue(name) {
    var cookieValue = _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY;
    !_doc && _getDoc();
    if (_doc.v) {
        var theCookie = _doc.v[strCookie] || _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY;
        if (_parsedCookieValue !== theCookie) {
            _cookieCache = _extractParts(theCookie);
            _parsedCookieValue = theCookie;
        }
        cookieValue = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(_cookieCache[name] || _InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_EMPTY);
    }
    return cookieValue;
}
function _setCookieValue(name, cookieValue) {
    !_doc && _getDoc();
    if (_doc.v) {
        _doc.v[strCookie] = name + "=" + cookieValue;
    }
}
function uaDisallowsSameSiteNone(userAgent) {
    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(userAgent)) {
        return false;
    }
    // Cover all iOS based browsers here. This includes:
    // - Safari on iOS 12 for iPhone, iPod Touch, iPad
    // - WkWebview on iOS 12 for iPhone, iPod Touch, iPad
    // - Chrome on iOS 12 for iPhone, iPod Touch, iPad
    // All of which are broken by SameSite=None, because they use the iOS networking stack
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "CPU iPhone OS 12") || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "iPad; CPU OS 12")) {
        return true;
    }
    // Cover Mac OS X based browsers that use the Mac OS networking stack. This includes:
    // - Safari on Mac OS X
    // This does not include:
    // - Internal browser on Mac OS X
    // - Chrome on Mac OS X
    // - Chromium on Mac OS X
    // Because they do not use the Mac OS networking stack.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "Macintosh; Intel Mac OS X 10_14") && (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "Version/") && (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "Safari")) {
        return true;
    }
    // Cover Mac OS X internal browsers that use the Mac OS networking stack. This includes:
    // - Internal browser on Mac OS X
    // This does not include:
    // - Safari on Mac OS X
    // - Chrome on Mac OS X
    // - Chromium on Mac OS X
    // Because they do not use the Mac OS networking stack.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "Macintosh; Intel Mac OS X 10_14") && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strEndsWith)(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) {
        return true;
    }
    // Cover Chrome 50-69, because some versions are broken by SameSite=None, and none in this range require it.
    // Note: this covers some pre-Chromium Edge versions, but pre-Chromim Edge does not require SameSite=None, so this is fine.
    // Note: this regex applies to Windows, Mac OS X, and Linux, deliberately.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "Chrome/5") || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "Chrome/6")) {
        return true;
    }
    // Unreal Engine runs Chromium 59, but does not advertise as Chrome until 4.23. Treat versions of Unreal
    // that don't specify their Chrome version as lacking support for SameSite=None.
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "UnrealEngine") && !(0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "Chrome")) {
        return true;
    }
    // UCBrowser < 12.13.2 ignores Set-Cookie headers with SameSite=None
    // NB: this rule isn't complete - you need regex to make a complete rule.
    // See: https://www.chromium.org/updates/same-site/incompatible-clients
    if ((0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "UCBrowser/12") || (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.strContains)(userAgent, "UCBrowser/11")) {
        return true;
    }
    return false;
}
//# sourceMappingURL=CookieMgr.js.map

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cfgDfBlockPropValue: () => (/* binding */ cfgDfBlockPropValue),
/* harmony export */   cfgDfBoolean: () => (/* binding */ cfgDfBoolean),
/* harmony export */   cfgDfFunc: () => (/* binding */ cfgDfFunc),
/* harmony export */   cfgDfMerge: () => (/* binding */ cfgDfMerge),
/* harmony export */   cfgDfSet: () => (/* binding */ cfgDfSet),
/* harmony export */   cfgDfString: () => (/* binding */ cfgDfString),
/* harmony export */   cfgDfValidate: () => (/* binding */ cfgDfValidate)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





/**
 * @internal
 * @ignore
 * @param str
 * @param defaultValue
 * @returns
 */
function _stringToBoolOrDefault(theValue, defaultValue, theConfig) {
    if (!theValue && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(theValue)) {
        return defaultValue;
    }
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(theValue)) {
        return theValue;
    }
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.asString)(theValue)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === "true";
}
/**
 * Helper which returns an IConfigDefaultCheck instance with the field defined as an object
 * that should be merged
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfMerge(defaultValue) {
    return {
        mrg: true,
        v: defaultValue
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance with the provided field set function
 * @param setter - The IConfigCheckFn function to validate the user provided value
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfSet(setter, defaultValue) {
    return {
        set: setter,
        v: defaultValue
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance with the provided field validator
 * @param validator - The IConfigCheckFn function to validate the user provided value
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @param fallBackName - The fallback configuration name if the current value is not available
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfValidate(validator, defaultValue, fallBackName) {
    return {
        fb: fallBackName,
        isVal: validator,
        v: defaultValue
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance that will validate and convert the user
 * provided value to a boolean from a string or boolean value
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @param fallBackName - The fallback configuration name if the current value is not available
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfBoolean(defaultValue, fallBackName) {
    return {
        fb: fallBackName,
        set: _stringToBoolOrDefault,
        v: !!defaultValue
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance that will validate that the user
 * provided value is a function.
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfFunc(defaultValue) {
    return {
        isVal: _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction,
        v: defaultValue || null
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance that will validate that the user
 * provided value is a function.
 * @param defaultValue - The default string value to apply it not provided or it's not valid, defaults to an empty string
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfString(defaultValue) {
    return {
        isVal: _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString,
        v: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.asString)(defaultValue || _JavaScriptSDK_InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY)
    };
}
/**
 * Helper which returns an IConfigDefaultCheck instance identifying that value associated with this property
 * should not have it's properties converted into a dynamic config properties.
 * @param defaultValue - The default value to apply it not provided or it's not valid
 * @returns a new IConfigDefaultCheck structure
 */
function cfgDfBlockPropValue(defaultValue) {
    return {
        blkVal: true,
        v: defaultValue
    };
}
//# sourceMappingURL=ConfigDefaultHelpers.js.map

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DiagnosticLogger: () => (/* binding */ DiagnosticLogger),
/* harmony export */   _InternalLogMessage: () => (/* binding */ _InternalLogMessage),
/* harmony export */   _logInternalMessage: () => (/* binding */ _logInternalMessage),
/* harmony export */   _throwInternal: () => (/* binding */ _throwInternal),
/* harmony export */   _warnToConsole: () => (/* binding */ _warnToConsole),
/* harmony export */   safeGetLogger: () => (/* binding */ safeGetLogger)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(41);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var _a;







var STR_WARN_TO_CONSOLE = "warnToConsole";
/**
 * For user non actionable traces use AI Internal prefix.
 */
var AiNonUserActionablePrefix = "AI (Internal): ";
/**
 * Prefix of the traces in portal.
 */
var AiUserActionablePrefix = "AI: ";
/**
 *  Session storage key for the prefix for the key indicating message type already logged
 */
var AIInternalMessagePrefix = "AITR_";
var defaultValues = {
    loggingLevelConsole: 0,
    loggingLevelTelemetry: 1,
    maxMessageLimit: 25,
    enableDebug: false
};
var _logFuncs = (_a = {},
    _a[0 /* eLoggingSeverity.DISABLED */] = null,
    _a[1 /* eLoggingSeverity.CRITICAL */] = "errorToConsole",
    _a[2 /* eLoggingSeverity.WARNING */] = STR_WARN_TO_CONSOLE,
    _a[3 /* eLoggingSeverity.DEBUG */] = "debugToConsole",
    _a);
function _sanitizeDiagnosticText(text) {
    if (text) {
        return "\"" + text[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_REPLACE /* @min:%2ereplace */](/\"/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EMPTY) + "\"";
    }
    return _InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EMPTY;
}
function _logToConsole(func, message) {
    var theConsole = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_5__.getConsole)();
    if (!!theConsole) {
        var logFunc = "log";
        if (theConsole[func]) {
            logFunc = func;
        }
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isFunction)(theConsole[logFunc])) {
            theConsole[logFunc](message);
        }
    }
}
var _InternalLogMessage = /** @class */ (function () {
    function _InternalLogMessage(msgId, msg, isUserAct, properties) {
        if (isUserAct === void 0) { isUserAct = false; }
        var _self = this;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE_ID /* @min:%2emessageId */] = msgId;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */] =
            (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +
                msgId;
        var strProps = _InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EMPTY;
        if ((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_5__.hasJSON)()) {
            strProps = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_5__.getJSON)().stringify(properties);
        }
        var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : _InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EMPTY) +
            (properties ? " props:" + _sanitizeDiagnosticText(strProps) : _InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EMPTY);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */] += diagnosticText;
    }
    _InternalLogMessage.dataType = "MessageData";
    return _InternalLogMessage;
}());

function safeGetLogger(core, config) {
    return (core || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */] || new DiagnosticLogger(config);
}
var DiagnosticLogger = /** @class */ (function () {
    function DiagnosticLogger(config) {
        this.identifier = "DiagnosticLogger";
        /**
         * The internal logging queue
         */
        this.queue = [];
        /**
         * Count of internal messages sent
         */
        var _messageCount = 0;
        /**
         * Holds information about what message types were already logged to console or sent to server.
         */
        var _messageLogged = {};
        var _loggingLevelConsole;
        var _loggingLevelTelemetry;
        var _maxInternalMessageLimit;
        var _enableDebug;
        var _unloadHandler;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(DiagnosticLogger, this, function (_self) {
            _unloadHandler = _setDefaultsFromConfig(config || {});
            _self.consoleLoggingLevel = function () { return _loggingLevelConsole; };
            /**
             * This method will throw exceptions in debug mode or attempt to log the error as a console warning.
             * @param severity - The severity of the log message
             * @param message  - The log message.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */] = function (severity, msgId, msg, properties, isUserAct) {
                if (isUserAct === void 0) { isUserAct = false; }
                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                if (_enableDebug) {
                    throw (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.dumpObj)(message);
                }
                else {
                    // Get the logging function and fallback to warnToConsole of for some reason errorToConsole doesn't exist
                    var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
                    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */])) {
                        if (isUserAct) {
                            // check if this message type was already logged to console for this page view and if so, don't log it again
                            var messageKey = +message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE_ID /* @min:%2emessageId */];
                            if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                                _self[logFunc](message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */]);
                                _messageLogged[messageKey] = true;
                            }
                        }
                        else {
                            // Only log traces if the console Logging Level is >= the throwInternal severity level
                            if (_loggingLevelConsole >= severity) {
                                _self[logFunc](message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */]);
                            }
                        }
                        _logInternalMessage(severity, message);
                    }
                    else {
                        _debugExtMsg("throw" + (severity === 1 /* eLoggingSeverity.CRITICAL */ ? "Critical" : "Warning"), message);
                    }
                }
            };
            _self.debugToConsole = function (message) {
                _logToConsole("debug", message);
                _debugExtMsg("warning", message);
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */] = function (message) {
                _logToConsole("warn", message);
                _debugExtMsg("warning", message);
            };
            _self.errorToConsole = function (message) {
                _logToConsole("error", message);
                _debugExtMsg("error", message);
            };
            _self.resetInternalMessageCount = function () {
                _messageCount = 0;
                _messageLogged = {};
            };
            _self.logInternalMessage = _logInternalMessage;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {
                _unloadHandler && _unloadHandler.rm();
                _unloadHandler = null;
            };
            function _logInternalMessage(severity, message) {
                if (_areInternalMessagesThrottled()) {
                    return;
                }
                // check if this message type was already logged for this session and if so, don't log it again
                var logMessage = true;
                var messageKey = AIInternalMessagePrefix + message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE_ID /* @min:%2emessageId */];
                // if the session storage is not available, limit to only one message type per page view
                if (_messageLogged[messageKey]) {
                    logMessage = false;
                }
                else {
                    _messageLogged[messageKey] = true;
                }
                if (logMessage) {
                    // Push the event in the internal queue
                    if (severity <= _loggingLevelTelemetry) {
                        _self.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](message);
                        _messageCount++;
                        _debugExtMsg((severity === 1 /* eLoggingSeverity.CRITICAL */ ? "error" : "warn"), message);
                    }
                    // When throttle limit reached, send a special event
                    if (_messageCount === _maxInternalMessageLimit) {
                        var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                        var throttleMessage = new _InternalLogMessage(23 /* _eInternalMessageId.MessageLimitPerPVExceeded */, throttleLimitMessage, false);
                        _self.queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](throttleMessage);
                        if (severity === 1 /* eLoggingSeverity.CRITICAL */) {
                            _self.errorToConsole(throttleLimitMessage);
                        }
                        else {
                            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](throttleLimitMessage);
                        }
                    }
                }
            }
            function _setDefaultsFromConfig(config) {
                // make sure the config is dynamic
                return (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.onConfigChange)((0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.createDynamicConfig)(config, defaultValues, _self).cfg, function (details) {
                    var config = details.cfg;
                    _loggingLevelConsole = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGING_LEVEL_CONSOL4 /* @min:%2eloggingLevelConsole */];
                    _loggingLevelTelemetry = config.loggingLevelTelemetry;
                    _maxInternalMessageLimit = config.maxMessageLimit;
                    _enableDebug = config.enableDebug;
                });
            }
            function _areInternalMessagesThrottled() {
                return _messageCount >= _maxInternalMessageLimit;
            }
            function _debugExtMsg(name, data) {
                var dbgExt = (0,_DbgExtensionUtils__WEBPACK_IMPORTED_MODULE_4__.getDebugExt)(config || {});
                if (dbgExt && dbgExt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]) {
                    dbgExt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](name, data);
                }
            }
        });
    }
// Removed Stub for DiagnosticLogger.prototype.consoleLoggingLevel.
// Removed Stub for DiagnosticLogger.prototype.throwInternal.
// Removed Stub for DiagnosticLogger.prototype.debugToConsole.
// Removed Stub for DiagnosticLogger.prototype.warnToConsole.
// Removed Stub for DiagnosticLogger.prototype.errorToConsole.
// Removed Stub for DiagnosticLogger.prototype.resetInternalMessageCount.
// Removed Stub for DiagnosticLogger.prototype.logInternalMessage.
// Removed Stub for DiagnosticLogger.prototype.unload.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    DiagnosticLogger.__ieDyn=1;

    return DiagnosticLogger;
}());

function _getLogger(logger) {
    return (logger || new DiagnosticLogger());
}
/**
 * This is a helper method which will call throwInternal on the passed logger, will throw exceptions in
 * debug mode or attempt to log the error as a console warning. This helper is provided mostly to better
 * support minification as logger.throwInternal() will not compress the publish "throwInternal" used throughout
 * the code.
 * @param logger - The Diagnostic Logger instance to use.
 * @param severity - The severity of the log message
 * @param message  - The log message.
 */
function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
    if (isUserAct === void 0) { isUserAct = false; }
    _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](severity, msgId, msg, properties, isUserAct);
}
/**
 * This is a helper method which will call warnToConsole on the passed logger with the provided message.
 * @param logger - The Diagnostic Logger instance to use.
 * @param message  - The log message.
 */
function _warnToConsole(logger, message) {
    _getLogger(logger)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);
}
/**
 * Logs a message to the internal queue.
 * @param logger - The Diagnostic Logger instance to use.
 * @param severity  - The severity of the log message
 * @param message - The message to log.
 */
function _logInternalMessage(logger, severity, message) {
    _getLogger(logger).logInternalMessage(severity, message);
}
//# sourceMappingURL=DiagnosticLogger.js.map

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDebugExt: () => (/* binding */ getDebugExt),
/* harmony export */   getDebugListener: () => (/* binding */ getDebugListener)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var listenerFuncs = [_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EVENTS_SENT, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EVENTS_DISCARDED, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EVENTS_SEND_REQUEST, _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_PERF_EVENT];
var _aiNamespace = null;
var _debugListener;
function _listenerProxyFunc(name, config) {
    return function () {
        var args = arguments;
        var dbgExt = getDebugExt(config);
        if (dbgExt) {
            var listener = dbgExt.listener;
            if (listener && listener[name]) {
                listener[name][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_APPLY /* @min:%2eapply */](listener, args);
            }
        }
    };
}
function _getExtensionNamespace() {
    // Cache the lookup of the global namespace object
    var target = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getInst)("Microsoft");
    if (target) {
        _aiNamespace = target["ApplicationInsights"];
    }
    return _aiNamespace;
}
function getDebugExt(config) {
    var ns = _aiNamespace;
    if (!ns && config.disableDbgExt !== true) {
        ns = _aiNamespace || _getExtensionNamespace();
    }
    return ns ? ns["ChromeDbgExt"] : null;
}
function getDebugListener(config) {
    if (!_debugListener) {
        _debugListener = {};
        for (var lp = 0; lp < listenerFuncs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]; lp++) {
            _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
        }
    }
    return _debugListener;
}
//# sourceMappingURL=DbgExtensionUtils.js.map

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NotificationManager: () => (/* binding */ NotificationManager)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(25);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








var defaultValues = {
    perfEvtsSendAll: false
};
function _runScheduledListeners(asyncNotifications) {
    asyncNotifications.h = null;
    var callbacks = asyncNotifications.cb;
    asyncNotifications.cb = [];
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(callbacks, function (cb) {
        // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.safe)(cb.fn, [cb.arg]);
    });
}
// This function is used to combine the logic of running the listeners and handling the async notifications so that they don't
// create multiple timers if there are multiple async listeners.
function _runListeners(listeners, name, asyncNotifications, callback) {
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(listeners, function (listener) {
        if (listener && listener[name]) {
            if (asyncNotifications) {
                // Schedule the callback to be called after the current call stack has cleared.
                asyncNotifications.cb[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_PUSH /* @min:%2epush */]({
                    fn: callback,
                    arg: listener
                });
                asyncNotifications.h = asyncNotifications.h || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.scheduleTimeout)(_runScheduledListeners, 0, asyncNotifications);
            }
            else {
                // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.safe)(callback, [listener]);
            }
        }
    });
}
/**
 * Class to manage sending notifications to all the listeners.
 */
var NotificationManager = /** @class */ (function () {
    function NotificationManager(config) {
        this.listeners = [];
        var perfEvtsSendAll;
        var unloadHandler;
        var _listeners = [];
        var _asyncNotifications = {
            h: null,
            cb: []
        };
        var cfgHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_3__.createDynamicConfig)(config, defaultValues);
        unloadHandler = cfgHandler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_WATCH /* @min:%2ewatch */](function (details) {
            perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
        });
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(NotificationManager, this, function (_self) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.objDefine)(_self, "listeners", {
                g: function () { return _listeners; }
            });
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {
                _listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_PUSH /* @min:%2epush */](listener);
            };
            /**
             * Removes all instances of the listener.
             * @param listener - AWTNotificationListener to remove.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {
                var index = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrIndexOf)(_listeners, listener);
                while (index > -1) {
                    _listeners[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_SPLICE /* @min:%2esplice */](index, 1);
                    index = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrIndexOf)(_listeners, listener);
                }
            };
            /**
             * Notification for events sent.
             * @param events - The array of events that have been sent.
             */
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_SENT /* @min:%2eeventsSent */] = function (events) {
                _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_SENT, _asyncNotifications, function (listener) {
                    listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_SENT /* @min:%2eeventsSent */](events);
                });
            };
            /**
             * Notification for events being discarded.
             * @param events - The array of events that have been discarded by the SDK.
             * @param reason - The reason for which the SDK discarded the events. The EventsDiscardedReason
             * constant should be used to check the different values.
             * @param sendType - [Optional] The send type used when the events were discarded.
             */
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */] = function (events, reason, sendType) {
                _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_DISCARDED, _asyncNotifications, function (listener) {
                    listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */](events, reason, sendType);
                });
            };
            /**
             * [Optional] A function called when the events have been requested to be sent to the sever.
             * @param sendReason - The reason why the event batch is being sent.
             * @param isAsync - A flag which identifies whether the requests are being sent in an async or sync manner.
             */
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */] = function (sendReason, isAsync) {
                _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function (listener) {
                    listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendReason, isAsync);
                });
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_PERF_EVENT /* @min:%2eperfEvent */] = function (perfEvent) {
                if (perfEvent) {
                    // Send all events or only parent events
                    if (perfEvtsSendAll || !perfEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */]()) {
                        _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_PERF_EVENT, null, function (listener) {
                            if (perfEvent.isAsync) {
                                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.scheduleTimeout)(function () { return listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent); }, 0);
                            }
                            else {
                                listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);
                            }
                        });
                    }
                }
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */] = function (events) {
                if (events && events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LENGTH /* @min:%2elength */]) {
                    _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_STORE, _asyncNotifications, function (listener) {
                        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */](events);
                    });
                }
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */] = function (batch) {
                if (batch && batch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_DATA /* @min:%2edata */]) {
                    _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_SENT, _asyncNotifications, function (listener) {
                        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */](batch);
                    });
                }
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */] = function (cnt, reason) {
                if (cnt > 0) {
                    var rn_1 = reason || 0; // default is unknown
                    _runListeners(_listeners, _InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_DROP, _asyncNotifications, function (listener) {
                        listener[_InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */](cnt, rn_1);
                    });
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {
                var _finishUnload = function () {
                    unloadHandler && unloadHandler.rm();
                    unloadHandler = null;
                    _listeners = [];
                    // Clear any async listener
                    _asyncNotifications.h && _asyncNotifications.h[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_CANCEL /* @min:%2ecancel */]();
                    _asyncNotifications.h = null;
                    _asyncNotifications.cb = [];
                };
                var waiting;
                _runListeners(_listeners, "unload", null, function (listener) {
                    var asyncUnload = listener[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_UNLOAD /* @min:%2eunload */](isAsync);
                    if (asyncUnload) {
                        if (!waiting) {
                            waiting = [];
                        }
                        waiting[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_PUSH /* @min:%2epush */](asyncUnload);
                    }
                });
                if (waiting) {
                    return (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.createPromise)(function (resolve) {
                        return (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.doAwaitResponse)((0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.createAllPromise)(waiting), function () {
                            _finishUnload();
                            resolve();
                        });
                    });
                }
                else {
                    _finishUnload();
                }
            };
        });
    }
// Removed Stub for NotificationManager.prototype.addNotificationListener.
// Removed Stub for NotificationManager.prototype.removeNotificationListener.
// Removed Stub for NotificationManager.prototype.eventsSent.
// Removed Stub for NotificationManager.prototype.eventsDiscarded.
// Removed Stub for NotificationManager.prototype.eventsSendRequest.
// Removed Stub for NotificationManager.prototype.perfEvent.
// Removed Stub for NotificationManager.prototype.unload.
// Removed Stub for NotificationManager.prototype.offlineEventsStored.
// Removed Stub for NotificationManager.prototype.offlineBatchSent.
// Removed Stub for NotificationManager.prototype.offlineBatchDrop.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    NotificationManager.__ieDyn=1;

    return NotificationManager;
}());

//# sourceMappingURL=NotificationManager.js.map

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerfEvent: () => (/* binding */ PerfEvent),
/* harmony export */   PerfManager: () => (/* binding */ PerfManager),
/* harmony export */   doPerf: () => (/* binding */ doPerf),
/* harmony export */   getGblPerfMgr: () => (/* binding */ getGblPerfMgr),
/* harmony export */   setGblPerfMgr: () => (/* binding */ setGblPerfMgr)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var strExecutionContextKey = "ctx";
var strParentContextKey = "ParentContextKey";
var strChildrenContextKey = "ChildrenContextKey";
var _defaultPerfManager = null;
var PerfEvent = /** @class */ (function () {
    function PerfEvent(name, payloadDetails, isAsync) {
        var _self = this;
        _self.start = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.utcNow)();
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */] = name;
        _self.isAsync = isAsync;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */] = function () { return false; };
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isFunction)(payloadDetails)) {
            // Create an accessor to minimize the potential performance impact of executing the payloadDetails callback
            var theDetails_1;
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objDefine)(_self, "payload", {
                g: function () {
                    // Delay the execution of the payloadDetails until needed
                    if (!theDetails_1 && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isFunction)(payloadDetails)) {
                        theDetails_1 = payloadDetails();
                        // clear it out now so the referenced objects can be garbage collected
                        payloadDetails = null;
                    }
                    return theDetails_1;
                }
            });
        }
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_CTX /* @min:%2egetCtx */] = function (key) {
            if (key) {
                // The parent and child links are located directly on the object (for better viewing in the DebugPlugin)
                if (key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey]) {
                    return _self[key];
                }
                return (_self[strExecutionContextKey] || {})[key];
            }
            return null;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */] = function (key, value) {
            if (key) {
                // Put the parent and child links directly on the object (for better viewing in the DebugPlugin)
                if (key === PerfEvent[strParentContextKey]) {
                    // Simple assumption, if we are setting a parent then we must be a child
                    if (!_self[key]) {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */] = function () { return true; };
                    }
                    _self[key] = value;
                }
                else if (key === PerfEvent[strChildrenContextKey]) {
                    _self[key] = value;
                }
                else {
                    var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                    ctx[key] = value;
                }
            }
        };
        _self.complete = function () {
            var childTime = 0;
            var childEvts = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_CTX /* @min:%2egetCtx */](PerfEvent[strChildrenContextKey]);
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(childEvts)) {
                for (var lp = 0; lp < childEvts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                    var childEvt = childEvts[lp];
                    if (childEvt) {
                        childTime += childEvt.time;
                    }
                }
            }
            _self.time = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.utcNow)() - _self.start;
            _self.exTime = _self.time - childTime;
            _self.complete = function () { };
        };
    }
    PerfEvent.ParentContextKey = "parent";
    PerfEvent.ChildrenContextKey = "childEvts";
    return PerfEvent;
}());

var PerfManager = /** @class */ (function () {
    function PerfManager(manager) {
        /**
         * General bucket used for execution context set and retrieved via setCtx() and getCtx.
         * Defined as private so it can be visualized via the DebugPlugin
         */
        this.ctx = {};
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(PerfManager, this, function (_self) {
            _self.create = function (src, payloadDetails, isAsync) {
                // TODO (@MSNev): at some point we will want to add additional configuration to "select" which events to instrument
                // for now this is just a simple do everything.
                return new PerfEvent(src, payloadDetails, isAsync);
            };
            _self.fire = function (perfEvent) {
                if (perfEvent) {
                    perfEvent.complete();
                    if (manager && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isFunction)(manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PERF_EVENT /* @min:%2eperfEvent */])) {
                        manager[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);
                    }
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */] = function (key, value) {
                if (key) {
                    var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                    ctx[key] = value;
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_CTX /* @min:%2egetCtx */] = function (key) {
                return (_self[strExecutionContextKey] || {})[key];
            };
        });
    }
// Removed Stub for PerfManager.prototype.create.
// Removed Stub for PerfManager.prototype.fire.
// Removed Stub for PerfManager.prototype.setCtx.
// Removed Stub for PerfManager.prototype.getCtx.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    PerfManager.__ieDyn=1;

    return PerfManager;
}());

var doPerfActiveKey = "CoreUtils.doPerf";
/**
 * Helper function to wrap a function with a perf event
 * @param mgrSource - The Performance Manager or a Performance provider source (may be null)
 * @param getSource - The callback to create the source name for the event (if perf monitoring is enabled)
 * @param func - The function to call and measure
 * @param details - A function to return the payload details
 * @param isAsync - Is the event / function being call asynchronously or synchronously
 */
function doPerf(mgrSource, getSource, func, details, isAsync) {
    if (mgrSource) {
        var perfMgr = mgrSource;
        if (perfMgr[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_GET_PERF_MGR]) {
            // Looks like a perf manager provider object
            perfMgr = perfMgr[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_GET_PERF_MGR]();
        }
        if (perfMgr) {
            var perfEvt = void 0;
            var currentActive = perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_CTX /* @min:%2egetCtx */](doPerfActiveKey);
            try {
                perfEvt = perfMgr.create(getSource(), details, isAsync);
                if (perfEvt) {
                    if (currentActive && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */]) {
                        perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */](PerfEvent[strParentContextKey], currentActive);
                        if (currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_CTX /* @min:%2egetCtx */] && currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */]) {
                            var children = currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_GET_CTX /* @min:%2egetCtx */](PerfEvent[strChildrenContextKey]);
                            if (!children) {
                                children = [];
                                currentActive[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */](PerfEvent[strChildrenContextKey], children);
                            }
                            children[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */](perfEvt);
                        }
                    }
                    // Set this event as the active event now
                    perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */](doPerfActiveKey, perfEvt);
                    return func(perfEvt);
                }
            }
            catch (ex) {
                if (perfEvt && perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */]) {
                    perfEvt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */]("exception", ex);
                }
            }
            finally {
                // fire the perf event
                if (perfEvt) {
                    perfMgr.fire(perfEvt);
                }
                // Reset the active event to the previous value
                perfMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_CTX /* @min:%2esetCtx */](doPerfActiveKey, currentActive);
            }
        }
    }
    return func();
}
/**
 * Set the global performance manager to use when there is no core instance or it has not been initialized yet.
 * @param perfManager - The IPerfManager instance to use when no performance manager is supplied.
 */
function setGblPerfMgr(perfManager) {
    _defaultPerfManager = perfManager;
}
/**
 * Get the current global performance manager that will be used with no performance manager is supplied.
 * @returns - The current default manager
 */
function getGblPerfMgr() {
    return _defaultPerfManager;
}
//# sourceMappingURL=PerfManager.js.map

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProcessTelemetryContext: () => (/* binding */ ProcessTelemetryContext),
/* harmony export */   createProcessTelemetryContext: () => (/* binding */ createProcessTelemetryContext),
/* harmony export */   createProcessTelemetryUnloadContext: () => (/* binding */ createProcessTelemetryUnloadContext),
/* harmony export */   createProcessTelemetryUpdateContext: () => (/* binding */ createProcessTelemetryUpdateContext),
/* harmony export */   createTelemetryPluginProxy: () => (/* binding */ createTelemetryPluginProxy),
/* harmony export */   createTelemetryProxyChain: () => (/* binding */ createTelemetryProxyChain)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _Config_ConfigDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _PerfManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43);
/* harmony import */ var _TelemetryHelpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(45);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */












var strTelemetryPluginChain = "TelemetryPluginChain";
var strHasRunFlags = "_hasRun";
var strGetTelCtx = "_getTelCtx";
var _chainId = 0;
function _getNextProxyStart(proxy, core, startAt) {
    while (proxy) {
        if (proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_PLUGIN /* @min:%2egetPlugin */]() === startAt) {
            return proxy;
        }
        proxy = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */]();
    }
    // This wasn't found in the existing chain so create an isolated one with just this plugin
    return createTelemetryProxyChain([startAt], core.config || {}, core);
}
/**
 * @ignore
 * @param telemetryChain
 * @param dynamicHandler
 * @param core
 * @param startAt - Identifies the next plugin to execute, if null there is no "next" plugin and if undefined it should assume the start of the chain
 * @returns
 */
function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
    // We have a special case where we want to start execution from this specific plugin
    // or we simply reuse the existing telemetry plugin chain (normal execution case)
    var _nextProxy = null; // By Default set as no next plugin
    var _onComplete = [];
    if (!dynamicHandler) {
        dynamicHandler = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.createDynamicConfig)({}, null, core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */]);
    }
    if (startAt !== null) {
        // There is no next element (null) vs not defined (undefined) so use the full chain
        _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
    }
    var context = {
        _next: _moveNext,
        ctx: {
            core: function () {
                return core;
            },
            diagLog: function () {
                return (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__.safeGetLogger)(core, dynamicHandler.cfg);
            },
            getCfg: function () {
                return dynamicHandler.cfg;
            },
            getExtCfg: _resolveExtCfg,
            getConfig: _getConfig,
            hasNext: function () {
                return !!_nextProxy;
            },
            getNext: function () {
                return _nextProxy;
            },
            setNext: function (nextPlugin) {
                _nextProxy = nextPlugin;
            },
            iterate: _iterateChain,
            onComplete: _addOnComplete
        }
    };
    function _addOnComplete(onComplete, that) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        if (onComplete) {
            _onComplete[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */]({
                func: onComplete,
                self: !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(that) ? that : context.ctx,
                args: args
            });
        }
    }
    function _moveNext() {
        var nextProxy = _nextProxy;
        // Automatically move to the next plugin
        _nextProxy = nextProxy ? nextProxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */]() : null;
        if (!nextProxy) {
            var onComplete = _onComplete;
            if (onComplete && onComplete[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(onComplete, function (completeDetails) {
                    try {
                        completeDetails.func.call(completeDetails.self, completeDetails.args);
                    }
                    catch (e) {
                        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._throwInternal)(core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LOGGER /* @min:%2elogger */], 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, "Unexpected Exception during onComplete - " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e));
                    }
                });
                _onComplete = [];
            }
        }
        return nextProxy;
    }
    function _getExtCfg(identifier, createIfMissing) {
        var idCfg = null;
        var cfg = dynamicHandler.cfg;
        if (cfg && identifier) {
            var extCfg = cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EXTENSION_CONFIG /* @min:%2eextensionConfig */];
            if (!extCfg && createIfMissing) {
                extCfg = {};
            }
            // Always set the value so that the property always exists
            cfg[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EXTENSION_CONFIG] = extCfg; // Note: it is valid for the "value" to be undefined
            // Calling `ref()` has a side effect of causing the referenced property to become dynamic  (if not already)
            extCfg = dynamicHandler.ref(cfg, _InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EXTENSION_CONFIG);
            if (extCfg) {
                idCfg = extCfg[identifier];
                if (!idCfg && createIfMissing) {
                    idCfg = {};
                }
                // Always set the value so that the property always exists
                extCfg[identifier] = idCfg; // Note: it is valid for the "value" to be undefined
                // Calling `ref()` has a side effect of causing the referenced property to become dynamic  (if not already)
                idCfg = dynamicHandler.ref(extCfg, identifier);
            }
        }
        return idCfg;
    }
    function _resolveExtCfg(identifier, defaultValues) {
        var newConfig = _getExtCfg(identifier, true);
        if (defaultValues) {
            // Enumerate over the defaultValues and if not already populated attempt to
            // find a value from the root config or use the default value
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(defaultValues, function (field, defaultValue) {
                // for each unspecified field, set the default value
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(newConfig[field])) {
                    var cfgValue = dynamicHandler.cfg[field];
                    if (cfgValue || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(cfgValue)) {
                        newConfig[field] = cfgValue;
                    }
                }
                (0,_Config_ConfigDefaults__WEBPACK_IMPORTED_MODULE_1__._applyDefaultValue)(dynamicHandler, newConfig, field, defaultValue);
            });
        }
        return dynamicHandler.setDf(newConfig, defaultValues);
    }
    function _getConfig(identifier, field, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        var theValue;
        var extConfig = _getExtCfg(identifier, false);
        var rootConfig = dynamicHandler.cfg;
        if (extConfig && (extConfig[field] || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(extConfig[field]))) {
            theValue = extConfig[field];
        }
        else if (rootConfig[field] || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(rootConfig[field])) {
            theValue = rootConfig[field];
        }
        return (theValue || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(theValue)) ? theValue : defaultValue;
    }
    function _iterateChain(cb) {
        // Keep processing until we reach the end of the chain
        var nextPlugin;
        while (!!(nextPlugin = context._next())) {
            var plugin = nextPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_PLUGIN /* @min:%2egetPlugin */]();
            if (plugin) {
                // callback with the current on
                cb(plugin);
            }
        }
    }
    return context;
}
/**
 * Creates a new Telemetry Item context with the current config, core and plugin execution chain
 * @param plugins - The plugin instances that will be executed
 * @param config - The current config
 * @param core - The current core instance
 * @param startAt - Identifies the next plugin to execute, if null there is no "next" plugin and if undefined it should assume the start of the chain
 */
function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
    var config = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.createDynamicConfig)(cfg);
    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
    var context = internalContext.ctx;
    function _processNext(env) {
        var nextPlugin = internalContext._next();
        if (nextPlugin) {
            // Run the next plugin which will call "processNext()"
            nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, context);
        }
        return !nextPlugin;
    }
    function _createNew(plugins, startAt) {
        if (plugins === void 0) { plugins = null; }
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
        }
        return createProcessTelemetryContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */](), config.cfg, core, startAt);
    }
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;
    return context;
}
/**
 * Creates a new Telemetry Item context with the current config, core and plugin execution chain for handling the unloading of the chain
 * @param plugins - The plugin instances that will be executed
 * @param config - The current config
 * @param core - The current core instance
 * @param startAt - Identifies the next plugin to execute, if null there is no "next" plugin and if undefined it should assume the start of the chain
 */
function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
    var config = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.createDynamicConfig)(core.config);
    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
    var context = internalContext.ctx;
    function _processNext(unloadState) {
        var nextPlugin = internalContext._next();
        nextPlugin && nextPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UNLOAD /* @min:%2eunload */](context, unloadState);
        return !nextPlugin;
    }
    function _createNew(plugins, startAt) {
        if (plugins === void 0) { plugins = null; }
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
        }
        return createProcessTelemetryUnloadContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);
    }
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;
    return context;
}
/**
 * Creates a new Telemetry Item context with the current config, core and plugin execution chain for updating the configuration
 * @param plugins - The plugin instances that will be executed
 * @param config - The current config
 * @param core - The current core instance
 * @param startAt - Identifies the next plugin to execute, if null there is no "next" plugin and if undefined it should assume the start of the chain
 */
function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
    var config = (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.createDynamicConfig)(core.config);
    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
    var context = internalContext.ctx;
    function _processNext(updateState) {
        return context.iterate(function (plugin) {
            if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UPDATE /* @min:%2eupdate */])) {
                plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UPDATE /* @min:%2eupdate */](context, updateState);
            }
        });
    }
    function _createNew(plugins, startAt) {
        if (plugins === void 0) { plugins = null; }
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);
        }
        return createProcessTelemetryUpdateContext(plugins || context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);
    }
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;
    context[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;
    return context;
}
/**
 * Creates an execution chain from the array of plugins
 * @param plugins - The array of plugins that will be executed in this order
 * @param defItemCtx - The default execution context to use when no telemetry context is passed to processTelemetry(), this
 * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error
 * reporting (hasRun) when errors occur.
 */
function createTelemetryProxyChain(plugins, config, core, startAt) {
    var firstProxy = null;
    var add = startAt ? false : true;
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(plugins) && plugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
        // Create the proxies and wire up the next plugin chain
        var lastProxy_1 = null;
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(plugins, function (thePlugin) {
            if (!add && startAt === thePlugin) {
                add = true;
            }
            if (add && thePlugin && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {
                // Only add plugins that are processors
                var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
                if (!firstProxy) {
                    firstProxy = newProxy;
                }
                if (lastProxy_1) {
                    // Set this new proxy as the next for the previous one
                    lastProxy_1._setNext(newProxy);
                }
                lastProxy_1 = newProxy;
            }
        });
    }
    if (startAt && !firstProxy) {
        // Special case where the "startAt" was not in the original list of plugins
        return createTelemetryProxyChain([startAt], config, core);
    }
    return firstProxy;
}
/**
 * Create the processing telemetry proxy instance, the proxy is used to abstract the current plugin to allow monitoring and
 * execution plugins while passing around the dynamic execution state (IProcessTelemetryContext), the proxy instance no longer
 * contains any execution state and can be reused between requests (this was not the case for 2.7.2 and earlier with the
 * TelemetryPluginChain class).
 * @param plugin - The plugin instance to proxy
 * @param config - The default execution context to use when no telemetry context is passed to processTelemetry(), this
 * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error
 * reporting (hasRun) when errors occur.
 * @returns
 */
function createTelemetryPluginProxy(plugin, config, core) {
    var nextProxy = null;
    var hasProcessTelemetry = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]);
    var hasSetNext = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */]);
    var chainId;
    if (plugin) {
        chainId = plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IDENTIFIER /* @min:%2eidentifier */] + "-" + plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_PRIORITY /* @min:%2epriority */] + "-" + _chainId++;
    }
    else {
        chainId = "Unknown-0-" + _chainId++;
    }
    var proxyChain = {
        getPlugin: function () {
            return plugin;
        },
        getNext: function () {
            return nextProxy;
        },
        processTelemetry: _processTelemetry,
        unload: _unloadPlugin,
        update: _updatePlugin,
        _id: chainId,
        _setNext: function (nextPlugin) {
            nextProxy = nextPlugin;
        }
    };
    function _getTelCtx() {
        var itemCtx;
        // Looks like a plugin didn't pass the (optional) context, so create a new one
        if (plugin && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(plugin[strGetTelCtx])) {
            // This plugin extends from the BaseTelemetryPlugin so lets use it
            itemCtx = plugin[strGetTelCtx]();
        }
        if (!itemCtx) {
            // Create a temporary one
            itemCtx = createProcessTelemetryContext(proxyChain, config, core);
        }
        return itemCtx;
    }
    function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
        var hasRun = false;
        var identifier = plugin ? plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IDENTIFIER /* @min:%2eidentifier */] : strTelemetryPluginChain;
        var hasRunContext = itemCtx[strHasRunFlags];
        if (!hasRunContext) {
            // Assign and populate
            hasRunContext = itemCtx[strHasRunFlags] = {};
        }
        // Ensure that we keep the context in sync
        itemCtx.setNext(nextProxy);
        if (plugin) {
            (0,_PerfManager__WEBPACK_IMPORTED_MODULE_7__.doPerf)(itemCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */](), function () { return identifier + ":" + name; }, function () {
                // Mark this component as having run
                hasRunContext[chainId] = true;
                try {
                    // Set a flag on the next plugin so we know if it was attempted to be executed
                    var nextId = nextProxy ? nextProxy._id : _InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EMPTY;
                    if (nextId) {
                        hasRunContext[nextId] = false;
                    }
                    hasRun = processPluginFn(itemCtx);
                }
                catch (error) {
                    var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                    if (hasNextRun) {
                        // The next plugin after us has already run so set this one as complete
                        hasRun = true;
                    }
                    if (!nextProxy || !hasNextRun) {
                        // Either we have no next plugin or the current one did not attempt to call the next plugin
                        // Which means the current one is the root of the failure so log/report this failure
                        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__._throwInternal)(itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 73 /* _eInternalMessageId.PluginException */, "Plugin [" + identifier + "] failed during " + name + " - " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(error) + ", run flags: " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(hasRunContext));
                    }
                }
            }, details, isAsync);
        }
        return hasRun;
    }
    function _processTelemetry(env, itemCtx) {
        itemCtx = itemCtx || _getTelCtx();
        function _callProcessTelemetry(itemCtx) {
            if (!plugin || !hasProcessTelemetry) {
                return false;
            }
            var pluginState = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_8__._getPluginState)(plugin);
            if (pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_DISABLED]) {
                return false;
            }
            // Ensure that we keep the context in sync (for processNext()), just in case a plugin
            // doesn't calls processTelemetry() instead of itemContext.processNext() or some
            // other form of error occurred
            if (hasSetNext) {
                // Backward compatibility setting the next plugin on the instance
                plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](nextProxy);
            }
            plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, itemCtx);
            // Process Telemetry is expected to call itemCtx.processNext() or nextPlugin.processTelemetry()
            return true;
        }
        if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function () { return ({ item: env }); }, !(env.sync))) {
            // The underlying plugin is either not defined, not enabled or does not have a processTelemetry implementation
            // so we still want the next plugin to be executed.
            itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);
        }
    }
    function _unloadPlugin(unloadCtx, unloadState) {
        function _callTeardown() {
            // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().
            var hasRun = false;
            if (plugin) {
                var pluginState = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_8__._getPluginState)(plugin);
                var pluginCore = plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */];
                // Only teardown the plugin if it was initialized by the current core (i.e. It's not a shared plugin)
                if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */]) {
                    // Handle plugins that don't extend from the BaseTelemetryPlugin
                    pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */] = null;
                    pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */] = true;
                    pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = false;
                    if (plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */] && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */](unloadCtx, unloadState) === true) {
                        // plugin told us that it was going to (or has) call unloadCtx.processNext()
                        hasRun = true;
                    }
                }
            }
            return hasRun;
        }
        if (!_processChain(unloadCtx, _callTeardown, "unload", function () { }, unloadState.isAsync)) {
            // Only called if we hasRun was not true
            unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);
        }
    }
    function _updatePlugin(updateCtx, updateState) {
        function _callUpdate() {
            // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().
            var hasRun = false;
            if (plugin) {
                var pluginState = (0,_TelemetryHelpers__WEBPACK_IMPORTED_MODULE_8__._getPluginState)(plugin);
                var pluginCore = plugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE] || pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */];
                // Only update the plugin if it was initialized by the current core (i.e. It's not a shared plugin)
                if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */]) {
                    if (plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UPDATE /* @min:%2eupdate */] && plugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UPDATE /* @min:%2eupdate */](updateCtx, updateState) === true) {
                        // plugin told us that it was going to (or has) call unloadCtx.processNext()
                        hasRun = true;
                    }
                }
            }
            return hasRun;
        }
        if (!_processChain(updateCtx, _callUpdate, "update", function () { }, false)) {
            // Only called if we hasRun was not true
            updateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);
        }
    }
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objFreeze)(proxyChain);
}
/**
 * This class will be removed!
 * @deprecated use createProcessTelemetryContext() instead
 */
var ProcessTelemetryContext = /** @class */ (function () {
    /**
     * Creates a new Telemetry Item context with the current config, core and plugin execution chain
     * @param plugins - The plugin instances that will be executed
     * @param config - The current config
     * @param core - The current core instance
     */
    function ProcessTelemetryContext(pluginChain, config, core, startAt) {
        var _self = this;
        var context = createProcessTelemetryContext(pluginChain, config, core, startAt);
        // Proxy all functions of the context to this object
        (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_5__.proxyFunctions)(_self, context, (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objKeys)(context));
    }
    return ProcessTelemetryContext;
}());

//# sourceMappingURL=ProcessTelemetryContext.js.map

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _getPluginState: () => (/* binding */ _getPluginState),
/* harmony export */   createDistributedTraceContext: () => (/* binding */ createDistributedTraceContext),
/* harmony export */   initializePlugins: () => (/* binding */ initializePlugins),
/* harmony export */   sortPlugins: () => (/* binding */ sortPlugins),
/* harmony export */   unloadComponents: () => (/* binding */ unloadComponents)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _DataCacheHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var _W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */







var pluginStateData = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_2__.createElmNodeData)("plugin");
function _getPluginState(plugin) {
    return pluginStateData.get(plugin, "state", {}, true);
}
/**
 * Initialize the queue of plugins
 * @param plugins - The array of plugins to initialize and setting of the next plugin
 * @param config - The current config for the instance
 * @param core - THe current core instance
 * @param extensions - The extensions
 */
function initializePlugins(processContext, extensions) {
    // Set the next plugin and identified the uninitialized plugins
    var initPlugins = [];
    var lastPlugin = null;
    var proxy = processContext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_NEXT /* @min:%2egetNext */]();
    var pluginState;
    while (proxy) {
        var thePlugin = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_PLUGIN /* @min:%2egetPlugin */]();
        if (thePlugin) {
            if (lastPlugin && lastPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] && thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]) {
                // Set this plugin as the next for the previous one
                lastPlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](thePlugin);
            }
            pluginState = _getPluginState(thePlugin);
            var isInitialized = !!pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */];
            if (thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]) {
                isInitialized = thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */]();
            }
            if (!isInitialized) {
                initPlugins[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](thePlugin);
            }
            lastPlugin = thePlugin;
            proxy = proxy[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_NEXT /* @min:%2egetNext */]();
        }
    }
    // Now initialize the plugins
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(initPlugins, function (thePlugin) {
        var core = processContext[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_CORE /* @min:%2ecore */]();
        thePlugin[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_INITIALIZE /* @min:%2einitialize */](processContext.getCfg(), core, extensions, processContext[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_NEXT /* @min:%2egetNext */]());
        pluginState = _getPluginState(thePlugin);
        // Only add the core to the state if the plugin didn't set it (doesn't extend from BaseTelemetryPlugin)
        if (!thePlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_CORE] && !pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_CORE]) {
            pluginState[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_CORE] = core;
        }
        pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = true;
        delete pluginState[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TEARDOWN /* @min:%2eteardown */];
    });
}
function sortPlugins(plugins) {
    // Sort by priority
    return plugins.sort(function (extA, extB) {
        var result = 0;
        if (extB) {
            var bHasProcess = extB[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PROCESS_TELEMETRY];
            if (extA[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PROCESS_TELEMETRY]) {
                result = bHasProcess ? extA[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PRIORITY] - extB[_InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_PRIORITY] : 1;
            }
            else if (bHasProcess) {
                result = -1;
            }
        }
        else {
            result = extA ? 1 : -1;
        }
        return result;
    });
    // sort complete
}
/**
 * Teardown / Unload helper to perform teardown/unloading operations for the provided components synchronously or asynchronously, this will call any
 * _doTeardown() or _doUnload() functions on the provided components to allow them to finish removal.
 * @param components - The components you want to unload
 * @param unloadCtx - This is the context that should be used during unloading.
 * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.
 * @param asyncCallback - An optional callback that the plugin must call if it returns true to inform the caller that it has completed any async unload/teardown operations.
 * @returns boolean - true if the plugin has or will call asyncCallback, this allows the plugin to perform any asynchronous operations.
 */
function unloadComponents(components, unloadCtx, unloadState, asyncCallback) {
    var idx = 0;
    function _doUnload() {
        while (idx < components[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
            var component = components[idx++];
            if (component) {
                var func = component._doUnload || component[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */];
                if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(func)) {
                    if (func.call(component, unloadCtx, unloadState, _doUnload) === true) {
                        return true;
                    }
                }
            }
        }
    }
    return _doUnload();
}
/**
 * Creates a IDistributedTraceContext which optionally also "sets" the value on a parent
 * @param parentCtx - An optional parent distributed trace instance
 * @returns A new IDistributedTraceContext instance that uses an internal temporary object
 */
function createDistributedTraceContext(parentCtx) {
    var trace = {};
    return {
        getName: function () {
            return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */];
        },
        setName: function (newValue) {
            parentCtx && parentCtx.setName(newValue);
            trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = newValue;
        },
        getTraceId: function () {
            return trace.traceId;
        },
        setTraceId: function (newValue) {
            parentCtx && parentCtx.setTraceId(newValue);
            if ((0,_W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__.isValidTraceId)(newValue)) {
                trace.traceId = newValue;
            }
        },
        getSpanId: function () {
            return trace.spanId;
        },
        setSpanId: function (newValue) {
            parentCtx && parentCtx.setSpanId(newValue);
            if ((0,_W3cTraceParent__WEBPACK_IMPORTED_MODULE_4__.isValidSpanId)(newValue)) {
                trace.spanId = newValue;
            }
        },
        getTraceFlags: function () {
            return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */];
        },
        setTraceFlags: function (newTraceFlags) {
            parentCtx && parentCtx.setTraceFlags(newTraceFlags);
            trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */] = newTraceFlags;
        }
    };
}
//# sourceMappingURL=TelemetryHelpers.js.map

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTraceParent: () => (/* binding */ createTraceParent),
/* harmony export */   findAllScripts: () => (/* binding */ findAllScripts),
/* harmony export */   findW3cTraceParent: () => (/* binding */ findW3cTraceParent),
/* harmony export */   formatTraceParent: () => (/* binding */ formatTraceParent),
/* harmony export */   isSampledFlag: () => (/* binding */ isSampledFlag),
/* harmony export */   isValidSpanId: () => (/* binding */ isValidSpanId),
/* harmony export */   isValidTraceId: () => (/* binding */ isValidTraceId),
/* harmony export */   isValidTraceParent: () => (/* binding */ isValidTraceParent),
/* harmony export */   parseTraceParent: () => (/* binding */ parseTraceParent)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _CoreUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





// using {0,16} for leading and trailing whitespace just to constrain the possible runtime of a random string
var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i;
var DEFAULT_VERSION = "00";
var INVALID_VERSION = "ff";
var INVALID_TRACE_ID = "00000000000000000000000000000000";
var INVALID_SPAN_ID = "0000000000000000";
var SAMPLED_FLAG = 0x01;
function _isValid(value, len, invalidValue) {
    if (value && value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] === len && value !== invalidValue) {
        return !!value.match(/^[\da-f]*$/i);
    }
    return false;
}
function _formatValue(value, len, defValue) {
    if (_isValid(value, len)) {
        return value;
    }
    return defValue;
}
function _formatFlags(value) {
    if (isNaN(value) || value < 0 || value > 255) {
        value = 0x01;
    }
    var result = value.toString(16);
    while (result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] < 2) {
        result = "0" + result;
    }
    return result;
}
/**
 * Create a new ITraceParent instance using the provided values.
 * @param traceId - The traceId to use, when invalid a new random W3C id will be generated.
 * @param spanId - The parent/span id to use, a new random value will be generated if it is invalid.
 * @param flags - The traceFlags to use, defaults to zero (0) if not supplied or invalid
 * @param version - The version to used, defaults to version "01" if not supplied or invalid.
 * @returns
 */
function createTraceParent(traceId, spanId, flags, version) {
    return {
        version: _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION,
        traceId: isValidTraceId(traceId) ? traceId : (0,_CoreUtils__WEBPACK_IMPORTED_MODULE_2__.generateW3CId)(),
        spanId: isValidSpanId(spanId) ? spanId : (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strLeft)((0,_CoreUtils__WEBPACK_IMPORTED_MODULE_2__.generateW3CId)(), 16),
        traceFlags: flags >= 0 && flags <= 0xFF ? flags : 1
    };
}
/**
 * Attempt to parse the provided string as a W3C TraceParent header value (https://www.w3.org/TR/trace-context/#traceparent-header)
 *
 * @param value - The value to be parsed
 * @param selectIdx - If the found value is comma separated which is the preferred entry to select, defaults to the first
 * @returns
 */
function parseTraceParent(value, selectIdx) {
    if (!value) {
        // Don't pass a null/undefined or empty string
        return null;
    }
    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        // The value may have been encoded on the page into an array so handle this automatically
        value = value[0] || "";
    }
    if (!value || !(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(value) || value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 8192) {
        // limit potential processing based on total length
        return null;
    }
    if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_INDEX_OF /* @min:%2eindexOf */](",") !== -1) {
        var values = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](",");
        value = values[selectIdx > 0 && values[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > selectIdx ? selectIdx : 0];
    }
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    var match = TRACE_PARENT_REGEX.exec((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.strTrim)(value));
    if (!match || // No match
        match[1] === INVALID_VERSION || // version ff is forbidden
        match[2] === INVALID_TRACE_ID || // All zeros is considered to be invalid
        match[3] === INVALID_SPAN_ID) { // All zeros is considered to be invalid
        return null;
    }
    return {
        version: (match[1] || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),
        traceId: (match[2] || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),
        spanId: (match[3] || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),
        traceFlags: parseInt(match[4], 16)
    };
}
/**
 * Is the provided W3c Trace Id a valid string representation, it must be a 32-character string
 * of lowercase hexadecimal characters for example, 4bf92f3577b34da6a3ce929d0e0e4736.
 * If all characters as zero (00000000000000000000000000000000) it will be considered an invalid value.
 * @param value - The W3c trace Id to be validated
 * @returns true if valid otherwise false
 */
function isValidTraceId(value) {
    return _isValid(value, 32, INVALID_TRACE_ID);
}
/**
 * Is the provided W3c span id (aka. parent id) a valid string representation, it must be a 16-character
 * string of lowercase hexadecimal characters, for example, 00f067aa0ba902b7.
 * If all characters are zero (0000000000000000) this is considered an invalid value.
 * @param value - The W3c span id to be validated
 * @returns true if valid otherwise false
 */
function isValidSpanId(value) {
    return _isValid(value, 16, INVALID_SPAN_ID);
}
/**
 * Validates that the provided ITraceParent instance conforms to the currently supported specifications
 * @param value - The parsed traceParent value
 * @returns
 */
function isValidTraceParent(value) {
    if (!value ||
        !_isValid(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VERSION /* @min:%2eversion */], 2, INVALID_VERSION) ||
        !_isValid(value.traceId, 32, INVALID_TRACE_ID) ||
        !_isValid(value.spanId, 16, INVALID_SPAN_ID) ||
        !_isValid(_formatFlags(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */]), 2)) {
        // Each known field must contain a valid value
        return false;
    }
    return true;
}
/**
 * Is the parsed traceParent indicating that the trace is currently sampled.
 * @param value - The parsed traceParent value
 * @returns
 */
function isSampledFlag(value) {
    if (isValidTraceParent(value)) {
        return (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */] & SAMPLED_FLAG) === SAMPLED_FLAG;
    }
    return false;
}
/**
 * Format the ITraceParent value as a string using the supported and know version formats.
 * So even if the passed traceParent is a later version the string value returned from this
 * function will convert it to only the known version formats.
 * This currently only supports version "00" and invalid "ff"
 * @param value - The parsed traceParent value
 * @returns
 */
function formatTraceParent(value) {
    if (value) {
        // Special Note: This only supports formatting as version 00, future versions should encode any known supported version
        // So parsing a future version will populate the correct version value but reformatting will reduce it to version 00.
        var flags = _formatFlags(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_FLAGS /* @min:%2etraceFlags */]);
        if (!_isValid(flags, 2)) {
            flags = "01";
        }
        var version = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_VERSION /* @min:%2eversion */] || DEFAULT_VERSION;
        if (version !== "00" && version !== "ff") {
            // Reduce version to "00"
            version = DEFAULT_VERSION;
        }
        // Format as version 00
        return "".concat(version.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
    }
    return "";
}
/**
 * Helper function to fetch the passed traceparent from the page, looking for it as a meta-tag or a Server-Timing header.
 * @param selectIdx - If the found value is comma separated which is the preferred entry to select, defaults to the first
 * @returns
 */
function findW3cTraceParent(selectIdx) {
    var name = "traceparent";
    var traceParent = parseTraceParent((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_3__.findMetaTag)(name), selectIdx);
    if (!traceParent) {
        traceParent = parseTraceParent((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_3__.findNamedServerTiming)(name), selectIdx);
    }
    return traceParent;
}
/**
 * Find all script tags in the provided document and return the information about them.
 * @param doc - The document to search for script tags
 * @returns
 */
function findAllScripts(doc) {
    var scripts = doc.getElementsByTagName("script");
    var result = [];
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(scripts, function (script) {
        var src = script[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */]("src");
        if (src) {
            var crossOrigin = script[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */]("crossorigin");
            var async = script.hasAttribute("async") === true;
            var defer = script.hasAttribute("defer") === true;
            var referrerPolicy = script[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */]("referrerpolicy");
            var info = { url: src };
            if (crossOrigin) {
                info.crossOrigin = crossOrigin;
            }
            if (async) {
                info.async = async;
            }
            if (defer) {
                info.defer = defer;
            }
            if (referrerPolicy) {
                info.referrerPolicy = referrerPolicy;
            }
            result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](info);
        }
    });
    return result;
}
//# sourceMappingURL=W3cTraceParent.js.map

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Undefined: () => (/* binding */ Undefined),
/* harmony export */   generateW3CId: () => (/* binding */ generateW3CId),
/* harmony export */   newGuid: () => (/* binding */ newGuid),
/* harmony export */   strEndsWith: () => (/* binding */ strEndsWith)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var _RandomHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








// Added to help with minfication
var Undefined = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.strShimUndefined;
function newGuid() {
    var uuid = generateW3CId();
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 0, 8) + "-" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 8, 12) + "-" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 12, 16) + "-" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 16, 20) + "-" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(uuid, 20);
}
/**
 * The strEndsWith() method determines whether a string ends with the characters of a specified string, returning true or false as appropriate.
 * @param value - The value to check whether it ends with the search value.
 * @param search - The characters to be searched for at the end of the value.
 * @returns true if the given search value is found at the end of the string, otherwise false.
 */
function strEndsWith(value, search) {
    if (value && search) {
        var len = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */];
        var start = len - search[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */];
        return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstring)(value, start >= 0 ? start : 0, len) === search;
    }
    return false;
}
/**
 * generate W3C trace id
 */
function generateW3CId() {
    var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    // rfc4122 version 4 UUID without dashes and with lowercase letters
    var oct = _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY, tmp;
    for (var a = 0; a < 4; a++) {
        tmp = (0,_RandomHelper__WEBPACK_IMPORTED_MODULE_4__.random32)();
        oct +=
            hexValues[tmp & 0xF] +
                hexValues[tmp >> 4 & 0xF] +
                hexValues[tmp >> 8 & 0xF] +
                hexValues[tmp >> 12 & 0xF] +
                hexValues[tmp >> 16 & 0xF] +
                hexValues[tmp >> 20 & 0xF] +
                hexValues[tmp >> 24 & 0xF] +
                hexValues[tmp >> 28 & 0xF];
    }
    // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
    var clockSequenceHi = hexValues[8 + ((0,_RandomHelper__WEBPACK_IMPORTED_MODULE_4__.random32)() & 0x03) | 0];
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 0, 8) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 9, 4) + "4" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 13, 3) + clockSequenceHi + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 16, 3) + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.strSubstr)(oct, 19, 12);
}
//# sourceMappingURL=CoreUtils.js.map

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TelemetryInitializerPlugin: () => (/* binding */ TelemetryInitializerPlugin)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _BaseTelemetryPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(24);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
// 
// 








function _addInitializer(_initializers, id, telemetryInitializer) {
    var theInitializer = {
        id: id,
        fn: telemetryInitializer
    };
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrAppend)(_initializers, theInitializer);
    var handler = {
        remove: function () {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(_initializers, function (initializer, idx) {
                if (initializer.id === theInitializer.id) {
                    _initializers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SPLICE /* @min:%2esplice */](idx, 1);
                    return -1;
                }
            });
        }
    };
    return handler;
}
function _runInitializers(_initializers, item, logger) {
    var doNotSendItem = false;
    var telemetryInitializersCount = _initializers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
    for (var i = 0; i < telemetryInitializersCount; ++i) {
        var telemetryInitializer = _initializers[i];
        if (telemetryInitializer) {
            try {
                if (telemetryInitializer.fn[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_APPLY /* @min:%2eapply */](null, [item]) === false) {
                    doNotSendItem = true;
                    break;
                }
            }
            catch (e) {
                // log error but dont stop executing rest of the telemetry initializers
                // doNotSendItem = true;
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_5__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, "Telemetry initializer failed: " + (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_6__.getExceptionName)(e), { exception: (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(e) }, true);
            }
        }
    }
    return !doNotSendItem;
}
var TelemetryInitializerPlugin = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__extendsFn)(TelemetryInitializerPlugin, _super);
    function TelemetryInitializerPlugin() {
        var _this = _super.call(this) || this;
        _this.identifier = "TelemetryInitializerPlugin";
        _this.priority = 199;
        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()
        var _id;
        var _initializers;
        _initDefaults();
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(TelemetryInitializerPlugin, _this, function (_self, _base) {
            _self.addTelemetryInitializer = function (telemetryInitializer) {
                return _addInitializer(_initializers, _id++, telemetryInitializer);
            };
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_7__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */] = function (item, itemCtx) {
                if (_runInitializers(_initializers, item, itemCtx ? itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]() : _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]())) {
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](item, itemCtx);
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] = function () {
                _initDefaults();
            };
        });
        function _initDefaults() {
            _id = 0;
            _initializers = [];
        }
        return _this;
    }
// Removed Stub for TelemetryInitializerPlugin.prototype.addTelemetryInitializer.
// Removed Stub for TelemetryInitializerPlugin.prototype.processTelemetry.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    TelemetryInitializerPlugin.__ieDyn=1;

    return TelemetryInitializerPlugin;
}(_BaseTelemetryPlugin__WEBPACK_IMPORTED_MODULE_4__.BaseTelemetryPlugin));

//# sourceMappingURL=TelemetryInitializerPlugin.js.map

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTelemetryPlugin: () => (/* binding */ BaseTelemetryPlugin)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);
/* harmony import */ var _ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(44);
/* harmony import */ var _UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(50);
/* harmony import */ var _UnloadHookContainer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(51);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var _a;










var strGetPlugin = "getPlugin";
var defaultValues = (_a = {},
    _a[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_EXTENSION_CONFIG] = { isVal: _HelperFuncs__WEBPACK_IMPORTED_MODULE_5__.isNotNullOrUndefined, v: {} },
    _a);
/**
 * BaseTelemetryPlugin provides a basic implementation of the ITelemetryPlugin interface so that plugins
 * can avoid implementation the same set of boiler plate code as well as provide a base
 * implementation so that new default implementations can be added without breaking all plugins.
 */
var BaseTelemetryPlugin = /** @class */ (function () {
    function BaseTelemetryPlugin() {
        var _self = this; // Setting _self here as it's used outside of the dynamicProto as well
        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()
        var _isinitialized;
        var _rootCtx; // Used as the root context, holding the current config and initialized core
        var _nextPlugin; // Used for backward compatibility where plugins don't call the main pipeline
        var _unloadHandlerContainer;
        var _hookContainer;
        _initDefaults();
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(BaseTelemetryPlugin, _self, function (_self) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {
                _setDefaults(config, core, pluginChain);
                _isinitialized = true;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TEARDOWN /* @min:%2eteardown */] = function (unloadCtx, unloadState) {
                // If this plugin has already been torn down (not operational) or is not initialized (core is not set)
                // or the core being used for unload was not the same core used for initialization.
                var core = _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */];
                if (!core || (unloadCtx && core !== unloadCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */]())) {
                    // Do Nothing as either the plugin is not initialized or was not initialized by the current core
                    return;
                }
                var result;
                var unloadDone = false;
                var theUnloadCtx = unloadCtx || (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_7__.createProcessTelemetryUnloadContext)(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUnloadState = unloadState || {
                    reason: 0 /* TelemetryUnloadReason.ManualTeardown */,
                    isAsync: false
                };
                function _unloadCallback() {
                    if (!unloadDone) {
                        unloadDone = true;
                        _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                        _hookContainer.run(theUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]());
                        if (result === true) {
                            theUnloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](theUnloadState);
                        }
                        _initDefaults();
                    }
                }
                if (!_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] || _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                    _unloadCallback();
                }
                else {
                    // Tell the caller that we will be calling processNext()
                    result = true;
                }
                return result;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_UPDATE /* @min:%2eupdate */] = function (updateCtx, updateState) {
                // If this plugin has already been torn down (not operational) or is not initialized (core is not set)
                // or the core being used for unload was not the same core used for initialization.
                var core = _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */];
                if (!core || (updateCtx && core !== updateCtx[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */]())) {
                    // Do Nothing
                    return;
                }
                var result;
                var updateDone = false;
                var theUpdateCtx = updateCtx || (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_7__.createProcessTelemetryUpdateContext)(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUpdateState = updateState || {
                    reason: 0 /* TelemetryUpdateReason.Unknown */
                };
                function _updateCallback() {
                    if (!updateDone) {
                        updateDone = true;
                        _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */]());
                    }
                }
                if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                    _updateCallback();
                }
                else {
                    result = true;
                }
                return result;
            };
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_5__.proxyFunctionAs)(_self, "_addUnloadCb", function () { return _unloadHandlerContainer; }, "add");
            (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_5__.proxyFunctionAs)(_self, "_addHook", function () { return _hookContainer; }, "add");
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.objDefine)(_self, "_unloadHooks", { g: function () { return _hookContainer; } });
        });
        // These are added after the dynamicProto so that are not moved to the prototype
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */] = function (itemCtx) {
            return _getTelCtx(itemCtx)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DIAG_LOG /* @min:%2ediagLog */]();
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () {
            return _isinitialized;
        };
        _self.setInitialized = function (isInitialized) {
            _isinitialized = isInitialized;
        };
        // _self.getNextPlugin = () => DO NOT IMPLEMENT
        // Sub-classes of this base class *should* not be relying on this value and instead
        // should use processNext() function. If you require access to the plugin use the
        // IProcessTelemetryContext.getNext().getPlugin() while in the pipeline, Note getNext() may return null.
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] = function (next) {
            _nextPlugin = next;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = function (env, itemCtx) {
            if (itemCtx) {
                // Normal core execution sequence
                itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);
            }
            else if (_nextPlugin && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {
                // Looks like backward compatibility or out of band processing. And as it looks
                // like a ITelemetryPlugin or ITelemetryPluginChain, just call processTelemetry
                _nextPlugin[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, null);
            }
        };
        _self._getTelCtx = _getTelCtx;
        function _getTelCtx(currentCtx) {
            if (currentCtx === void 0) { currentCtx = null; }
            var itemCtx = currentCtx;
            if (!itemCtx) {
                var rootCtx = _rootCtx || (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_7__.createProcessTelemetryContext)(null, {}, _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */]);
                // tslint:disable-next-line: prefer-conditional-expression
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                    // Looks like a chain object
                    itemCtx = rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin[strGetPlugin]);
                }
                else {
                    itemCtx = rootCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin);
                }
            }
            return itemCtx;
        }
        function _setDefaults(config, core, pluginChain) {
            // Make sure the extensionConfig exists and the config is dynamic
            (0,_Config_DynamicConfig__WEBPACK_IMPORTED_MODULE_2__.createDynamicConfig)(config, defaultValues, (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_4__.safeGetLogger)(core));
            if (!pluginChain && core) {
                // Get the first plugin from the core
                pluginChain = core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_PROCESS_TEL_CONT2 /* @min:%2egetProcessTelContext */]()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_GET_NEXT /* @min:%2egetNext */]();
            }
            var nextPlugin = _nextPlugin;
            if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                // If it looks like a proxy/chain then get the plugin
                nextPlugin = _nextPlugin[strGetPlugin]();
            }
            // Support legacy plugins where core was defined as a property
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */] = core;
            _rootCtx = (0,_ProcessTelemetryContext__WEBPACK_IMPORTED_MODULE_7__.createProcessTelemetryContext)(pluginChain, config, core, nextPlugin);
        }
        function _initDefaults() {
            _isinitialized = false;
            _self[_InternalConstants__WEBPACK_IMPORTED_MODULE_6__.STR_CORE /* @min:%2ecore */] = null;
            _rootCtx = null;
            _nextPlugin = null;
            _hookContainer = (0,_UnloadHookContainer__WEBPACK_IMPORTED_MODULE_9__.createUnloadHookContainer)();
            _unloadHandlerContainer = (0,_UnloadHandlerContainer__WEBPACK_IMPORTED_MODULE_8__.createUnloadHandlerContainer)();
        }
    }
// Removed Stub for BaseTelemetryPlugin.prototype.initialize.
// Removed Stub for BaseTelemetryPlugin.prototype.teardown.
// Removed Stub for BaseTelemetryPlugin.prototype.update.
// Removed Stub for BaseTelemetryPlugin.prototype._addUnloadCb.
// Removed Stub for BaseTelemetryPlugin.prototype._addHook.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    BaseTelemetryPlugin.__ieDyn=1;

    return BaseTelemetryPlugin;
}());

//# sourceMappingURL=BaseTelemetryPlugin.js.map

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createUnloadHandlerContainer: () => (/* binding */ createUnloadHandlerContainer)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





function createUnloadHandlerContainer() {
    var handlers = [];
    function _addHandler(handler) {
        if (handler) {
            handlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](handler);
        }
    }
    function _runHandlers(unloadCtx, unloadState) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(handlers, function (handler) {
            try {
                handler(unloadCtx, unloadState);
            }
            catch (e) {
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(unloadCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, "Unexpected error calling unload handler - " + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e));
            }
        });
        handlers = [];
    }
    return {
        add: _addHandler,
        run: _runHandlers
    };
}
//# sourceMappingURL=UnloadHandlerContainer.js.map

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _testHookMaxUnloadHooksCb: () => (/* binding */ _testHookMaxUnloadHooksCb),
/* harmony export */   createUnloadHookContainer: () => (/* binding */ createUnloadHookContainer)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var _maxHooks;
var _hookAddMonitor;
/**
 * Test hook for setting the maximum number of unload hooks and calling a monitor function when the hooks are added or removed
 * This allows for automatic test failure when the maximum number of unload hooks is exceeded
 * @param maxHooks - The maximum number of unload hooks
 * @param addMonitor - The monitor function to call when hooks are added or removed
 */
function _testHookMaxUnloadHooksCb(maxHooks, addMonitor) {
    _maxHooks = maxHooks;
    _hookAddMonitor = addMonitor;
}
/**
 * Create a IUnloadHookContainer which can be used to remember unload hook functions to be executed during the component unloading
 * process.
 * @returns A new IUnloadHookContainer instance
 */
function createUnloadHookContainer() {
    var _hooks = [];
    function _doUnload(logger) {
        var oldHooks = _hooks;
        _hooks = [];
        // Remove all registered unload hooks
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(oldHooks, function (fn) {
            // allow either rm or remove callback function
            try {
                (fn.rm || fn.remove).call(fn);
            }
            catch (e) {
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, "Unloading:" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e));
            }
        });
        if (_maxHooks && oldHooks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > _maxHooks) {
            _hookAddMonitor ? _hookAddMonitor("doUnload", oldHooks) : (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(null, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.MaxUnloadHookExceeded */, "Max unload hooks exceeded. An excessive number of unload hooks has been detected.");
        }
    }
    function _addHook(hooks) {
        if (hooks) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrAppend)(_hooks, hooks);
            if (_maxHooks && _hooks[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > _maxHooks) {
                _hookAddMonitor ? _hookAddMonitor("Add", _hooks) : (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(null, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.MaxUnloadHookExceeded */, "Max unload hooks exceeded. An excessive number of unload hooks has been detected.");
            }
        }
    }
    return {
        run: _doUnload,
        add: _addHook
    };
}
//# sourceMappingURL=UnloadHookContainer.js.map

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   STR_DEFAULT_ENDPOINT_URL: () => (/* binding */ STR_DEFAULT_ENDPOINT_URL),
/* harmony export */   STR_EMPTY: () => (/* binding */ STR_EMPTY),
/* harmony export */   STR_PROPERTIES: () => (/* binding */ STR_PROPERTIES),
/* harmony export */   STR_VERSION: () => (/* binding */ STR_VERSION)
/* harmony export */ });
/*
 * 1DS JS SDK Core, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

// Licensed under the MIT License.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Generally you should only put values that are used more than 2 times and then only if not already exposed as a constant (such as SdkCoreNames)
// as when using "short" named values from here they will be will be minified smaller than the SdkCoreNames[eSdkCoreNames.xxxx] value.
var STR_EMPTY = "";
var STR_DEFAULT_ENDPOINT_URL = "https://browser.events.data.microsoft.com/OneCollector/1.0/";
var STR_VERSION = "version";
var STR_PROPERTIES = "properties";
//# sourceMappingURL=InternalConstants.js.map

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FullVersionString: () => (/* binding */ FullVersionString),
/* harmony export */   Version: () => (/* binding */ Version),
/* harmony export */   createGuid: () => (/* binding */ createGuid),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   getCommonSchemaMetaData: () => (/* binding */ getCommonSchemaMetaData),
/* harmony export */   getCookieValue: () => (/* binding */ getCookieValue),
/* harmony export */   getFieldValueType: () => (/* binding */ getFieldValueType),
/* harmony export */   getTenantId: () => (/* binding */ getTenantId),
/* harmony export */   getTime: () => (/* binding */ getTime),
/* harmony export */   isArrayValid: () => (/* binding */ isArrayValid),
/* harmony export */   isChromium: () => (/* binding */ isChromium),
/* harmony export */   isDocumentObjectAvailable: () => (/* binding */ isDocumentObjectAvailable),
/* harmony export */   isGreaterThanZero: () => (/* binding */ isGreaterThanZero),
/* harmony export */   isLatency: () => (/* binding */ isLatency),
/* harmony export */   isUint8ArrayAvailable: () => (/* binding */ isUint8ArrayAvailable),
/* harmony export */   isValueAssigned: () => (/* binding */ isValueAssigned),
/* harmony export */   isValueKind: () => (/* binding */ isValueKind),
/* harmony export */   isWindowObjectAvailable: () => (/* binding */ isWindowObjectAvailable),
/* harmony export */   openXhr: () => (/* binding */ openXhr),
/* harmony export */   sanitizeProperty: () => (/* binding */ sanitizeProperty),
/* harmony export */   setProcessTelemetryTimings: () => (/* binding */ setProcessTelemetryTimings)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(54);
/*
 * 1DS JS SDK Core, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
var _a;
/**
* Utils.ts
* @author  Abhilash Panwar (abpanwar) Hector Hernandez (hectorh)
* @copyright Microsoft 2018
* File containing utility functions.
*/





var Version = '4.3.11';
var FullVersionString = "1DS-Web-JS-" + Version;
var ObjHasOwnProperty = _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.ObjProto.hasOwnProperty;
// Defining here so we don't need to take (import) the ApplicationInsights Common module
var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
var strWithCredentials = "withCredentials";
var strTimeout = "timeout";
// If value is array just get the type for the first element
var _fieldTypeEventPropMap = (_a = {},
    _a[0 /* FieldValueSanitizerType.NotSet */] = 0 /* eEventPropertyType.Unspecified */,
    _a[2 /* FieldValueSanitizerType.Number */] = 6 /* eEventPropertyType.Double */,
    _a[1 /* FieldValueSanitizerType.String */] = 1 /* eEventPropertyType.String */,
    _a[3 /* FieldValueSanitizerType.Boolean */] = 7 /* eEventPropertyType.Bool */,
    _a[4096 /* FieldValueSanitizerType.Array */ | 2 /* FieldValueSanitizerType.Number */] = 6 /* eEventPropertyType.Double */,
    _a[4096 /* FieldValueSanitizerType.Array */ | 1 /* FieldValueSanitizerType.String */] = 1 /* eEventPropertyType.String */,
    _a[4096 /* FieldValueSanitizerType.Array */ | 3 /* FieldValueSanitizerType.Boolean */] = 7 /* eEventPropertyType.Bool */,
    _a);
/**
 * @ignore
 */
// let _uaDisallowsSameSiteNone = null;
var uInt8ArraySupported = null;
// var _areCookiesAvailable: boolean | undefined;
/**
 * Checks if document object is available
 */
var isDocumentObjectAvailable = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hasDocument)();
/**
 * Checks if window object is available
 */
var isWindowObjectAvailable = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hasWindow)();
/**
 * Checks if value is assigned to the given param.
 * @param value - The token from which the tenant id is to be extracted.
 * @returns True/false denoting if value is assigned to the param.
 */
function isValueAssigned(value) {
    /// <summary> takes a value and checks for undefined, null and empty string </summary>
    /// <param type="any"> value to be tested </param>
    /// <returns> true if value is null undefined or emptyString </returns>
    return !(value === _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(value));
}
/**
 * Gets the tenant id from the tenant token.
 * @param apiKey - The token from which the tenant id is to be extracted.
 * @returns The tenant id.
 */
function getTenantId(apiKey) {
    if (apiKey) {
        var indexTenantId = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(apiKey, "-");
        if (indexTenantId > -1) {
            return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strLeft)(apiKey, indexTenantId);
        }
    }
    return _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY;
}
/**
 * Checks if Uint8Array are available in the current environment. Safari and Firefox along with
 * ReactNative are known to not support Uint8Array properly.
 * @returns True if available, false otherwise.
 */
function isUint8ArrayAvailable() {
    if (uInt8ArraySupported === null) {
        uInt8ArraySupported = !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(Uint8Array) && !isSafariOrFirefox() && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isReactNative)();
    }
    return uInt8ArraySupported;
}
/**
 * Checks if the value is a valid EventLatency.
 * @param value - The value that needs to be checked.
 * @returns True if the value is in AWTEventLatency, false otherwise.
 */
function isLatency(value) {
    if (value && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(value) && value >= 1 /* EventLatencyValue.Normal */ && value <= 4 /* EventLatencyValue.Immediate */) {
        return true;
    }
    return false;
}
/**
 * Sanitizes the Property. It checks the that the property name and value are valid. It also
 * checks/populates the correct type and pii of the property value.
 * @param name - property name                          - The property name.
 * @param property - The property value or an IEventProperty containing value,
 * type ,pii and customer content.
 * @returns IEventProperty containing valid name, value, pii and type or null if invalid.
 */
function sanitizeProperty(name, property, stringifyObjects) {
    // Check that property is valid
    if ((!property && !isValueAssigned(property)) || typeof name !== "string") {
        return null;
    }
    // Perf optimization -- only need to get the type once not multiple times
    var propType = typeof property;
    // If the property isn't IEventProperty (and is either string, number, boolean or array), convert it into one.
    if (propType === "string" || propType === "number" || propType === "boolean" || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(property)) {
        property = { value: property };
    }
    else if (propType === "object" && !ObjHasOwnProperty.call(property, "value")) {
        property = { value: stringifyObjects ? JSON.stringify(property) : property };
    }
    else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */])
        || property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */] === _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY || (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */])
        && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNumber)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */]) && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */])
        && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */]))) {
        // Since property is IEventProperty, we need to validate its value
        return null;
    }
    // We need to check that if the property value is an array, it is valid
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */]) &&
        !isArrayValid(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */])) {
        return null;
    }
    // If either pii or cc is set convert value to string (since only string pii/cc is allowed).
    // If the value is a complex type like an array that can't be converted to string we will drop
    // the property.
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(property.kind)) {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */]) || !isValueKind(property.kind)) {
            return null;
        }
        property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */] = property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */].toString();
    }
    return property;
}
function getCommonSchemaMetaData(value, kind, type) {
    var encodedTypeValue = -1;
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(value)) {
        if (kind > 0) {
            if (kind === 32 /* eValueKind.CustomerContent_GenericContent */) {
                // encode customer content. Value can only be string. bit 13-16 are for cc
                encodedTypeValue = (1 << 13);
            }
            else if (kind <= 13) {
                // encode PII. Value can only be string. bits 5-12 are for Pii
                encodedTypeValue = (kind << 5);
            }
        }
        // isDataType checks that the "type" is a number so we don't need to check for undefined
        if (isDataType(type)) {
            // Data Type is provided and valid, so use that
            if (encodedTypeValue === -1) {
                // Don't return -1
                encodedTypeValue = 0;
            }
            encodedTypeValue |= type;
        }
        else {
            var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
            if (encodedTypeValue !== -1 && propType !== -1) {
                // pii exists so we must return correct type
                encodedTypeValue |= propType;
            }
            else if (propType === 6 /* eEventPropertyType.Double */) {
                encodedTypeValue = propType;
            }
        }
    }
    return encodedTypeValue;
}
/**
 * Helper to get and decode the cookie value using decodeURIComponent, this is for historical
 * backward compatibility where the document.cookie value was decoded before parsing.
 * @param cookieMgr - The cookie manager to use
 * @param name - The name of the cookie to get
 * @param decode - A flag to indicate whether the cookie value should be decoded
 * @returns The decoded cookie value (if available) otherwise an empty string.
 */
function getCookieValue(cookieMgr, name, decode) {
    if (decode === void 0) { decode = true; }
    var cookieValue;
    if (cookieMgr) {
        cookieValue = cookieMgr.get(name);
        if (decode && cookieValue && decodeURIComponent) {
            cookieValue = decodeURIComponent(cookieValue);
        }
    }
    return cookieValue || _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY;
}
/**
 * Create a new guid.
 * @param style - The style of guid to generated, defaults to Digits
 * Digits (Default) : 32 digits separated by hyphens: 00000000-0000-0000-0000-000000000000
 * Braces - 32 digits separated by hyphens, enclosed in braces: \{00000000-0000-0000-0000-000000000000\}
 * Parentheses - 32 digits separated by hyphens, enclosed in parentheses: (00000000-0000-0000-0000-000000000000)
 * Numeric - 32 digits: 00000000000000000000000000000000
 */
function createGuid(style) {
    if (style === void 0) { style = "D" /* GuidStyle.Digits */; }
    var theGuid = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.newGuid)();
    if (style === "B" /* GuidStyle.Braces */) {
        theGuid = "{" + theGuid + "}";
    }
    else if (style === "P" /* GuidStyle.Parentheses */) {
        theGuid = "(" + theGuid + ")";
    }
    else if (style === "N" /* GuidStyle.Numeric */) {
        theGuid = theGuid.replace(/-/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_4__.STR_EMPTY);
    }
    return theGuid;
}
/**
 * Pass in the objects to merge as arguments.
 * @param obj1 - object to merge.  Set this argument to 'true' for a deep extend.
 * @param obj2 - object to merge.
 * @param obj3 - object to merge.
 * @param obj4 - object to merge.
 * @param obj5 - object to merge.
 * @returns The extended object.
 */
function extend(obj, obj2, obj3, obj4, obj5) {
    // Variables
    var extended = {};
    var deep = false;
    var i = 0;
    var length = arguments[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */];
    var theArgs = arguments;
    // Check if a deep merge
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(theArgs[0])) {
        deep = theArgs[0];
        i++;
    }
    // Loop through each object and conduct a merge
    for (; i < length; i++) {
        var obj = theArgs[i];
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(obj, function (prop, value) {
            // If deep merge and property is an object, merge properties
            if (deep && value && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(value)) {
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                    extended[prop] = extended[prop] || [];
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(value, function (arrayValue, arrayIndex) {
                        if (arrayValue && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(arrayValue)) {
                            extended[prop][arrayIndex] = extend(true, extended[prop][arrayIndex], arrayValue);
                        }
                        else {
                            extended[prop][arrayIndex] = arrayValue;
                        }
                    });
                }
                else {
                    extended[prop] = extend(true, extended[prop], value);
                }
            }
            else {
                extended[prop] = value;
            }
        });
    }
    return extended;
}
var getTime = _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.perfNow;
function isValueKind(value) {
    // Always assume that it's a number (no type checking) for performance as this is used during the JSON serialization
    if (value === 0 /* eValueKind.NotSet */ || ((value > 0 /* eValueKind.NotSet */ && value <= 13 /* eValueKind.Pii_IPV4AddressLegacy */) || value === 32 /* eValueKind.CustomerContent_GenericContent */)) {
        return true;
    }
    return false;
}
function isDataType(value) {
    // Remark: 0 returns false, but it doesn't affect encoding anyways
    // Always assume that it's a number (no type checking) for performance as this is used during the JSON serialization
    if (value >= 0 && value <= 9) {
        return true;
    }
    return false;
}
function isSafariOrFirefox() {
    var nav = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getNavigator)();
    // If non-browser navigator will be undefined
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(nav) && nav.userAgent) {
        var ua = nav.userAgent.toLowerCase();
        if ((ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_INDEX_OF /* @min:%2eindexOf */]("safari") >= 0 || ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_INDEX_OF /* @min:%2eindexOf */]("firefox") >= 0) && ua[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_INDEX_OF /* @min:%2eindexOf */]("chrome") < 0) {
            return true;
        }
    }
    return false;
}
function isArrayValid(value) {
    return value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0;
}
function setProcessTelemetryTimings(event, identifier) {
    var evt = event;
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_TIMINGS /* @min:%2etimings */] = evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_TIMINGS /* @min:%2etimings */] || {};
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_TIMINGS /* @min:%2etimings */][_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_PROCESS_TELEMETRY_ST0 /* @min:%2eprocessTelemetryStart */] = evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_TIMINGS /* @min:%2etimings */][_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_PROCESS_TELEMETRY_ST0 /* @min:%2eprocessTelemetryStart */] || {};
    evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_TIMINGS /* @min:%2etimings */][_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_PROCESS_TELEMETRY_ST0 /* @min:%2eprocessTelemetryStart */][identifier] = getTime();
}
/**
 * Returns a bitwise value for the FieldValueSanitizerType enum representing the decoded type of the passed value
 * @param value - The value to determine the type
 */
function getFieldValueType(value) {
    var theType = 0 /* FieldValueSanitizerType.NotSet */;
    if (value !== null && value !== undefined) {
        var objType = typeof value;
        if (objType === "string") {
            theType = 1 /* FieldValueSanitizerType.String */;
        }
        else if (objType === "number") {
            theType = 2 /* FieldValueSanitizerType.Number */;
        }
        else if (objType === "boolean") {
            theType = 3 /* FieldValueSanitizerType.Boolean */;
        }
        else if (objType === _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_3__.strShimObject) {
            theType = 4 /* FieldValueSanitizerType.Object */;
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
                theType = 4096 /* FieldValueSanitizerType.Array */;
                if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    // Empty arrays are not supported and are considered to be the same as null
                    theType |= getFieldValueType(value[0]);
                }
            }
            else if (ObjHasOwnProperty.call(value, "value")) {
                // Looks like an IEventProperty
                theType = 8192 /* FieldValueSanitizerType.EventProperty */ | getFieldValueType(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_5__._DYN_VALUE /* @min:%2evalue */]);
            }
        }
    }
    return theType;
}
/**
 * Helper to identify whether we are running in a chromium based browser environment
 */
function isChromium() {
    return !!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getInst)("chrome");
}
/**
 * Create and open an XMLHttpRequest object
 * @param method - The request method
 * @param urlString - The url
 * @param withCredentials - Option flag indicating that credentials should be sent
 * @param disabled - Optional flag indicating that the XHR object should be marked as disabled and not tracked (default is false)
 * @param isSync - Optional flag indicating if the instance should be a synchronous request (defaults to false)
 * @param timeout - Optional value identifying the timeout value that should be assigned to the XHR request
 * @returns A new opened XHR request
 */
function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
    if (disabled === void 0) { disabled = false; }
    if (isSync === void 0) { isSync = false; }
    function _wrapSetXhrProp(xhr, prop, value) {
        try {
            xhr[prop] = value;
        }
        catch (e) {
            // - Wrapping as depending on the environment setting the property may fail (non-terminally)
        }
    }
    var xhr = new XMLHttpRequest();
    if (disabled) {
        // Tag the instance so it's not tracked (trackDependency)
        // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would
        // cause the request to fail and we no telemetry would be sent
        _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
    }
    if (withCredentials) {
        // Some libraries require that the withCredentials flag is set "before" open and
        // - Wrapping as IE 10 has started throwing when setting before open
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    xhr.open(method, urlString, !isSync);
    if (withCredentials) {
        // withCredentials should be set AFTER open (https://xhr.spec.whatwg.org/#the-withcredentials-attribute)
        // And older firefox instances from 11+ will throw for sync events (current versions don't) which happens during unload processing
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    // Only set the timeout for asynchronous requests as
    // "Timeout shouldn't be used for synchronous XMLHttpRequests requests used in a document environment or it will throw an InvalidAccessError exception.""
    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout
    if (!isSync && timeout) {
        _wrapSetXhrProp(xhr, strTimeout, timeout);
    }
    return xhr;
}
/**
 * Check to see if the value is \> 0
 * @param value - The value to check
 * @returns true if \> 0 otherwise false
 */
function isGreaterThanZero(value) {
    return value > 0;
}
//# sourceMappingURL=Utils.js.map

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _DYN_CAN_HANDLE: () => (/* binding */ _DYN_CAN_HANDLE),
/* harmony export */   _DYN_HANDLE_FIELD: () => (/* binding */ _DYN_HANDLE_FIELD),
/* harmony export */   _DYN_INDEX_OF: () => (/* binding */ _DYN_INDEX_OF),
/* harmony export */   _DYN_INITIALIZE: () => (/* binding */ _DYN_INITIALIZE),
/* harmony export */   _DYN_LENGTH: () => (/* binding */ _DYN_LENGTH),
/* harmony export */   _DYN_POLL_INTERNAL_LOGS: () => (/* binding */ _DYN_POLL_INTERNAL_LOGS),
/* harmony export */   _DYN_PROCESS_TELEMETRY_ST0: () => (/* binding */ _DYN_PROCESS_TELEMETRY_ST0),
/* harmony export */   _DYN_RM_FIELD_SANITIZER: () => (/* binding */ _DYN_RM_FIELD_SANITIZER),
/* harmony export */   _DYN_RM_SANITIZER: () => (/* binding */ _DYN_RM_SANITIZER),
/* harmony export */   _DYN_TIMINGS: () => (/* binding */ _DYN_TIMINGS),
/* harmony export */   _DYN_VALUE: () => (/* binding */ _DYN_VALUE)
/* harmony export */ });
/*
 * 1DS JS SDK Core, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

// Licensed under the MIT License.
// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES5 which can result in a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_INITIALIZE = "initialize"; // Count: 4
var _DYN_INDEX_OF = "indexOf"; // Count: 4
var _DYN_TIMINGS = "timings"; // Count: 4
var _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs"; // Count: 4
var _DYN_VALUE = "value"; // Count: 20
var _DYN_LENGTH = "length"; // Count: 7
var _DYN_PROCESS_TELEMETRY_ST0 = "processTelemetryStart"; // Count: 3
var _DYN_HANDLE_FIELD = "handleField"; // Count: 3
var _DYN_RM_SANITIZER = "rmSanitizer"; // Count: 3
var _DYN_RM_FIELD_SANITIZER = "rmFieldSanitizer"; // Count: 3
var _DYN_CAN_HANDLE = "canHandle"; // Count: 4
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventLatency: () => (/* binding */ EventLatency),
/* harmony export */   EventPersistence: () => (/* binding */ EventPersistence),
/* harmony export */   EventPropertyType: () => (/* binding */ EventPropertyType),
/* harmony export */   TraceLevel: () => (/* binding */ TraceLevel),
/* harmony export */   ValueKind: () => (/* binding */ ValueKind)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/*
 * 1DS JS SDK Core, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* Enums.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
* File containing the enums as constants.
*/

/**
 * The ValueKind contains a set of values that specify value kind of the property.
 * Either PII (Personal Identifiable Information) or customer content.
 */
var ValueKind = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    NotSet: 0 /* eValueKind.NotSet */,
    Pii_DistinguishedName: 1 /* eValueKind.Pii_DistinguishedName */,
    Pii_GenericData: 2 /* eValueKind.Pii_GenericData */,
    Pii_IPV4Address: 3 /* eValueKind.Pii_IPV4Address */,
    Pii_IPv6Address: 4 /* eValueKind.Pii_IPv6Address */,
    Pii_MailSubject: 5 /* eValueKind.Pii_MailSubject */,
    Pii_PhoneNumber: 6 /* eValueKind.Pii_PhoneNumber */,
    Pii_QueryString: 7 /* eValueKind.Pii_QueryString */,
    Pii_SipAddress: 8 /* eValueKind.Pii_SipAddress */,
    Pii_SmtpAddress: 9 /* eValueKind.Pii_SmtpAddress */,
    Pii_Identity: 10 /* eValueKind.Pii_Identity */,
    Pii_Uri: 11 /* eValueKind.Pii_Uri */,
    Pii_Fqdn: 12 /* eValueKind.Pii_Fqdn */,
    Pii_IPV4AddressLegacy: 13 /* eValueKind.Pii_IPV4AddressLegacy */,
    Pii_IPv6ScrubLastHextets: 14 /* eValueKind.Pii_IPv6ScrubLastHextets */,
    Pii_DropValue: 15 /* eValueKind.Pii_DropValue */,
    CustomerContent_GenericContent: 32 /* eValueKind.CustomerContent_GenericContent */
}));
/**
 * The EventLatency contains a set of values that specify the latency with which an event is sent.
 */
var EventLatency = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Normal latency.
     */
    Normal: 1 /* EventLatencyValue.Normal */,
    /**
     * Cost deferred latency. At the moment this latency is treated as Normal latency.
     */
    CostDeferred: 2 /* EventLatencyValue.CostDeferred */,
    /**
     * Real time latency.
     */
    RealTime: 3 /* EventLatencyValue.RealTime */,
    /**
     * Bypass normal batching/timing and send as soon as possible, this will still send asynchronously.
     * Added in v3.1.1
     */
    Immediate: 4 /* EventLatencyValue.Immediate */
}));
/**
 * Enum for property types.
 */
var EventPropertyType = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    Unspecified: 0 /* eEventPropertyType.Unspecified */,
    String: 1 /* eEventPropertyType.String */,
    Int32: 2 /* eEventPropertyType.Int32 */,
    UInt32: 3 /* eEventPropertyType.UInt32 */,
    Int64: 4 /* eEventPropertyType.Int64 */,
    UInt64: 5 /* eEventPropertyType.UInt64 */,
    Double: 6 /* eEventPropertyType.Double */,
    Bool: 7 /* eEventPropertyType.Bool */,
    Guid: 8 /* eEventPropertyType.Guid */,
    DateTime: 9 /* eEventPropertyType.DateTime */
}));
/**
 * The EventPersistence contains a set of values that specify the event's persistence.
 */
var EventPersistence = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Normal persistence.
     */
    Normal: 1 /* EventPersistenceValue.Normal */,
    /**
     * Critical persistence.
     */
    Critical: 2 /* EventPersistenceValue.Critical */
}));
var TraceLevel = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    NONE: 0 /* eTraceLevel.NONE */,
    ERROR: 1 /* eTraceLevel.ERROR */,
    WARNING: 2 /* eTraceLevel.WARNING */,
    INFORMATION: 3 /* eTraceLevel.INFORMATION */
}));
//# sourceMappingURL=Enums.js.map

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ValueSanitizer: () => (/* binding */ ValueSanitizer)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);
/*
 * 1DS JS SDK Core, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */





function _isSpecialName(name) {
    return (name == "__proto__" || name == "constructor" || name == "prototype");
}
var ValueSanitizer = /** @class */ (function () {
    function ValueSanitizer(fieldSanitizerProvider) {
        var _self = this;
        // To aid with performance this is a lookup map to check if the field value sanitizer supports this field
        var _sanitizerMap = {};
        var _sanitizers = [];
        var _fieldSanitizers = [];
        if (fieldSanitizerProvider) {
            _fieldSanitizers.push(fieldSanitizerProvider);
        }
        function _getFieldSanitizer(path, name) {
            var result;
            var fieldLookup = _sanitizerMap[path];
            if (fieldLookup) {
                result = fieldLookup[name];
            }
            if (!result && result !== null) {
                // Null is a valid result indicating that the value sanitizer does not support this field
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(path) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(name)) {
                    if (_fieldSanitizers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        for (var lp = 0; lp < _fieldSanitizers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                            if (_fieldSanitizers[lp][_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HANDLE_FIELD /* @min:%2ehandleField */](path, name)) {
                                result = {
                                    canHandle: true,
                                    fieldHandler: _fieldSanitizers[lp]
                                };
                                break;
                            }
                        }
                    }
                    else if (_sanitizers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] === 0) {
                        // Special use-case where there is no sanitizer to pass on to, so just resolving the field
                        // and returning the resulting value (same as sanitizeProperty())
                        result = {
                            canHandle: true
                        };
                    }
                }
                // We still don't have a handler so lets lookup the providers
                if (!result && result !== null) {
                    // Setting the result to null -- which means we and any contained sanitizers can't handle this field
                    result = null;
                    for (var lp = 0; lp < _sanitizers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                        if (_sanitizers[lp][_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HANDLE_FIELD /* @min:%2ehandleField */](path, name)) {
                            result = {
                                canHandle: true,
                                handler: _sanitizers[lp],
                                fieldHandler: null
                            };
                            break;
                        }
                    }
                }
                if (!fieldLookup) {
                    // Handle edge case to avoid prototype pollution
                    if (_isSpecialName(path)) {
                        return null;
                    }
                    fieldLookup = _sanitizerMap[path] = {};
                }
                // Handle edge case to avoid prototype pollution
                if (_isSpecialName(name)) {
                    return null;
                }
                fieldLookup[name] = result;
            }
            return result;
        }
        _self.clearCache = function () {
            _sanitizerMap = {};
        };
        _self.addSanitizer = function (newSanitizer) {
            if (newSanitizer) {
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIncludes)(_sanitizers, newSanitizer)) {
                    _sanitizers.push(newSanitizer);
                }
                // Invalidate any previously mapped fields
                _sanitizerMap = {};
            }
        };
        _self.addFieldSanitizer = function (fieldSanitizer) {
            if (fieldSanitizer) {
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIncludes)(_fieldSanitizers, fieldSanitizer)) {
                    _fieldSanitizers.push(fieldSanitizer);
                }
                // Invalidate any previously mapped fields
                _sanitizerMap = {};
            }
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_RM_SANITIZER /* @min:%2ermSanitizer */] = function (theSanitizer) {
            if (theSanitizer) {
                var idx = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_sanitizers, theSanitizer);
                if (idx !== -1) {
                    _sanitizers.splice(idx, 1);
                    // Invalidate any previously mapped fields
                    _sanitizerMap = {};
                }
                // Try and remove the sanitizer from any chained sanitizer as well
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_sanitizers, function (sanitizer) {
                    sanitizer && sanitizer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_RM_SANITIZER /* @min:%2ermSanitizer */] && sanitizer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_RM_SANITIZER /* @min:%2ermSanitizer */](theSanitizer);
                });
            }
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_RM_FIELD_SANITIZER /* @min:%2ermFieldSanitizer */] = function (theFieldSanitizer) {
            if (theFieldSanitizer) {
                var idx = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_fieldSanitizers, theFieldSanitizer);
                if (idx !== -1) {
                    _fieldSanitizers.splice(idx, 1);
                    // Invalidate any previously mapped fields
                    _sanitizerMap = {};
                }
                // Try and remove the field sanitizer from any chained sanitizer as well
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(_sanitizers, function (sanitizer) {
                    sanitizer && sanitizer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_RM_FIELD_SANITIZER /* @min:%2ermFieldSanitizer */] && sanitizer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_RM_FIELD_SANITIZER /* @min:%2ermFieldSanitizer */](theFieldSanitizer);
                });
            }
        };
        _self.isEmpty = function () {
            return ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getLength)(_sanitizers) + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getLength)(_fieldSanitizers)) === 0;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HANDLE_FIELD /* @min:%2ehandleField */] = function (path, name) {
            var mapValue = _getFieldSanitizer(path, name);
            return mapValue ? mapValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CAN_HANDLE /* @min:%2ecanHandle */] : false;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */] = function (path, name, value, stringifyObjects) {
            var mapValue = _getFieldSanitizer(path, name);
            if (mapValue && mapValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CAN_HANDLE /* @min:%2ecanHandle */]) {
                if (!mapValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CAN_HANDLE /* @min:%2ecanHandle */]) {
                    return null;
                }
                if (mapValue.handler) {
                    // This value sanitizer can't handle this field so pass it only the next one
                    return mapValue.handler[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */](path, name, value, stringifyObjects);
                }
                // Check that property is valid
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(name) || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(value) || value === _InternalConstants__WEBPACK_IMPORTED_MODULE_1__.STR_EMPTY) {
                    return null;
                }
                var property = null;
                var fieldType = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.getFieldValueType)(value);
                if ((fieldType & 8192 /* FieldValueSanitizerType.EventProperty */) === 8192 /* FieldValueSanitizerType.EventProperty */) {
                    var subType = fieldType & ~8192 /* FieldValueSanitizerType.EventProperty */;
                    property = value;
                    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */]) ||
                        (subType !== 1 /* FieldValueSanitizerType.String */ &&
                            subType !== 2 /* FieldValueSanitizerType.Number */ &&
                            subType !== 3 /* FieldValueSanitizerType.Boolean */ &&
                            (subType & 4096 /* FieldValueSanitizerType.Array */) !== 4096 /* FieldValueSanitizerType.Array */)) {
                        // Not a supported IEventProperty type to be able to sanitize
                        return null;
                    }
                }
                else if (fieldType === 1 /* FieldValueSanitizerType.String */ ||
                    fieldType === 2 /* FieldValueSanitizerType.Number */ ||
                    fieldType === 3 /* FieldValueSanitizerType.Boolean */ ||
                    (fieldType & 4096 /* FieldValueSanitizerType.Array */) === 4096 /* FieldValueSanitizerType.Array */) {
                    // If the property isn't IEventProperty (and is either string, number, boolean or array), convert it into one.
                    property = _convertToProperty(path, name, value);
                }
                else if (fieldType === 4 /* FieldValueSanitizerType.Object */) {
                    property = _convertToProperty(path, name, !!stringifyObjects ? JSON.stringify(value) : value);
                }
                if (property) {
                    return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
                }
            }
            return null;
        };
        _self.property = function (path, name, property, stringifyObjects) {
            var mapValue = _getFieldSanitizer(path, name);
            if (!mapValue || !mapValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CAN_HANDLE /* @min:%2ecanHandle */]) {
                return null;
            }
            // Check that property is valid
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(name) || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(property) || !(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */])) {
                return null;
            }
            var fieldType = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.getFieldValueType)(property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */]);
            if (fieldType === 0 /* FieldValueSanitizerType.NotSet */) {
                // Not a supported field that we can sanitize or serialize
                return null;
            }
            return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
        };
        function _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects) {
            if (mapValue.handler) {
                // This value sanitizer can't handle this field so pass it only the next one
                return mapValue.handler.property(path, name, property, stringifyObjects);
            }
            // If either pii or cc is set convert value to string (since only string pii/cc is allowed).
            // If the value is a complex type like an array that can't be converted to string we will drop
            // the property.
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(property.kind)) {
                if ((fieldType & 4096 /* FieldValueSanitizerType.Array */) === 4096 /* FieldValueSanitizerType.Array */ || !(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isValueKind)(property.kind)) {
                    return null;
                }
                // Convert the value to a string and assign back to the original value
                property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */] = property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */].toString();
            }
            return _callFieldSanitizer(mapValue.fieldHandler, path, name, fieldType, property);
        }
        function _convertToProperty(path, name, value) {
            if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(value)) {
                return { value: value };
            }
            return null;
        }
        function _callFieldSanitizer(fieldProvider, path, name, theType, property) {
            if (property && fieldProvider) {
                var sanitizer = fieldProvider.getSanitizer(path, name, theType, property.kind, property.propertyType);
                if (sanitizer) {
                    // This is where we the field will call the handler to "scrub" the value. This the primary hook for the ClientHashing Plugin to
                    // be able to apply the hashFunc() / Sha256 conversion of the properties value
                    if (theType === 4 /* FieldValueSanitizerType.Object */) {
                        // Special case of an embedded object (ext.metadata, data.properties)
                        var newValue_1 = {};
                        var propValue = property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */];
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(propValue, function (propKey, theValue) {
                            var newPath = path + "." + name;
                            if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(theValue)) {
                                var newProp = _convertToProperty(newPath, propKey, theValue);
                                newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.getFieldValueType)(theValue), newProp);
                                if (newProp) {
                                    newValue_1[propKey] = newProp[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */];
                                }
                            }
                        });
                        property[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */] = newValue_1;
                    }
                    else {
                        var details = {
                            path: path,
                            name: name,
                            type: theType,
                            prop: property,
                            sanitizer: _self
                        };
                        property = sanitizer.call(_self, details);
                    }
                }
            }
            return property;
        }
    }
    ValueSanitizer.getFieldType = _Utils__WEBPACK_IMPORTED_MODULE_2__.getFieldValueType;
    return ValueSanitizer;
}());

//# sourceMappingURL=ValueSanitizer.js.map

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MinChannelPriorty: () => (/* binding */ MinChannelPriorty)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
var MinChannelPriorty = 100;
//# sourceMappingURL=IChannelControls.js.map

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BatchDiscardedReason: () => (/* binding */ BatchDiscardedReason),
/* harmony export */   EventsDiscardedReason: () => (/* binding */ EventsDiscardedReason)
/* harmony export */ });
/* harmony import */ var _JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



/**
 * The EventsDiscardedReason enumeration contains a set of values that specify the reason for discarding an event.
 */
var EventsDiscardedReason = ( /* @__PURE__ */(0,_JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Unknown.
     */
    Unknown: 0 /* eEventsDiscardedReason.Unknown */,
    /**
     * Status set to non-retryable.
     */
    NonRetryableStatus: 1 /* eEventsDiscardedReason.NonRetryableStatus */,
    /**
     * The event is invalid.
     */
    InvalidEvent: 2 /* eEventsDiscardedReason.InvalidEvent */,
    /**
     * The size of the event is too large.
     */
    SizeLimitExceeded: 3 /* eEventsDiscardedReason.SizeLimitExceeded */,
    /**
     * The server is not accepting events from this instrumentation key.
     */
    KillSwitch: 4 /* eEventsDiscardedReason.KillSwitch */,
    /**
     * The event queue is full.
     */
    QueueFull: 5 /* eEventsDiscardedReason.QueueFull */,
    /**
     * The sendBeacon API call failed for reasons other than size limits.
     */
    BeaconSendFailure: 6 /* eEventsDiscardedReason.BeaconSendFailure */
}));
/**
 *  The eBatchDiscardedReason enumeration contains a set of values that specify the reason for discarding offline batches.
 */
var BatchDiscardedReason = ( /* @__PURE__ */(0,_JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Unknown.
     */
    Unknown: 0 /* eBatchDiscardedReason.Unknown */,
    /**
      * Status set to non-retryable after sending
      */
    NonRetryableStatus: 1 /* eBatchDiscardedReason.NonRetryableStatus */,
    /**
     * Batches with lower number of critical events are dropped to free up storage space
     */
    CleanStorage: 2 /* eBatchDiscardedReason.CleanStorage */,
    /**
     * The batches in storage exceed max allowed time
     */
    MaxInStorageTimeExceeded: 3 /* eBatchDiscardedReason.MaxInStorageTimeExceeded */
}));
//# sourceMappingURL=EventsDiscardedReason.js.map

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseResponse: () => (/* binding */ parseResponse)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






/**
 * Parses the response from the backend.
 * @param response - XMLHttpRequest or XDomainRequest response
 */
function parseResponse(response, diagLog) {
    try {
        if (response && response !== "") {
            var result = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_3__.getJSON)().parse(response);
            if (result && result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] && result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] >= result.itemsAccepted &&
                result.itemsReceived - result.itemsAccepted === result.errors[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
                return result;
            }
        }
    }
    catch (e) {
        (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(diagLog, 1 /* eLoggingSeverity.CRITICAL */, 43 /* _eInternalMessageId.InvalidBackendResponse */, "Cannot parse the response. " + (e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e)), {
            response: response
        });
    }
    return null;
}
//# sourceMappingURL=ResponseHelpers.js.map

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SenderPostManager: () => (/* binding */ SenderPostManager)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37);
/* harmony import */ var _DiagnosticLogger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _EnvUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(24);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */










var STR_EMPTY = "";
var STR_NO_RESPONSE_BODY = "NoResponseBody";
var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
var STR_POST_METHOD = "POST";
/**
 * This Internal component
 * Manager SendPost functions
 * SendPostManger
 * @internal for internal use only
 */
var SenderPostManager = /** @class */ (function () {
    function SenderPostManager() {
        var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)
        var _enableSendPromise;
        var _isInitialized;
        var _diagLog;
        var _isOneDs;
        var _onCompleteFuncs;
        var _disableCredentials;
        var _fetchCredentials;
        var _fallbackInst;
        var _disableXhr;
        var _disableBeacon;
        var _disableBeaconSync;
        var _disableFetchKeepAlive;
        var _addNoResponse;
        var _timeoutWrapper;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(SenderPostManager, this, function (_self, _base) {
            var _sendCredentials = true; // for 1ds
            _initDefaults();
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, diagLog) {
                _diagLog = diagLog;
                if (_isInitialized) {
                    (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_5__._throwInternal)(_diagLog, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, "Sender is already initialized");
                }
                _self.SetConfig(config);
                _isInitialized = true;
            };
            _self["_getDbgPlgTargets"] = function () {
                return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];
            };
            // This componet might get its config from sender, offline sender, 1ds post
            // so set this function to mock dynamic changes
            _self.SetConfig = function (config) {
                try {
                    _onCompleteFuncs = config.senderOnCompleteCallBack || {};
                    _disableCredentials = !!config.disableCredentials;
                    _fetchCredentials = config.fetchCredentials;
                    _isOneDs = !!config.isOneDs;
                    _enableSendPromise = !!config.enableSendPromise;
                    _disableXhr = !!config.disableXhr;
                    _disableBeacon = !!config.disableBeacon;
                    _disableBeaconSync = !!config.disableBeaconSync;
                    _timeoutWrapper = config.timeWrapper;
                    _addNoResponse = !!config.addNoResponse;
                    _disableFetchKeepAlive = !!config.disableFetchKeepAlive;
                    _fallbackInst = { sendPOST: _xhrSender };
                    if (!_isOneDs) {
                        _sendCredentials = false; // for appInsights, set it to false always
                    }
                    if (_disableCredentials) {
                        var location_1 = (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_6__.getLocation)();
                        if (location_1 && location_1.protocol && location_1.protocol[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === "file:") {
                            // Special case where a local html file fails with a CORS error on Chromium browsers
                            _sendCredentials = false;
                        }
                    }
                    return true;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return false;
            };
            _self.getSyncFetchPayload = function () {
                return _syncFetchPayload;
            };
            _self.getSenderInst = function (transports, sync) {
                if (transports && transports[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
                    return _getSenderInterface(transports, sync);
                }
                return null;
            };
            _self.getFallbackInst = function () {
                return _fallbackInst;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] = function (unloadCtx, unloadState) {
                _initDefaults();
            };
            _self.preparePayload = function (callback, zipPayload, payload, isSync) {
                if (!zipPayload || isSync || !payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */]) {
                    // If the request is synchronous, the body is null or undefined or Compression is not supported, we don't need to compress it
                    callback(payload);
                    return;
                }
                try {
                    var csStream = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.getInst)("CompressionStream");
                    if (!(0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(csStream)) {
                        callback(payload);
                        return;
                    }
                    // Create a readable stream from the uint8 data
                    var body = new ReadableStream({
                        start: function (controller) {
                            controller.enqueue((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */]) ? new TextEncoder().encode(payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */]) : payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */]);
                            controller.close();
                        }
                    });
                    var compressedStream = body.pipeThrough(new csStream("gzip"));
                    var reader_1 = compressedStream.getReader();
                    var chunks_1 = [];
                    var totalLength_1 = 0;
                    var callbackCalled_1 = false;
                    // Process each chunk from the compressed stream reader
                    (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.doAwaitResponse)(reader_1.read(), function processChunk(response) {
                        if (!callbackCalled_1 && !response.rejected) {
                            // Process the chunk and continue reading
                            var result = response[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */];
                            if (!result.done) {
                                // Add current chunk and continue reading
                                chunks_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */]);
                                totalLength_1 += result.value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
                                return (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.doAwaitResponse)(reader_1.read(), processChunk);
                            }
                            // We are complete so combine all chunks
                            var combined = new Uint8Array(totalLength_1);
                            var offset = 0;
                            for (var _i = 0, chunks_2 = chunks_1; _i < chunks_2.length; _i++) {
                                var chunk = chunks_2[_i];
                                combined.set(chunk, offset);
                                offset += chunk[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
                            }
                            // Update payload with compressed data
                            payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */] = combined;
                            payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HEADERS /* @min:%2eheaders */]["Content-Encoding"] = "gzip";
                            payload._chunkCount = chunks_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
                        }
                        if (!callbackCalled_1) {
                            // Send the processed payload to the callback, if not already called
                            // If the response was rejected, we will call the callback with the original payload
                            // As it only gets "replaced" if the compression was successful
                            callbackCalled_1 = true;
                            callback(payload);
                        }
                        // We don't need to return anything as this will cause the calling chain to be resolved and closed
                    });
                    // returning the reader to allow the caller to cancel the stream if needed
                    // This is not a requirement but allows for better control over the stream, like if we detect that we are unloading
                    // we could use reader.cancel() to stop the stream and avoid sending the request, but this may still be an asynchronous operation
                    // and may not be possible to cancel the stream in time
                    return reader_1;
                }
                catch (error) {
                    // CompressionStream is not available at all
                    callback(payload);
                    return;
                }
            };
            /**
             * success handler
             */
            function _onSuccess(res, onComplete) {
                _doOnComplete(onComplete, 200, {}, res);
            }
            /**
             * error handler
             */
            function _onError(message, onComplete) {
                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_5__._throwInternal)(_diagLog, 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, "Failed to send telemetry.", { message: message });
                _doOnComplete(onComplete, 400, {});
            }
            function _onNoPayloadUrl(onComplete) {
                _onError("No endpoint url is provided for the batch", onComplete);
            }
            function _getSenderInterface(transports, syncSupport) {
                var transportType = 0 /* TransportType.NotSet */;
                var sendPostFunc = null;
                var lp = 0;
                while (sendPostFunc == null && lp < transports[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
                    transportType = transports[lp];
                    if (!_disableXhr && transportType === 1 /* TransportType.Xhr */) {
                        if ((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_6__.useXDomainRequest)()) {
                            // IE 8 and 9
                            sendPostFunc = _xdrSender;
                        }
                        else if ((0,_EnvUtils__WEBPACK_IMPORTED_MODULE_6__.isXhrSupported)()) {
                            sendPostFunc = _xhrSender;
                        }
                    }
                    else if (transportType === 2 /* TransportType.Fetch */ && (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_6__.isFetchSupported)(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {
                        sendPostFunc = _doFetchSender;
                    }
                    else if (transportType === 3 /* TransportType.Beacon */ && (0,_EnvUtils__WEBPACK_IMPORTED_MODULE_6__.isBeaconsSupported)() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {
                        sendPostFunc = _beaconSender;
                    }
                    lp++;
                }
                if (sendPostFunc) {
                    return {
                        _transport: transportType,
                        _isSync: syncSupport,
                        sendPOST: sendPostFunc
                    };
                }
                return null;
            }
            function _doOnComplete(oncomplete, status, headers, response) {
                try {
                    oncomplete && oncomplete(status, headers, response);
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
            }
            function _doBeaconSend(payload, oncomplete) {
                var nav = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.getNavigator)();
                var url = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_URL_STRING /* @min:%2eurlString */];
                if (!url) {
                    _onNoPayloadUrl(oncomplete);
                    // return true here, because we don't want to retry it with fallback sender
                    return true;
                }
                url = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_URL_STRING /* @min:%2eurlString */] + (_addNoResponse ? _noResponseQs : STR_EMPTY);
                var data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */];
                // Chrome only allows CORS-safelisted values for the sendBeacon data argument
                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283
                // Chrome only allows CORS-safelisted values for the sendBeacon data argument
                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283
                var plainTextBatch = _isOneDs ? data : new Blob([data], { type: "text/plain;charset=UTF-8" });
                // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.
                var queued = nav.sendBeacon(url, plainTextBatch);
                return queued;
            }
            /**
             * Send Beacon API request
             * @param payload - The data payload to be sent.
             * @param sync - not used
             * Note: Beacon API does not support custom headers and we are not able to get
             * appId from the backend for the correct correlation.
             */
            function _beaconSender(payload, oncomplete, sync) {
                var data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */];
                try {
                    if (data) {
                        // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.
                        if (!_doBeaconSend(payload, oncomplete)) {
                            var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;
                            if (onRetry && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(onRetry)) {
                                onRetry(payload, oncomplete, _doBeaconSend);
                            }
                            else {
                                _fallbackInst && _fallbackInst.sendPOST(payload, oncomplete, true);
                                (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_5__._throwInternal)(_diagLog, 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                            }
                        }
                        else {
                            // if can send
                            _onSuccess(STR_EMPTY, oncomplete); // if success, onComplete is called with status code 200
                        }
                    }
                }
                catch (e) {
                    _isOneDs && (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_5__._warnToConsole)(_diagLog, "Failed to send telemetry using sendBeacon API. Ex:" + (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(e));
                    _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY);
                }
                return;
            }
            /**
             * Send XMLHttpRequest
             * @param payload - The data payload to be sent.
             * @param sync - Indicates if the request should be sent synchronously
             */
            function _xhrSender(payload, oncomplete, sync) {
                //let  internalPayload = payload as IInternalPayloadData;
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var headers = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HEADERS /* @min:%2eheaders */] || {};
                if (!sync && _enableSendPromise) {
                    thePromise = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.createPromise)(function (resolve, reject) {
                        resolveFunc = resolve;
                        rejectFunc = reject;
                    });
                }
                if (_isOneDs && sync && payload.disableXhrSync) {
                    sync = false;
                }
                //const xhr = new XMLHttpRequest();
                var endPointUrl = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_URL_STRING /* @min:%2eurlString */];
                if (!endPointUrl) {
                    _onNoPayloadUrl(oncomplete);
                    resolveFunc && resolveFunc(false);
                    return;
                }
                var xhr = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__.openXhr)(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIMEOUT /* @min:%2etimeout */]);
                if (!_isOneDs) {
                    // application/json should NOT add to 1ds post by default
                    xhr.setRequestHeader("Content-type", "application/json");
                }
                (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrForEach)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.objKeys)(headers), function (headerName) {
                    xhr.setRequestHeader(headerName, headers[headerName]);
                });
                xhr.onreadystatechange = function () {
                    if (!_isOneDs) {
                        _doOnReadyFunc(xhr);
                        if (xhr.readyState === 4) {
                            resolveFunc && resolveFunc(true);
                        }
                    }
                };
                xhr.onload = function () {
                    if (_isOneDs) {
                        _doOnReadyFunc(xhr);
                    }
                };
                function _doOnReadyFunc(xhr) {
                    var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;
                    var onReadyFuncExist = onReadyFunc && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(onReadyFunc);
                    if (onReadyFuncExist) {
                        onReadyFunc(xhr, oncomplete, payload);
                    }
                    else {
                        var response = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__.getResponseText)(xhr);
                        _doOnComplete(oncomplete, xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STATUS /* @min:%2estatus */], (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__._getAllResponseHeaders)(xhr, _isOneDs), response);
                    }
                }
                xhr.onerror = function (event) {
                    _doOnComplete(oncomplete, _isOneDs ? xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STATUS /* @min:%2estatus */] : 400, (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__._getAllResponseHeaders)(xhr, _isOneDs), _isOneDs ? STR_EMPTY : (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__.formatErrorMessageXhr)(xhr));
                    rejectFunc && rejectFunc(event);
                };
                xhr.ontimeout = function () {
                    _doOnComplete(oncomplete, _isOneDs ? xhr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STATUS /* @min:%2estatus */] : 500, (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__._getAllResponseHeaders)(xhr, _isOneDs), _isOneDs ? STR_EMPTY : (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__.formatErrorMessageXhr)(xhr));
                    resolveFunc && resolveFunc(false);
                };
                xhr.send(payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */]);
                return thePromise;
            }
            /**
             * Send fetch API request
             * @param payload - The data payload to be sent.
             * @param sync - For fetch this identifies whether we are "unloading" (false) or a normal request
             */
            function _doFetchSender(payload, oncomplete, sync) {
                var _a;
                var endPointUrl = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_URL_STRING /* @min:%2eurlString */];
                var batch = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */];
                var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: "application/json" });
                var thePromise;
                var resolveFunc;
                var rejectFunc;
                var requestHeaders = new Headers();
                var batchLength = batch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
                var ignoreResponse = false;
                var responseHandled = false;
                var headers = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HEADERS /* @min:%2eheaders */] || {};
                //TODO: handle time out for 1ds
                var init = (_a = {
                        method: STR_POST_METHOD,
                        body: plainTextBatch
                    },
                    _a[_Constants__WEBPACK_IMPORTED_MODULE_4__.DisabledPropertyName] = true // Mark so we don't attempt to track this request
                ,
                    _a);
                // Only add headers if there are headers to add, due to issue with some polyfills
                if (payload.headers && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.objKeys)(payload.headers)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.arrForEach)((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.objKeys)(headers), function (headerName) {
                        requestHeaders.append(headerName, headers[headerName]);
                    });
                    init[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HEADERS /* @min:%2eheaders */] = requestHeaders;
                }
                if (_fetchCredentials) { // if user passed in this value via post channel (1ds), then use it
                    init.credentials = _fetchCredentials;
                }
                else if (_sendCredentials && _isOneDs) {
                    // for 1ds, Don't send credentials when URL is file://
                    init.credentials = "include";
                }
                if (sync) {
                    init.keepalive = true;
                    _syncFetchPayload += batchLength;
                    if (_isOneDs) {
                        if (payload["_sendReason"] === 2 /* SendRequestReason.Unload */) {
                            // As a sync request (during unload), it is unlikely that we will get a chance to process the response so
                            // just like beacon send assume that the events have been accepted and processed
                            ignoreResponse = true;
                            if (_addNoResponse) {
                                endPointUrl += _noResponseQs;
                            }
                        }
                    }
                    else {
                        // for appinsights, set to true for all sync request
                        ignoreResponse = true;
                    }
                }
                var request = new Request(endPointUrl, init);
                try {
                    // Also try and tag the request (just in case the value in init is not copied over)
                    request[_Constants__WEBPACK_IMPORTED_MODULE_4__.DisabledPropertyName] = true;
                }
                catch (e) {
                    // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would
                    // cause the request to fail and we no telemetry would be sent
                }
                if (!sync && _enableSendPromise) {
                    thePromise = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.createPromise)(function (resolve, reject) {
                        resolveFunc = resolve;
                        rejectFunc = reject;
                    });
                }
                if (!endPointUrl) {
                    _onNoPayloadUrl(oncomplete);
                    resolveFunc && resolveFunc(false);
                    return;
                }
                function _handleError(res, statusCode) {
                    // In case there is an error in the request. Set the status to 0 for 1ds and 400 for appInsights
                    // so that the events can be retried later.
                    if (statusCode) {
                        _doOnComplete(oncomplete, _isOneDs ? 0 : statusCode, {}, _isOneDs ? STR_EMPTY : res);
                    }
                    else {
                        _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY : res);
                    }
                }
                function _onFetchComplete(response, payload, value) {
                    var status = response[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STATUS /* @min:%2estatus */];
                    var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;
                    if (onCompleteFunc && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(onCompleteFunc)) {
                        onCompleteFunc(response, oncomplete, value || STR_EMPTY, payload);
                    }
                    else {
                        _doOnComplete(oncomplete, status, {}, value || STR_EMPTY);
                    }
                }
                try {
                    (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.doAwaitResponse)(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function (result) {
                        if (sync) {
                            _syncFetchPayload -= batchLength;
                            batchLength = 0;
                        }
                        if (!responseHandled) {
                            responseHandled = true;
                            if (!result.rejected) {
                                var response_1 = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */];
                                try {
                                    /**
                                     * The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500.
                                     * Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure
                                     * or if anything prevented the request from completing.
                                     */
                                    if (!_isOneDs && !response_1.ok) {
                                        // this is for appInsights only
                                        if (response_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STATUS /* @min:%2estatus */]) {
                                            _handleError(response_1.statusText, response_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STATUS /* @min:%2estatus */]);
                                        }
                                        else {
                                            _handleError(response_1.statusText, 499);
                                        }
                                        resolveFunc && resolveFunc(false);
                                    }
                                    else {
                                        if (_isOneDs && !response_1.body) {
                                            _onFetchComplete(response_1, null, STR_EMPTY);
                                            resolveFunc && resolveFunc(true);
                                        }
                                        else {
                                            (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_1__.doAwaitResponse)(response_1.text(), function (resp) {
                                                _onFetchComplete(response_1, payload, resp[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_VALUE /* @min:%2evalue */]);
                                                resolveFunc && resolveFunc(true);
                                            });
                                        }
                                    }
                                }
                                catch (e) {
                                    if (response_1 && response_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STATUS /* @min:%2estatus */]) {
                                        _handleError((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(e), response_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STATUS /* @min:%2estatus */]);
                                    }
                                    else {
                                        _handleError((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(e), 499);
                                    }
                                    rejectFunc && rejectFunc(e);
                                }
                            }
                            else {
                                _handleError(result.reason && result.reason[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */], 499);
                                rejectFunc && rejectFunc(result.reason);
                            }
                        }
                    });
                }
                catch (e) {
                    if (!responseHandled) {
                        _handleError((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.dumpObj)(e), 499);
                        rejectFunc && rejectFunc(e);
                    }
                }
                if (ignoreResponse && !responseHandled) {
                    // Assume success during unload processing as we most likely won't get the response
                    responseHandled = true;
                    _doOnComplete(oncomplete, 200, {});
                    resolveFunc && resolveFunc(true);
                }
                if (_isOneDs && !responseHandled && payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIMEOUT /* @min:%2etimeout */] > 0) {
                    // Simulate timeout
                    _timeoutWrapper && _timeoutWrapper.set(function () {
                        if (!responseHandled) {
                            // Assume a 500 response (which will cause a retry)
                            responseHandled = true;
                            _doOnComplete(oncomplete, 500, {});
                            resolveFunc && resolveFunc(true);
                        }
                    }, payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIMEOUT /* @min:%2etimeout */]);
                }
                return thePromise;
            }
            /**
             * Send XDomainRequest
             * @param payload - The data payload to be sent.
             * @param sync - Indicates if the request should be sent synchronously
             *
             * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added
             * to maintain consistency with the xhrSender's contract
             * Note: XDomainRequest does not support custom headers and we are not able to get
             * appId from the backend for the correct correlation.
             */
            function _xdrSender(payload, oncomplete, sync) {
                // It doesn't support custom headers, so no action is taken with current requestHeaders
                var _window = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.getWindow)();
                var xdr = new XDomainRequest();
                var data = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_DATA /* @min:%2edata */];
                xdr.onload = function () {
                    var response = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__.getResponseText)(xdr);
                    var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;
                    if (onloadFunc && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(onloadFunc)) {
                        onloadFunc(xdr, oncomplete, payload);
                    }
                    else {
                        _doOnComplete(oncomplete, 200, {}, response);
                    }
                };
                xdr.onerror = function () {
                    _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY : (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_7__.formatErrorMessageXdr)(xdr));
                };
                xdr.ontimeout = function () {
                    _doOnComplete(oncomplete, 500, {});
                };
                xdr.onprogress = function () { };
                // XDomainRequest requires the same protocol as the hosting page.
                // If the protocol doesn't match, we can't send the telemetry :(.
                var hostingProtocol = _window && _window.location && _window.location.protocol || "";
                var endpoint = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_URL_STRING /* @min:%2eurlString */];
                if (!endpoint) {
                    _onNoPayloadUrl(oncomplete);
                    return;
                }
                if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {
                    var msg = "Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.";
                    (0,_DiagnosticLogger__WEBPACK_IMPORTED_MODULE_5__._throwInternal)(_diagLog, 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + msg);
                    _onError(msg, oncomplete);
                    return;
                }
                var endpointUrl = _isOneDs ? endpoint : endpoint[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_REPLACE /* @min:%2ereplace */](/^(https?:)/, "");
                xdr.open(STR_POST_METHOD, endpointUrl);
                if (payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIMEOUT /* @min:%2etimeout */]) {
                    xdr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIMEOUT /* @min:%2etimeout */] = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TIMEOUT /* @min:%2etimeout */];
                }
                xdr.send(data);
                if (_isOneDs && sync) {
                    _timeoutWrapper && _timeoutWrapper.set(function () {
                        xdr.send(data);
                    }, 0);
                }
                else {
                    xdr.send(data);
                }
            }
            function _initDefaults() {
                _syncFetchPayload = 0;
                _isInitialized = false;
                _enableSendPromise = false;
                _diagLog = null;
                _isOneDs = null;
                _onCompleteFuncs = null;
                _disableCredentials = null;
                _fetchCredentials = null;
                _fallbackInst = null;
                _disableXhr = false;
                _disableBeacon = false;
                _disableBeaconSync = false;
                _disableFetchKeepAlive = false;
                _addNoResponse = false;
                _timeoutWrapper = null;
            }
        });
    }
// Removed Stub for SenderPostManager.prototype.initialize.
// Removed Stub for SenderPostManager.prototype.getSyncFetchPayload.
// Removed Stub for SenderPostManager.prototype.SetConfig.
// Removed Stub for SenderPostManager.prototype.getSenderInst.
// Removed Stub for SenderPostManager.prototype.getFallbackInst.
// Removed Stub for SenderPostManager.prototype._doTeardown.
// Removed Stub for SenderPostManager.prototype.preparePayload.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    SenderPostManager.__ieDyn=1;

    return SenderPostManager;
}());

//# sourceMappingURL=SenderPostManager.js.map

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __getRegisteredEvents: () => (/* binding */ __getRegisteredEvents),
/* harmony export */   addEventHandler: () => (/* binding */ addEventHandler),
/* harmony export */   addEventListeners: () => (/* binding */ addEventListeners),
/* harmony export */   addPageHideEventListener: () => (/* binding */ addPageHideEventListener),
/* harmony export */   addPageShowEventListener: () => (/* binding */ addPageShowEventListener),
/* harmony export */   addPageUnloadEventListener: () => (/* binding */ addPageUnloadEventListener),
/* harmony export */   attachEvent: () => (/* binding */ attachEvent),
/* harmony export */   detachEvent: () => (/* binding */ detachEvent),
/* harmony export */   eventOff: () => (/* binding */ eventOff),
/* harmony export */   eventOn: () => (/* binding */ eventOn),
/* harmony export */   mergeEvtNamespace: () => (/* binding */ mergeEvtNamespace),
/* harmony export */   removeEventHandler: () => (/* binding */ removeEventHandler),
/* harmony export */   removeEventListeners: () => (/* binding */ removeEventListeners),
/* harmony export */   removePageHideEventListener: () => (/* binding */ removePageHideEventListener),
/* harmony export */   removePageShowEventListener: () => (/* binding */ removePageShowEventListener),
/* harmony export */   removePageUnloadEventListener: () => (/* binding */ removePageUnloadEventListener)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _DataCacheHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






// Added to help with minfication
var strOnPrefix = "on";
var strAttachEvent = "attachEvent";
var strAddEventHelper = "addEventListener";
var strDetachEvent = "detachEvent";
var strRemoveEventListener = "removeEventListener";
var strEvents = "events";
var strVisibilityChangeEvt = "visibilitychange";
var strPageHide = "pagehide";
var strPageShow = "pageshow";
var strUnload = "unload";
var strBeforeUnload = "beforeunload";
var strPageHideNamespace = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_2__.createUniqueNamespace)("aiEvtPageHide");
var strPageShowNamespace = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_2__.createUniqueNamespace)("aiEvtPageShow");
var rRemoveEmptyNs = /\.[\.]+/g;
var rRemoveTrailingEmptyNs = /[\.]+$/;
var _guid = 1;
var elmNodeData = (0,_DataCacheHelper__WEBPACK_IMPORTED_MODULE_2__.createElmNodeData)("events");
var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
function _normalizeNamespace(name) {
    if (name && name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REPLACE /* @min:%2ereplace */]) {
        return name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_REPLACE /* @min:%2ereplace */](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY);
    }
    return name;
}
function _getEvtNamespace(eventName, evtNamespace) {
    if (evtNamespace) {
        var theNamespace_1 = _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY;
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(evtNamespace)) {
            theNamespace_1 = _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY;
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(evtNamespace, function (name) {
                name = _normalizeNamespace(name);
                if (name) {
                    if (name[0] !== ".") {
                        name = "." + name;
                    }
                    theNamespace_1 += name;
                }
            });
        }
        else {
            theNamespace_1 = _normalizeNamespace(evtNamespace);
        }
        if (theNamespace_1) {
            if (theNamespace_1[0] !== ".") {
                theNamespace_1 = "." + theNamespace_1;
            }
            // We may only have the namespace and not an eventName
            eventName = (eventName || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY) + theNamespace_1;
        }
    }
    var parsedEvent = (eventNamespace.exec(eventName || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY) || []);
    return {
        type: parsedEvent[1],
        ns: ((parsedEvent[2] || _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](".").sort()).join(".")
    };
}
/**
 * Get all of the registered events on the target object, this is primarily used for testing cleanup but may also be used by
 * applications to remove their own events
 * @param target - The EventTarget that has registered events
 * @param eventName - [Optional] The name of the event to return the registered handlers and full name (with namespaces)
 * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,
 * if the eventName also includes a namespace the namespace(s) are merged into a single namespace
 */
function __getRegisteredEvents(target, eventName, evtNamespace) {
    var theEvents = [];
    var eventCache = elmNodeData.get(target, strEvents, {}, false);
    var evtName = _getEvtNamespace(eventName, evtNamespace);
    (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(eventCache, function (evtType, registeredEvents) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(registeredEvents, function (value) {
            if (!evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */] || evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */] === value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVT_NAME /* @min:%2eevtName */][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */]) {
                if (!evtName.ns || evtName.ns === evtName.ns) {
                    theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */]({
                        name: value.evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */] + (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVT_NAME /* @min:%2eevtName */].ns ? "." + value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVT_NAME /* @min:%2eevtName */].ns : _InternalConstants__WEBPACK_IMPORTED_MODULE_3__.STR_EMPTY),
                        handler: value.handler
                    });
                }
            }
        });
    });
    return theEvents;
}
// Exported for internal unit testing only
function _getRegisteredEvents(target, evtName, addDefault) {
    if (addDefault === void 0) { addDefault = true; }
    var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
    var registeredEvents = aiEvts[evtName];
    if (!registeredEvents) {
        registeredEvents = aiEvts[evtName] = [];
    }
    return registeredEvents;
}
function _doDetach(obj, evtName, handlerRef, useCapture) {
    if (obj && evtName && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */]) {
        if (obj[strRemoveEventListener]) {
            obj[strRemoveEventListener](evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */], handlerRef, useCapture);
        }
        else if (obj[strDetachEvent]) {
            obj[strDetachEvent](strOnPrefix + evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */], handlerRef);
        }
    }
}
function _doAttach(obj, evtName, handlerRef, useCapture) {
    var result = false;
    if (obj && evtName && evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */] && handlerRef) {
        if (obj[strAddEventHelper]) {
            // all browsers except IE before version 9
            obj[strAddEventHelper](evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */], handlerRef, useCapture);
            result = true;
        }
        else if (obj[strAttachEvent]) {
            // IE before version 9
            obj[strAttachEvent](strOnPrefix + evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */], handlerRef);
            result = true;
        }
    }
    return result;
}
function _doUnregister(target, events, evtName, unRegFn) {
    var idx = events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */];
    while (idx--) {
        var theEvent = events[idx];
        if (theEvent) {
            if (!evtName.ns || evtName.ns === theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVT_NAME /* @min:%2eevtName */].ns) {
                if (!unRegFn || unRegFn(theEvent)) {
                    _doDetach(target, theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EVT_NAME /* @min:%2eevtName */], theEvent.handler, theEvent.capture);
                    // Remove the registered event
                    events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLICE /* @min:%2esplice */](idx, 1);
                }
            }
        }
    }
}
function _unregisterEvents(target, evtName, unRegFn) {
    if (evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */]) {
        _doUnregister(target, _getRegisteredEvents(target, evtName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TYPE /* @min:%2etype */]), evtName, unRegFn);
    }
    else {
        var eventCache = elmNodeData.get(target, strEvents, {});
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(eventCache, function (evtType, events) {
            _doUnregister(target, events, evtName, unRegFn);
        });
        // Cleanup
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.objKeys)(eventCache)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] === 0) {
            elmNodeData.kill(target, strEvents);
        }
    }
}
function mergeEvtNamespace(theNamespace, namespaces) {
    var newNamespaces;
    if (namespaces) {
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(namespaces)) {
            newNamespaces = [theNamespace].concat(namespaces);
        }
        else {
            newNamespaces = [theNamespace, namespaces];
        }
        // resort the namespaces so they are always in order
        newNamespaces = (_getEvtNamespace("xx", newNamespaces).ns)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SPLIT /* @min:%2esplit */](".");
    }
    else {
        newNamespaces = theNamespace;
    }
    return newNamespaces;
}
/**
 * Binds the specified function to an event, so that the function gets called whenever the event fires on the object
 * @param obj - Object to add the event too.
 * @param eventName - String that specifies any of the standard DHTML Events without "on" prefix, if may also include an optional (dot "." prefixed)
 * namespaces "click" "click.mynamespace" in addition to specific namespaces.
 * @param handlerRef - Pointer that specifies the function to call when event fires
 * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,
 * if the eventName also includes a namespace the namespace(s) are merged into a single namespace
 * @param useCapture - [Optional] Defaults to false
 * @returns True if the function was bound successfully to the event, otherwise false
 */
function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    var result = false;
    if (target) {
        try {
            var evtName = _getEvtNamespace(eventName, evtNamespace);
            result = _doAttach(target, evtName, handlerRef, useCapture);
            if (result && elmNodeData.accept(target)) {
                var registeredEvent = {
                    guid: _guid++,
                    evtName: evtName,
                    handler: handlerRef,
                    capture: useCapture
                };
                _getRegisteredEvents(target, evtName.type)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PUSH /* @min:%2epush */](registeredEvent);
            }
        }
        catch (e) {
            // Just Ignore any error so that we don't break any execution path
        }
    }
    return result;
}
/**
 * Removes an event handler for the specified event
 * @param Object - to remove the event from
 * @param eventName - The name of the event, with optional namespaces or just the namespaces,
 * such as "click", "click.mynamespace" or ".mynamespace"
 * @param handlerRef - The callback function that needs to be removed from the given event, when using a
 * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers
 * otherwise this will only remove events with this specific handler.
 * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,
 * if the eventName also includes a namespace the namespace(s) are merged into a single namespace
 * @param useCapture - [Optional] Defaults to false
 */
function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    if (target) {
        try {
            var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
            var found_1 = false;
            _unregisterEvents(target, evtName_1, function (regEvent) {
                if ((evtName_1.ns && !handlerRef) || regEvent.handler === handlerRef) {
                    found_1 = true;
                    return true;
                }
                return false;
            });
            if (!found_1) {
                // fallback to try and remove as requested
                _doDetach(target, evtName_1, handlerRef, useCapture);
            }
        }
        catch (e) {
            // Just Ignore any error so that we don't break any execution path
        }
    }
}
/**
 * Binds the specified function to an event, so that the function gets called whenever the event fires on the object
 * @param obj - Object to add the event too.
 * @param eventNameWithoutOn - String that specifies any of the standard DHTML Events without "on" prefix and optional (dot "." prefixed) namespaces "click" "click.mynamespace".
 * @param handlerRef - Pointer that specifies the function to call when event fires
 * @param useCapture - [Optional] Defaults to false
 * @returns True if the function was bound successfully to the event, otherwise false
 */
function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    return eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);
}
/**
 * Removes an event handler for the specified event
 * @param Object - to remove the event from
 * @param eventNameWithoutOn  - The name of the event, with optional namespaces or just the namespaces,
 * such as "click", "click.mynamespace" or ".mynamespace"
 * @param handlerRef - The callback function that needs to be removed from the given event, when using a
 * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers
 * otherwise this will only remove events with this specific handler.
 * @param useCapture - [Optional] Defaults to false
 */
function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
    if (useCapture === void 0) { useCapture = false; }
    eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);
}
/**
 * Trys to add an event handler for the specified event to the window, body and document
 * @param eventName  - The name of the event
 * @param callback  - The callback function that needs to be executed for the given event
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 * @returns - true if the handler was successfully added
 */
function addEventHandler(eventName, callback, evtNamespace) {
    var result = false;
    var w = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (w) {
        result = eventOn(w, eventName, callback, evtNamespace);
        result = eventOn(w["body"], eventName, callback, evtNamespace) || result;
    }
    var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    if (doc) {
        result = eventOn(doc, eventName, callback, evtNamespace) || result;
    }
    return result;
}
/**
 * Trys to remove event handler(s) for the specified event/namespace to the window, body and document
 * @param eventName - The name of the event, with optional namespaces or just the namespaces,
 * such as "click", "click.mynamespace" or ".mynamespace"
 * @param callback - The callback function that needs to be removed from the given event, when using a
 * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers
 * otherwise this will only remove events with this specific handler.
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 */
function removeEventHandler(eventName, callback, evtNamespace) {
    var w = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
    if (w) {
        eventOff(w, eventName, callback, evtNamespace);
        eventOff(w["body"], eventName, callback, evtNamespace);
    }
    var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    if (doc) {
        eventOff(doc, eventName, callback, evtNamespace);
    }
}
/**
 * Bind the listener to the array of events
 * @param events - An string array of event names to bind the listener to
 * @param listener - The event callback to call when the event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 * @returns true - when at least one of the events was registered otherwise false
 */
function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
    var added = false;
    if (listener && events && events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(events, function (name) {
            if (name) {
                if (!excludeEvents || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(excludeEvents, name) === -1) {
                    added = addEventHandler(name, listener, evtNamespace) || added;
                }
            }
        });
    }
    return added;
}
/**
 * Bind the listener to the array of events
 * @param events - An string array of event names to bind the listener to
 * @param listener - The event callback to call when the event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 * @returns true - when at least one of the events was registered otherwise false
 */
function addEventListeners(events, listener, excludeEvents, evtNamespace) {
    var added = false;
    if (listener && events && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(events)) {
        added = _addEventListeners(events, listener, excludeEvents, evtNamespace);
        if (!added && excludeEvents && excludeEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
            // Failed to add any listeners and we excluded some, so just attempt to add the excluded events
            added = _addEventListeners(events, listener, null, evtNamespace);
        }
    }
    return added;
}
/**
 * Remove the listener from the array of events
 * @param events - An string array of event names to bind the listener to
 * @param listener - The event callback to call when the event is triggered
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 */
function removeEventListeners(events, listener, evtNamespace) {
    if (events && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(events)) {
        (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(events, function (name) {
            if (name) {
                removeEventHandler(name, listener, evtNamespace);
            }
        });
    }
}
/**
 * Listen to the 'beforeunload', 'unload' and 'pagehide' events which indicates a page unload is occurring,
 * this does NOT listen to the 'visibilitychange' event as while it does indicate that the page is being hidden
 * it does not *necessarily* mean that the page is being completely unloaded, it can mean that the user is
 * just navigating to a different Tab and may come back (without unloading the page). As such you may also
 * need to listen to the 'addPageHideEventListener' and 'addPageShowEventListener' events.
 * @param listener - The event callback to call when a page unload event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked, unless no other events can be.
 * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.
 * @returns true - when at least one of the events was registered otherwise false
 */
function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
    // Hook the unload event for the document, window and body to ensure that the client events are flushed to the server
    // As just hooking the window does not always fire (on chrome) for page navigation's.
    return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);
}
/**
 * Remove any matching 'beforeunload', 'unload' and 'pagehide' events that may have been added via addEventListener,
 * addEventListeners, addPageUnloadEventListener or addPageHideEventListener.
 * @param listener - The specific event callback to to be removed
 * @param evtNamespace - [Optional] Namespace(s) uniquely identified and removed based on this namespace.
 * @returns true - when at least one of the events was registered otherwise false
 */
function removePageUnloadEventListener(listener, evtNamespace) {
    removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);
}
/**
 * Listen to the pagehide and visibility changing to 'hidden' events, because the 'visibilitychange' uses
 * an internal proxy to detect the visibility state you SHOULD use a unique namespace when if you plan to call
 * removePageShowEventListener as the remove ignores the listener argument for the 'visibilitychange' event.
 * @param listener - The event callback to call when a page hide event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.
 * @param evtNamespace - [Optional] A Namespace to append to the event listeners so they can be uniquely identified and removed
 * based on this namespace. This call also adds an additional unique "pageshow" namespace to the events
 * so that only the matching "removePageHideEventListener" can remove these events.
 * Suggestion: pass as true if you are also calling addPageUnloadEventListener as that also hooks pagehide
 * @returns true - when at least one of the events was registered otherwise false
 */
function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
    function _handlePageVisibility(evt) {
        var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
        if (listener && doc && doc.visibilityState === "hidden") {
            listener(evt);
        }
    }
    // add the unique page show namespace to any provided namespace so we can only remove the ones added by "pagehide"
    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
    var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);
    if (!excludeEvents || (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(excludeEvents, strVisibilityChangeEvt) === -1) {
        pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;
    }
    if (!pageUnloadAdded && excludeEvents) {
        // Failed to add any listeners and we where requested to exclude some, so just call again without excluding anything
        pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);
    }
    return pageUnloadAdded;
}
/**
 * Removes the pageHide event listeners added by addPageHideEventListener, because the 'visibilitychange' uses
 * an internal proxy to detect the visibility state you SHOULD use a unique namespace when calling addPageHideEventListener
 * as the remove ignores the listener argument for the 'visibilitychange' event.
 * @param listener - The specific listener to remove for the 'pageshow' event only (ignored for 'visibilitychange')
 * @param evtNamespace - The unique namespace used when calling addPageShowEventListener
 */
function removePageHideEventListener(listener, evtNamespace) {
    // add the unique page show namespace to any provided namespace so we only remove the ones added by "pagehide"
    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
    removeEventListeners([strPageHide], listener, newNamespaces);
    removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
}
/**
 * Listen to the pageshow and visibility changing to 'visible' events, because the 'visibilitychange' uses
 * an internal proxy to detect the visibility state you SHOULD use a unique namespace when if you plan to call
 * removePageShowEventListener as the remove ignores the listener argument for the 'visibilitychange' event.
 * @param listener - The event callback to call when a page is show event is triggered
 * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.
 * @param evtNamespace - [Optional/Recommended] A Namespace to append to the event listeners so they can be uniquely
 * identified and removed based on this namespace. This call also adds an additional unique "pageshow" namespace to the events
 * so that only the matching "removePageShowEventListener" can remove these events.
 * @returns true - when at least one of the events was registered otherwise false
 */
function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
    function _handlePageVisibility(evt) {
        var doc = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
        if (listener && doc && doc.visibilityState === "visible") {
            listener(evt);
        }
    }
    // add the unique page show namespace to any provided namespace so we can only remove the ones added by "pageshow"
    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
    var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);
    pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;
    if (!pageShowAdded && excludeEvents) {
        // Failed to add any listeners and we where requested to exclude some, so just call again without excluding anything
        pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);
    }
    return pageShowAdded;
}
/**
 * Removes the pageShow event listeners added by addPageShowEventListener, because the 'visibilitychange' uses
 * an internal proxy to detect the visibility state you SHOULD use a unique namespace when calling addPageShowEventListener
 * as the remove ignores the listener argument for the 'visibilitychange' event.
 * @param listener - The specific listener to remove for the 'pageshow' event only (ignored for 'visibilitychange')
 * @param evtNamespace - The unique namespace used when calling addPageShowEventListener
 */
function removePageShowEventListener(listener, evtNamespace) {
    // add the unique page show namespace to any provided namespace so we only remove the ones added by "pageshow"
    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
    removeEventListeners([strPageShow], listener, newNamespaces);
    removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
}
//# sourceMappingURL=EventHelpers.js.map

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LoggingSeverity: () => (/* binding */ LoggingSeverity)
/* harmony export */ });
/* harmony import */ var _JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/*
 * Application Insights JavaScript SDK - Core, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


//  @skip-file-minify

var LoggingSeverity = ( /* @__PURE__ */(0,_JavaScriptSDK_Enums_EnumHelperFuncs__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    DISABLED: 0 /* eLoggingSeverity.DISABLED */,
    CRITICAL: 1 /* eLoggingSeverity.CRITICAL */,
    WARNING: 2 /* eLoggingSeverity.WARNING */,
    DEBUG: 3 /* eLoggingSeverity.DEBUG */
}));
//# sourceMappingURL=LoggingEnums.js.map

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BE_PROFILE: () => (/* reexport safe */ _DataModels__WEBPACK_IMPORTED_MODULE_0__.BE_PROFILE),
/* harmony export */   NRT_PROFILE: () => (/* reexport safe */ _DataModels__WEBPACK_IMPORTED_MODULE_0__.NRT_PROFILE),
/* harmony export */   PostChannel: () => (/* reexport safe */ _PostChannel__WEBPACK_IMPORTED_MODULE_1__.PostChannel),
/* harmony export */   RT_PROFILE: () => (/* reexport safe */ _DataModels__WEBPACK_IMPORTED_MODULE_0__.RT_PROFILE)
/* harmony export */ });
/* harmony import */ var _DataModels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/* harmony import */ var _PostChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* @name Index.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
* File to export public classes.
*/



//# sourceMappingURL=Index.js.map

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BE_PROFILE: () => (/* binding */ BE_PROFILE),
/* harmony export */   NRT_PROFILE: () => (/* binding */ NRT_PROFILE),
/* harmony export */   RT_PROFILE: () => (/* binding */ RT_PROFILE)
/* harmony export */ });
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
 * Real Time profile (default profile). RealTime Latency events are sent every 1 sec and
 * Normal Latency events are sent every 2 sec.
 */
var RT_PROFILE = "REAL_TIME";
/**
 * Near Real Time profile. RealTime Latency events are sent every 3 sec and
 * Normal Latency events are sent every 6 sec.
 */
var NRT_PROFILE = "NEAR_REAL_TIME";
/**
 * Best Effort. RealTime Latency events are sent every 9 sec and
 * Normal Latency events are sent every 18 sec.
 */
var BE_PROFILE = "BEST_EFFORT";
//# sourceMappingURL=DataModels.js.map

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PostChannel: () => (/* binding */ PostChannel)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(61);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(43);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(40);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(44);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(22);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(21);
/* harmony import */ var _DataModels__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(64);
/* harmony import */ var _EventBatch__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(66);
/* harmony import */ var _HttpManager__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(69);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(67);
/* harmony import */ var _RetryPolicy__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(72);
/* harmony import */ var _TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(74);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(68);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

/**
* PostManager.ts
* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)
* @copyright Microsoft 2018-2020
*/











var FlushCheckTimer = 0.250; // This needs to be in seconds, so this is 250ms
var MaxNumberEventPerBatch = 500;
var EventsDroppedAtOneTime = 20;
var MaxSendAttempts = 6;
var MaxSyncUnloadSendAttempts = 2; // Assuming 2 based on beforeunload and unload
var MaxBackoffCount = 4;
var MaxConnections = 2;
var MaxRequestRetriesBeforeBackoff = 1;
var MaxEventsLimitInMem = 10000;
var strEventsDiscarded = "eventsDiscarded";
var EMPTY_STR = "";
var undefValue = undefined;
/**
 * The default settings for the config.
 * WE MUST include all defaults here to ensure that the config is created with all of the properties
 * defined as dynamic.
 */
var defaultPostChannelConfig = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.objDeepFreeze)({
    eventsLimitInMem: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.isGreaterThanZero, v: MaxEventsLimitInMem },
    immediateEventLimit: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.isGreaterThanZero, v: 500 },
    autoFlushEventsLimit: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.isGreaterThanZero, v: 0 },
    disableAutoBatchFlushLimit: false,
    httpXHROverride: { isVal: isOverrideFn, v: undefValue },
    overrideInstrumentationKey: undefValue,
    overrideEndpointUrl: undefValue,
    disableTelemetry: false,
    ignoreMc1Ms0CookieProcessing: false,
    setTimeoutOverride: undefValue,
    clearTimeoutOverride: undefValue,
    payloadPreprocessor: undefValue,
    payloadListener: undefValue,
    disableEventTimings: undefValue,
    valueSanitizer: undefValue,
    stringifyObjects: undefValue,
    enableCompoundKey: undefValue,
    disableOptimizeObj: false,
    fetchCredentials: undefValue,
    // disableCacheHeader: undefValue, // See Task #7178858 - Collector requires a change to support this
    transports: undefValue,
    unloadTransports: undefValue,
    useSendBeacon: undefValue,
    disableFetchKeepAlive: undefValue,
    avoidOptions: false,
    xhrTimeout: undefValue,
    disableXhrSync: undefValue,
    alwaysUseXhrOverride: false,
    maxEventRetryAttempts: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isNumber, v: MaxSendAttempts },
    maxUnloadEventRetryAttempts: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isNumber, v: MaxSyncUnloadSendAttempts },
    addNoResponse: undefValue,
    maxEvtPerBatch: { isVal: _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isNumber, v: MaxNumberEventPerBatch },
    excludeCsMetaData: undefValue,
    requestLimit: {}
});
function isOverrideFn(httpXHROverride) {
    return httpXHROverride && httpXHROverride.sendPOST;
}
/**
 * Class that manages adding events to inbound queues and batching of events
 * into requests.
 * @group Classes
 * @group Entrypoint
 */
var PostChannel = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__extendsFn)(PostChannel, _super);
    function PostChannel() {
        var _this = _super.call(this) || this;
        _this.identifier = "PostChannel";
        _this.priority = 1011;
        _this.version = '4.3.11';
        var _postConfig;
        var _isTeardownCalled = false;
        var _flushCallbackQueue = [];
        var _flushCallbackTimer;
        var _paused = false;
        var _immediateQueueSize = 0;
        var _immediateQueueSizeLimit;
        var _queueSize = 0;
        var _queueSizeLimit;
        var _profiles = {};
        var _currentProfile = _DataModels__WEBPACK_IMPORTED_MODULE_14__.RT_PROFILE;
        var _scheduledTimer;
        var _immediateTimer;
        var _currentBackoffCount;
        var _timerCount;
        var _httpManager;
        var _batchQueues;
        var _autoFlushEventsLimit;
        // either MaxBatchSize * (1+ Max Connections) or _queueLimit / 6 (where 3 latency Queues [normal, realtime, cost deferred] * 2 [allow half full -- allow for retry])
        var _autoFlushBatchLimit;
        var _delayedBatchSendLatency;
        var _delayedBatchReason;
        var _optimizeObject;
        var _isPageUnloadTriggered;
        var _maxEventSendAttempts;
        var _maxUnloadEventSendAttempts;
        var _evtNamespace;
        var _timeoutWrapper;
        var _ignoreMc1Ms0CookieProcessing;
        var _disableAutoBatchFlushLimit;
        var _notificationManager;
        var _unloadHandlersAdded;
        var _overrideInstrumentationKey;
        var _disableTelemetry;
        var _maxEvtPerBatch;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(PostChannel, _this, function (_self, _base) {
            _initDefaults();
            // Special internal method to allow the DebugPlugin to hook embedded objects
            _self["_getDbgPlgTargets"] = function () {
                return [_httpManager, _postConfig];
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_INITIALIZE /* @min:%2einitialize */] = function (theConfig, core, extensions) {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__.doPerf)(core, function () { return "PostChannel:initialize"; }, function () {
                    _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_INITIALIZE /* @min:%2einitialize */](theConfig, core, extensions);
                    _notificationManager = core.getNotifyMgr();
                    try {
                        _evtNamespace = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.mergeEvtNamespace)((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_11__.createUniqueNamespace)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_IDENTIFIER /* @min:%2eidentifier */]), core.evtNamespace && core.evtNamespace());
                        _self._addHook((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_12__.onConfigChange)(theConfig, function (details) {
                            var coreConfig = details.cfg;
                            var ctx = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_10__.createProcessTelemetryContext)(null, coreConfig, core);
                            _postConfig = ctx.getExtCfg(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_IDENTIFIER /* @min:%2eidentifier */], defaultPostChannelConfig);
                            _timeoutWrapper = (0,_TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_19__.createTimeoutWrapper)(_postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SET_TIMEOUT_OVERRIDE /* @min:%2esetTimeoutOverride */], _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_CLEAR_TIMEOUT_OVERRI3 /* @min:%2eclearTimeoutOverride */]);
                            // Only try and use the optimizeObject() if this appears to be a chromium based browser and it has not been explicitly disabled
                            _optimizeObject = !_postConfig.disableOptimizeObj && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.isChromium)();
                            _ignoreMc1Ms0CookieProcessing = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_IGNORE_MC1_MS0_COOKI13 /* @min:%2eignoreMc1Ms0CookieProcessing */];
                            _hookWParam(core); // _hookWParam uses _ignoreMc1Ms0CookieProcessing
                            _queueSizeLimit = _postConfig.eventsLimitInMem;
                            _immediateQueueSizeLimit = _postConfig.immediateEventLimit;
                            _autoFlushEventsLimit = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_AUTO_FLUSH_EVENTS_LI14 /* @min:%2eautoFlushEventsLimit */];
                            _maxEventSendAttempts = _postConfig.maxEventRetryAttempts;
                            _maxUnloadEventSendAttempts = _postConfig.maxUnloadEventRetryAttempts;
                            _disableAutoBatchFlushLimit = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_DISABLE_AUTO_BATCH_F15 /* @min:%2edisableAutoBatchFlushLimit */];
                            _maxEvtPerBatch = _postConfig.maxEvtPerBatch;
                            if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isPromiseLike)(coreConfig.endpointUrl)) {
                                _self.pause();
                            }
                            else if (!!_paused) {
                                // if previous url is promise, resume
                                _self.resume();
                            }
                            _setAutoLimits();
                            // Override iKey if provided in Post config if provided for during initialization
                            _overrideInstrumentationKey = _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_OVERRIDE_INSTRUMENTA16 /* @min:%2eoverrideInstrumentationKey */];
                            // DisableTelemetry was defined in the config provided during initialization
                            _disableTelemetry = !!_postConfig.disableTelemetry;
                            if (_unloadHandlersAdded) {
                                _removeUnloadHandlers();
                            }
                            var excludePageUnloadEvents = coreConfig.disablePageUnloadEvents || [];
                            // When running in Web browsers try to send all telemetry if page is unloaded
                            _unloadHandlersAdded = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.addPageUnloadEventListener)(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace);
                            _unloadHandlersAdded = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.addPageHideEventListener)(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace) || _unloadHandlersAdded;
                            _unloadHandlersAdded = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.addPageShowEventListener)(_handleShowEvents, coreConfig.disablePageShowEvents, _evtNamespace) || _unloadHandlersAdded;
                        }));
                        // only initialize the manager once
                        _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_INITIALIZE /* @min:%2einitialize */](theConfig, _self.core, _self);
                    }
                    catch (e) {
                        // resetting the initialized state because of failure
                        _self.setInitialized(false);
                        throw e;
                    }
                }, function () { return ({ theConfig: theConfig, core: core, extensions: extensions }); });
            };
            _self.processTelemetry = function (ev, itemCtx) {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.setProcessTelemetryTimings)(ev, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_IDENTIFIER /* @min:%2eidentifier */]);
                itemCtx = itemCtx || _self._getTelCtx(itemCtx);
                var event = ev;
                if (!_disableTelemetry && !_isTeardownCalled) {
                    // Override iKey if provided in Post config if provided for during initialization
                    if (_overrideInstrumentationKey) {
                        event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_I_KEY /* @min:%2eiKey */] = _overrideInstrumentationKey;
                    }
                    _addEventToQueues(event, true);
                    if (_isPageUnloadTriggered) {
                        // Unload event has been received so we need to try and flush new events
                        _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
                    }
                    else {
                        _scheduleTimer();
                    }
                }
                _self.processNext(event, itemCtx);
            };
            _self.getOfflineSupport = function () {
                try {
                    var details_1 = _httpManager && _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_GET_OFFLINE_REQUEST_9 /* @min:%2egetOfflineRequestDetails */]();
                    if (_httpManager) {
                        return {
                            getUrl: function () {
                                if (details_1) {
                                    return details_1.url;
                                }
                                return null;
                            },
                            serialize: _serialize,
                            batch: _batch,
                            shouldProcess: function (evt) {
                                return !_disableTelemetry;
                            },
                            createPayload: function (evt) {
                                return null;
                            },
                            createOneDSPayload: function (evts) {
                                if (_httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_CREATE_ONE_DSPAYLOAD /* @min:%2ecreateOneDSPayload */]) {
                                    return _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_CREATE_ONE_DSPAYLOAD /* @min:%2ecreateOneDSPayload */](evts, _optimizeObject);
                                }
                            }
                        };
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            };
            _self._doTeardown = function (unloadCtx, unloadState) {
                _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
                _isTeardownCalled = true;
                _httpManager.teardown();
                _removeUnloadHandlers();
                // Just register to remove all events associated with this namespace
                _initDefaults();
            };
            function _removeUnloadHandlers() {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.removePageUnloadEventListener)(null, _evtNamespace);
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.removePageHideEventListener)(null, _evtNamespace);
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.removePageShowEventListener)(null, _evtNamespace);
            }
            function _hookWParam(core) {
                var existingGetWParamMethod = core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_GET_WPARAM /* @min:%2egetWParam */];
                core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_GET_WPARAM /* @min:%2egetWParam */] = function () {
                    var wparam = 0;
                    if (_ignoreMc1Ms0CookieProcessing) {
                        wparam = wparam | 2;
                    }
                    return wparam | existingGetWParamMethod.call(core);
                };
            }
            function _batch(arr) {
                var rlt = EMPTY_STR;
                if (arr && arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */]) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.arrForEach)(arr, function (item) {
                        if (rlt) {
                            rlt += "\n";
                        }
                        rlt += item;
                    });
                }
                return rlt;
            }
            function _serialize(event) {
                var rlt = EMPTY_STR;
                try {
                    _cleanEvent(event);
                    rlt = _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SERIALIZE_OFFLINE_EV8 /* @min:%2eserializeOfflineEvt */](event);
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return rlt;
            }
            // Moving event handlers out from the initialize closure so that any local variables can be garbage collected
            function _handleUnloadEvents(evt) {
                var theEvt = evt || (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.getWindow)().event; // IE 8 does not pass the event
                if (theEvt.type !== "beforeunload") {
                    // Only set the unload trigger if not beforeunload event as beforeunload can be cancelled while the other events can't
                    _isPageUnloadTriggered = true;
                    _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SET_UNLOADING /* @min:%2esetUnloading */](_isPageUnloadTriggered);
                }
                _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
            }
            function _handleShowEvents(evt) {
                // Handle the page becoming visible again
                _isPageUnloadTriggered = false;
                _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SET_UNLOADING /* @min:%2esetUnloading */](_isPageUnloadTriggered);
            }
            function _cleanEvent(event) {
                if (event.ext && event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_TRACE]) {
                    delete (event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_TRACE]);
                }
                if (event.ext && event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_USER] && event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_USER]["id"]) {
                    delete (event.ext[_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_USER]["id"]);
                }
                // v8 performance optimization for iterating over the keys
                if (_optimizeObject) {
                    event.ext = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.optimizeObject)(event.ext);
                    if (event.baseData) {
                        event.baseData = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.optimizeObject)(event.baseData);
                    }
                    if (event.data) {
                        event.data = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.optimizeObject)(event.data);
                    }
                }
            }
            function _addEventToQueues(event, append) {
                // If send attempt field is undefined we should set it to 0.
                if (!event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SEND_ATTEMPT /* @min:%2esendAttempt */]) {
                    event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SEND_ATTEMPT /* @min:%2esendAttempt */] = 0;
                }
                // Add default latency
                if (!event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LATENCY /* @min:%2elatency */]) {
                    event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LATENCY /* @min:%2elatency */] = 1 /* EventLatencyValue.Normal */;
                }
                _cleanEvent(event);
                if (event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SYNC /* @min:%2esync */]) {
                    // If the transmission is backed off then do not send synchronous events.
                    // We will convert these events to Real time latency instead.
                    if (_currentBackoffCount || _paused) {
                        event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LATENCY /* @min:%2elatency */] = 3 /* EventLatencyValue.RealTime */;
                        event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SYNC /* @min:%2esync */] = false;
                    }
                    else {
                        // Log the event synchronously
                        if (_httpManager) {
                            // v8 performance optimization for iterating over the keys
                            if (_optimizeObject) {
                                event = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.optimizeObject)(event);
                            }
                            _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SEND_SYNCHRONOUS_BAT10 /* @min:%2esendSynchronousBatch */](_EventBatch__WEBPACK_IMPORTED_MODULE_15__.EventBatch.create(event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_I_KEY /* @min:%2eiKey */], [event]), event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SYNC /* @min:%2esync */] === true ? 1 /* EventSendType.Synchronous */ : event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SYNC /* @min:%2esync */], 3 /* SendRequestReason.SyncEvent */);
                            return;
                        }
                    }
                }
                var evtLatency = event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LATENCY /* @min:%2elatency */];
                var queueSize = _queueSize;
                var queueLimit = _queueSizeLimit;
                if (evtLatency === 4 /* EventLatencyValue.Immediate */) {
                    queueSize = _immediateQueueSize;
                    queueLimit = _immediateQueueSizeLimit;
                }
                var eventDropped = false;
                // Only add the event if the queue isn't full or it's a direct event (which don't add to the queue sizes)
                if (queueSize < queueLimit) {
                    eventDropped = !_addEventToProperQueue(event, append);
                }
                else {
                    var dropLatency = 1 /* EventLatencyValue.Normal */;
                    var dropNumber = EventsDroppedAtOneTime;
                    if (evtLatency === 4 /* EventLatencyValue.Immediate */) {
                        // Only drop other immediate events as they are not technically sharing the general queue
                        dropLatency = 4 /* EventLatencyValue.Immediate */;
                        dropNumber = 1;
                    }
                    // Drop old event from lower or equal latency
                    eventDropped = true;
                    if (_dropEventWithLatencyOrLess(event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_I_KEY /* @min:%2eiKey */], event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LATENCY /* @min:%2elatency */], dropLatency, dropNumber)) {
                        eventDropped = !_addEventToProperQueue(event, append);
                    }
                }
                if (eventDropped) {
                    // Can't drop events from current queues because the all the slots are taken by queues that are being flushed.
                    _notifyEvents(strEventsDiscarded, [event], _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.EventsDiscardedReason.QueueFull);
                }
            }
            _self.setEventQueueLimits = function (eventLimit, autoFlushLimit) {
                _postConfig.eventsLimitInMem = _queueSizeLimit = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.isGreaterThanZero)(eventLimit) ? eventLimit : MaxEventsLimitInMem;
                _postConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_AUTO_FLUSH_EVENTS_LI14 /* @min:%2eautoFlushEventsLimit */] = _autoFlushEventsLimit = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.isGreaterThanZero)(autoFlushLimit) ? autoFlushLimit : 0;
                _setAutoLimits();
                // We only do this check here as during normal event addition if the queue is > then events start getting dropped
                var doFlush = _queueSize > eventLimit;
                if (!doFlush && _autoFlushBatchLimit > 0) {
                    // Check the auto flush max batch size
                    for (var latency = 1 /* EventLatencyValue.Normal */; !doFlush && latency <= 3 /* EventLatencyValue.RealTime */; latency++) {
                        var batchQueue = _batchQueues[latency];
                        if (batchQueue && batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_BATCHES /* @min:%2ebatches */]) {
                            (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.arrForEach)(batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                                if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]() >= _autoFlushBatchLimit) {
                                    // If any 1 batch is > than the limit then trigger an auto flush
                                    doFlush = true;
                                }
                            });
                        }
                    }
                }
                _performAutoFlush(true, doFlush);
            };
            _self.pause = function () {
                _clearScheduledTimer();
                _paused = true;
                _httpManager && _httpManager.pause();
            };
            _self.resume = function () {
                _paused = false;
                _httpManager && _httpManager.resume();
                _scheduleTimer();
            };
            _self._loadTransmitProfiles = function (profiles) {
                _resetTransmitProfiles();
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.objForEachKey)(profiles, function (profileName, profileValue) {
                    var profLen = profileValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */];
                    if (profLen >= 2) {
                        var directValue = (profLen > 2 ? profileValue[2] : 0);
                        profileValue.splice(0, profLen - 2);
                        // Make sure if a higher latency is set to not send then don't send lower latency
                        if (profileValue[1] < 0) {
                            profileValue[0] = -1;
                        }
                        // Make sure each latency is multiple of the latency higher then it. If not a multiple
                        // we round up so that it becomes a multiple.
                        if (profileValue[1] > 0 && profileValue[0] > 0) {
                            var timerMultiplier = profileValue[0] / profileValue[1];
                            profileValue[0] = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.mathCeil)(timerMultiplier) * profileValue[1];
                        }
                        // Add back the direct profile timeout
                        if (directValue >= 0 && profileValue[1] >= 0 && directValue > profileValue[1]) {
                            // Make sure if it's not disabled (< 0) then make sure it's not larger than RealTime
                            directValue = profileValue[1];
                        }
                        profileValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_PUSH /* @min:%2epush */](directValue);
                        _profiles[profileName] = profileValue;
                    }
                });
            };
            _self.flush = function (isAsync, callback, sendReason) {
                if (isAsync === void 0) { isAsync = true; }
                var result;
                if (!_paused) {
                    sendReason = sendReason || 1 /* SendRequestReason.ManualFlush */;
                    if (isAsync) {
                        if (!callback) {
                            result = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_13__.createPromise)(function (resolve) {
                                // Set the callback to the promise resolve callback
                                callback = resolve;
                            });
                        }
                        if (_flushCallbackTimer == null) {
                            // Clear the normal schedule timer as we are going to try and flush ASAP
                            _clearScheduledTimer();
                            // Move all queued events to the HttpManager so that we don't discard new events (Auto flush scenario)
                            _queueBatches(1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, sendReason);
                            _flushCallbackTimer = _createTimer(function () {
                                _flushCallbackTimer = null;
                                _flushImpl(callback, sendReason);
                            }, 0);
                        }
                        else {
                            // Even if null (no callback) this will ensure after the flushImpl finishes waiting
                            // for a completely idle connection it will attempt to re-flush any queued events on the next cycle
                            _flushCallbackQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_PUSH /* @min:%2epush */](callback);
                        }
                    }
                    else {
                        // Clear the normal schedule timer as we are going to try and flush ASAP
                        var cleared = _clearScheduledTimer();
                        // Now cause all queued events to be sent synchronously
                        _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, 1 /* EventSendType.Synchronous */, sendReason);
                        callback && callback();
                        if (cleared) {
                            // restart the normal event timer if it was cleared
                            _scheduleTimer();
                        }
                    }
                }
                return result;
            };
            _self.setMsaAuthTicket = function (ticket) {
                _httpManager.addHeader(_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_MSA_DEVICE_TICKET, ticket);
            };
            _self.setAuthPluginHeader = function (token) {
                _httpManager.addHeader(_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_AUTH_WEB_TOKEN, token);
            };
            _self.removeAuthPluginHeader = function () {
                _httpManager.removeHeader(_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_AUTH_WEB_TOKEN);
            };
            _self.hasEvents = _hasEvents;
            _self._setTransmitProfile = function (profileName) {
                if (_currentProfile !== profileName && _profiles[profileName] !== undefined) {
                    _clearScheduledTimer();
                    _currentProfile = profileName;
                    _scheduleTimer();
                }
            };
            (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.proxyFunctions)(_self, function () { return _httpManager; }, ["addResponseHandler"]);
            /**
             * Batch and send events currently in the queue for the given latency.
             * @param latency - Latency for which to send events.
             */
            function _sendEventsForLatencyAndAbove(latency, sendType, sendReason) {
                var queued = _queueBatches(latency, sendType, sendReason);
                // Always trigger the request as while the post channel may not have queued additional events, the httpManager may already have waiting events
                _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SEND_QUEUED_REQUESTS /* @min:%2esendQueuedRequests */](sendType, sendReason);
                return queued;
            }
            function _hasEvents() {
                return _queueSize > 0;
            }
            /**
             * Try to schedule the timer after which events will be sent. If there are
             * no events to be sent, or there is already a timer scheduled, or the
             * http manager doesn't have any idle connections this method is no-op.
             */
            function _scheduleTimer() {
                // If we had previously attempted to send requests, but the http manager didn't have any idle connections then the requests where delayed
                // so try and requeue then again now
                if (_delayedBatchSendLatency >= 0 && _queueBatches(_delayedBatchSendLatency, 0 /* EventSendType.Batched */, _delayedBatchReason)) {
                    _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SEND_QUEUED_REQUESTS /* @min:%2esendQueuedRequests */](0 /* EventSendType.Batched */, _delayedBatchReason);
                }
                if (_immediateQueueSize > 0 && !_immediateTimer && !_paused) {
                    // During initialization _profiles enforce that the direct [2] is less than real time [1] timer value
                    // If the immediateTimeout is disabled the immediate events will be sent with Real Time events
                    var immediateTimeOut = _profiles[_currentProfile][2];
                    if (immediateTimeOut >= 0) {
                        _immediateTimer = _createTimer(function () {
                            _immediateTimer = null;
                            // Only try to send direct events
                            _sendEventsForLatencyAndAbove(4 /* EventLatencyValue.Immediate */, 0 /* EventSendType.Batched */, 1 /* SendRequestReason.NormalSchedule */);
                            _scheduleTimer();
                        }, immediateTimeOut);
                    }
                }
                // During initialization the _profiles enforce that the normal [0] is a multiple of the real time [1] timer value
                var timeOut = _profiles[_currentProfile][1];
                if (!_scheduledTimer && !_flushCallbackTimer && timeOut >= 0 && !_paused) {
                    if (_hasEvents()) {
                        _scheduledTimer = _createTimer(function () {
                            _scheduledTimer = null;
                            _sendEventsForLatencyAndAbove(_timerCount === 0 ? 3 /* EventLatencyValue.RealTime */ : 1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, 1 /* SendRequestReason.NormalSchedule */);
                            // Increment the count for next cycle
                            _timerCount++;
                            _timerCount %= 2;
                            _scheduleTimer();
                        }, timeOut);
                    }
                    else {
                        _timerCount = 0;
                    }
                }
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN__BACK_OFF_TRANSMISSI12 /* @min:%2e_backOffTransmission */] = function () {
                if (_currentBackoffCount < MaxBackoffCount) {
                    _currentBackoffCount++;
                    _clearScheduledTimer();
                    _scheduleTimer();
                }
            };
            _self._clearBackOff = function () {
                if (_currentBackoffCount) {
                    _currentBackoffCount = 0;
                    _clearScheduledTimer();
                    _scheduleTimer();
                }
            };
            function _initDefaults() {
                _postConfig = null;
                _isTeardownCalled = false;
                _flushCallbackQueue = [];
                _flushCallbackTimer = null;
                _paused = false;
                _immediateQueueSize = 0;
                _immediateQueueSizeLimit = 500;
                _queueSize = 0;
                _queueSizeLimit = MaxEventsLimitInMem;
                _profiles = {};
                _currentProfile = _DataModels__WEBPACK_IMPORTED_MODULE_14__.RT_PROFILE;
                _scheduledTimer = null;
                _immediateTimer = null;
                _currentBackoffCount = 0;
                _timerCount = 0;
                _batchQueues = {};
                _autoFlushEventsLimit = 0;
                _unloadHandlersAdded = false;
                // either MaxBatchSize * (1+ Max Connections) or _queueLimit / 6 (where 3 latency Queues [normal, realtime, cost deferred] * 2 [allow half full -- allow for retry])
                _autoFlushBatchLimit = 0;
                _delayedBatchSendLatency = -1;
                _delayedBatchReason = null;
                _optimizeObject = true;
                _isPageUnloadTriggered = false;
                _maxEventSendAttempts = MaxSendAttempts;
                _maxUnloadEventSendAttempts = MaxSyncUnloadSendAttempts;
                _evtNamespace = null;
                _overrideInstrumentationKey = null;
                _maxEvtPerBatch = null;
                _disableTelemetry = false;
                _timeoutWrapper = (0,_TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_19__.createTimeoutWrapper)();
                // httpManager init should use the default value, because _maxEvtPerBatch is null currently
                _httpManager = new _HttpManager__WEBPACK_IMPORTED_MODULE_16__.HttpManager(MaxNumberEventPerBatch, MaxConnections, MaxRequestRetriesBeforeBackoff, {
                    requeue: _requeueEvents,
                    send: _sendingEvent,
                    sent: _eventsSentEvent,
                    drop: _eventsDropped,
                    rspFail: _eventsResponseFail,
                    oth: _otherEvent
                });
                _initializeProfiles();
                _clearQueues();
                _setAutoLimits();
            }
            function _createTimer(theTimerFunc, timeOut) {
                // If the transmission is backed off make the timer at least 1 sec to allow for back off.
                if (timeOut === 0 && _currentBackoffCount) {
                    timeOut = 1;
                }
                var timerMultiplier = 1000;
                if (_currentBackoffCount) {
                    timerMultiplier = (0,_RetryPolicy__WEBPACK_IMPORTED_MODULE_18__.retryPolicyGetMillisToBackoffForRetry)(_currentBackoffCount - 1);
                }
                return _timeoutWrapper.set(theTimerFunc, timeOut * timerMultiplier);
            }
            function _clearScheduledTimer() {
                if (_scheduledTimer !== null) {
                    _scheduledTimer.cancel();
                    _scheduledTimer = null;
                    _timerCount = 0;
                    return true;
                }
                return false;
            }
            // Try to send all queued events using beacons if available
            function _releaseAllQueues(sendType, sendReason) {
                _clearScheduledTimer();
                // Cancel all flush callbacks
                if (_flushCallbackTimer) {
                    _flushCallbackTimer.cancel();
                    _flushCallbackTimer = null;
                }
                if (!_paused) {
                    // Queue all the remaining requests to be sent. The requests will be sent using HTML5 Beacons if they are available.
                    _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, sendType, sendReason);
                }
            }
            /**
             * Add empty queues for all latencies in the inbound queues map. This is called
             * when Transmission Manager is being flushed. This ensures that new events added
             * after flush are stored separately till we flush the current events.
             */
            function _clearQueues() {
                _batchQueues[4 /* EventLatencyValue.Immediate */] = {
                    batches: [],
                    iKeyMap: {}
                };
                _batchQueues[3 /* EventLatencyValue.RealTime */] = {
                    batches: [],
                    iKeyMap: {}
                };
                _batchQueues[2 /* EventLatencyValue.CostDeferred */] = {
                    batches: [],
                    iKeyMap: {}
                };
                _batchQueues[1 /* EventLatencyValue.Normal */] = {
                    batches: [],
                    iKeyMap: {}
                };
            }
            function _getEventBatch(iKey, latency, create) {
                var batchQueue = _batchQueues[latency];
                if (!batchQueue) {
                    latency = 1 /* EventLatencyValue.Normal */;
                    batchQueue = _batchQueues[latency];
                }
                var eventBatch = batchQueue.iKeyMap[iKey];
                if (!eventBatch && create) {
                    eventBatch = _EventBatch__WEBPACK_IMPORTED_MODULE_15__.EventBatch.create(iKey);
                    batchQueue.batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_PUSH /* @min:%2epush */](eventBatch);
                    batchQueue.iKeyMap[iKey] = eventBatch;
                }
                return eventBatch;
            }
            function _performAutoFlush(isAsync, doFlush) {
                // Only perform the auto flush check if the httpManager has an idle connection and we are not in a backoff situation
                if (_httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_CAN_SEND_REQUEST /* @min:%2ecanSendRequest */]() && !_currentBackoffCount) {
                    if (_autoFlushEventsLimit > 0 && _queueSize > _autoFlushEventsLimit) {
                        // Force flushing
                        doFlush = true;
                    }
                    if (doFlush && _flushCallbackTimer == null) {
                        // Auto flush the queue, adding a callback to avoid the creation of a promise
                        _self.flush(isAsync, function () { }, 20 /* SendRequestReason.MaxQueuedEvents */);
                    }
                }
            }
            function _addEventToProperQueue(event, append) {
                // v8 performance optimization for iterating over the keys
                if (_optimizeObject) {
                    event = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.optimizeObject)(event);
                }
                var latency = event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LATENCY /* @min:%2elatency */];
                var eventBatch = _getEventBatch(event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_I_KEY /* @min:%2eiKey */], latency, true);
                if (eventBatch.addEvent(event)) {
                    if (latency !== 4 /* EventLatencyValue.Immediate */) {
                        _queueSize++;
                        // Check for auto flushing based on total events in the queue, but not for requeued or retry events
                        if (append && event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SEND_ATTEMPT /* @min:%2esendAttempt */] === 0) {
                            // Force the flushing of the batch if the batch (specific iKey / latency combination) reaches it's auto flush limit
                            _performAutoFlush(!event.sync, _autoFlushBatchLimit > 0 && eventBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]() >= _autoFlushBatchLimit);
                        }
                    }
                    else {
                        // Direct events don't need auto flushing as they are scheduled (by default) for immediate delivery
                        _immediateQueueSize++;
                    }
                    return true;
                }
                return false;
            }
            function _dropEventWithLatencyOrLess(iKey, latency, currentLatency, dropNumber) {
                while (currentLatency <= latency) {
                    var eventBatch = _getEventBatch(iKey, latency, true);
                    if (eventBatch && eventBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                        // Dropped oldest events from lowest possible latency
                        var droppedEvents = eventBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SPLIT /* @min:%2esplit */](0, dropNumber);
                        var droppedCount = droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]();
                        if (droppedCount > 0) {
                            if (currentLatency === 4 /* EventLatencyValue.Immediate */) {
                                _immediateQueueSize -= droppedCount;
                            }
                            else {
                                _queueSize -= droppedCount;
                            }
                            _notifyBatchEvents(strEventsDiscarded, [droppedEvents], _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.EventsDiscardedReason.QueueFull, undefined);
                            return true;
                        }
                    }
                    currentLatency++;
                }
                // Unable to drop any events -- lets just make sure the queue counts are correct to avoid exhaustion
                _resetQueueCounts();
                return false;
            }
            /**
             * Internal helper to reset the queue counts, used as a backstop to avoid future queue exhaustion errors
             * that might occur because of counting issues.
             */
            function _resetQueueCounts() {
                var immediateQueue = 0;
                var normalQueue = 0;
                var _loop_1 = function (latency) {
                    var batchQueue = _batchQueues[latency];
                    if (batchQueue && batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_BATCHES /* @min:%2ebatches */]) {
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.arrForEach)(batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                            if (latency === 4 /* EventLatencyValue.Immediate */) {
                                immediateQueue += theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]();
                            }
                            else {
                                normalQueue += theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]();
                            }
                        });
                    }
                };
                for (var latency = 1 /* EventLatencyValue.Normal */; latency <= 4 /* EventLatencyValue.Immediate */; latency++) {
                    _loop_1(latency);
                }
                _queueSize = normalQueue;
                _immediateQueueSize = immediateQueue;
            }
            function _queueBatches(latency, sendType, sendReason) {
                var eventsQueued = false;
                var isAsync = sendType === 0 /* EventSendType.Batched */;
                // Only queue batches (to the HttpManager) if this is a sync request or the httpManager has an idle connection
                // Thus keeping the events within the PostChannel until the HttpManager has a connection available
                // This is so we can drop "old" events if the queue is getting full because we can't successfully send events
                if (!isAsync || _httpManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_CAN_SEND_REQUEST /* @min:%2ecanSendRequest */]()) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__.doPerf)(_self.core, function () { return "PostChannel._queueBatches"; }, function () {
                        var droppedEvents = [];
                        var latencyToProcess = 4 /* EventLatencyValue.Immediate */;
                        while (latencyToProcess >= latency) {
                            var batchQueue = _batchQueues[latencyToProcess];
                            if (batchQueue && batchQueue.batches && batchQueue.batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */] > 0) {
                                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.arrForEach)(batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                                    // Add the batch to the http manager to send the requests
                                    if (!_httpManager.addBatch(theBatch)) {
                                        // The events from this iKey are being dropped (killed)
                                        droppedEvents = droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_CONCAT /* @min:%2econcat */](theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_EVENTS /* @min:%2eevents */]());
                                    }
                                    else {
                                        eventsQueued = eventsQueued || (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]() > 0);
                                    }
                                    if (latencyToProcess === 4 /* EventLatencyValue.Immediate */) {
                                        _immediateQueueSize -= theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]();
                                    }
                                    else {
                                        _queueSize -= theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]();
                                    }
                                });
                                // Remove all batches from this Queue
                                batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_BATCHES /* @min:%2ebatches */] = [];
                                batchQueue.iKeyMap = {};
                            }
                            latencyToProcess--;
                        }
                        if (droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */] > 0) {
                            _notifyEvents(strEventsDiscarded, droppedEvents, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.EventsDiscardedReason.KillSwitch);
                        }
                        if (eventsQueued && _delayedBatchSendLatency >= latency) {
                            // We have queued events at the same level as the delayed values so clear the setting
                            _delayedBatchSendLatency = -1;
                            _delayedBatchReason = 0 /* SendRequestReason.Undefined */;
                        }
                    }, function () { return ({ latency: latency, sendType: sendType, sendReason: sendReason }); }, !isAsync);
                }
                else {
                    // remember the min latency so that we can re-trigger later
                    _delayedBatchSendLatency = _delayedBatchSendLatency >= 0 ? (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.mathMin)(_delayedBatchSendLatency, latency) : latency;
                    _delayedBatchReason = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.mathMax)(_delayedBatchReason, sendReason);
                }
                return eventsQueued;
            }
            /**
             * This is the callback method is called as part of the manual flushing process.
             * @param callback - The callback method to call after the flush is complete
             * @param sendReason - The reason why the flush is being called
             */
            function _flushImpl(callback, sendReason) {
                // Add any additional queued events and cause all queued events to be sent asynchronously
                _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, sendReason);
                // All events (should) have been queue -- lets just make sure the queue counts are correct to avoid queue exhaustion (previous bug #9685112)
                _resetQueueCounts();
                _waitForIdleManager(function () {
                    // Only called AFTER the httpManager does not have any outstanding requests
                    if (callback) {
                        callback();
                    }
                    if (_flushCallbackQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        _flushCallbackTimer = _createTimer(function () {
                            _flushCallbackTimer = null;
                            _flushImpl(_flushCallbackQueue.shift(), sendReason);
                        }, 0);
                    }
                    else {
                        // No more flush requests
                        _flushCallbackTimer = null;
                        // Restart the normal timer schedule
                        _scheduleTimer();
                    }
                });
            }
            function _waitForIdleManager(callback) {
                if (_httpManager.isCompletelyIdle()) {
                    callback();
                }
                else {
                    _flushCallbackTimer = _createTimer(function () {
                        _flushCallbackTimer = null;
                        _waitForIdleManager(callback);
                    }, FlushCheckTimer);
                }
            }
            /**
             * Resets the transmit profiles to the default profiles of Real Time, Near Real Time
             * and Best Effort. This removes all the custom profiles that were loaded.
             */
            function _resetTransmitProfiles() {
                _clearScheduledTimer();
                _initializeProfiles();
                _currentProfile = _DataModels__WEBPACK_IMPORTED_MODULE_14__.RT_PROFILE;
                _scheduleTimer();
            }
            function _initializeProfiles() {
                _profiles = {};
                _profiles[_DataModels__WEBPACK_IMPORTED_MODULE_14__.RT_PROFILE] = [2, 1, 0];
                _profiles[_DataModels__WEBPACK_IMPORTED_MODULE_14__.NRT_PROFILE] = [6, 3, 0];
                _profiles[_DataModels__WEBPACK_IMPORTED_MODULE_14__.BE_PROFILE] = [18, 9, 0];
            }
            /**
             * The notification handler for requeue events
             * @ignore
             */
            function _requeueEvents(batches, reason) {
                var droppedEvents = [];
                var maxSendAttempts = _maxEventSendAttempts;
                if (_isPageUnloadTriggered) {
                    // If a page unlaod has been triggered reduce the number of times we try to "retry"
                    maxSendAttempts = _maxUnloadEventSendAttempts;
                }
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.arrForEach)(batches, function (theBatch) {
                    if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.arrForEach)(theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_EVENTS /* @min:%2eevents */](), function (theEvent) {
                            if (theEvent) {
                                // Check if the request being added back is for a sync event in which case mark it no longer a sync event
                                if (theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SYNC /* @min:%2esync */]) {
                                    theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LATENCY /* @min:%2elatency */] = 4 /* EventLatencyValue.Immediate */;
                                    theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SYNC /* @min:%2esync */] = false;
                                }
                                if (theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_SEND_ATTEMPT /* @min:%2esendAttempt */] < maxSendAttempts) {
                                    // Reset the event timings
                                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.setProcessTelemetryTimings)(theEvent, _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_IDENTIFIER /* @min:%2eidentifier */]);
                                    _addEventToQueues(theEvent, false);
                                }
                                else {
                                    droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_PUSH /* @min:%2epush */](theEvent);
                                }
                            }
                        });
                    }
                });
                if (droppedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _notifyEvents(strEventsDiscarded, droppedEvents, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.EventsDiscardedReason.NonRetryableStatus);
                }
                if (_isPageUnloadTriggered) {
                    // Unload event has been received so we need to try and flush new events
                    _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
                }
            }
            function _callNotification(evtName, theArgs) {
                var manager = (_notificationManager || {});
                var notifyFunc = manager[evtName];
                if (notifyFunc) {
                    try {
                        notifyFunc.apply(manager, theArgs);
                    }
                    catch (e) {
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_9__._throwInternal)(_self.diagLog(), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, evtName + " notification failed: " + e);
                    }
                }
            }
            function _notifyEvents(evtName, theEvents) {
                var extraArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    extraArgs[_i - 2] = arguments[_i];
                }
                if (theEvents && theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _callNotification(evtName, [theEvents][_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_CONCAT /* @min:%2econcat */](extraArgs));
                }
            }
            function _notifyBatchEvents(evtName, batches) {
                var extraArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    extraArgs[_i - 2] = arguments[_i];
                }
                if (batches && batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.arrForEach)(batches, function (theBatch) {
                        if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                            _callNotification(evtName, [theBatch.events()][_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_CONCAT /* @min:%2econcat */](extraArgs));
                        }
                    });
                }
            }
            /**
             * The notification handler for when batches are about to be sent
             * @ignore
             */
            function _sendingEvent(batches, reason, isSyncRequest) {
                if (batches && batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_20__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _callNotification("eventsSendRequest", [(reason >= 1000 /* EventBatchNotificationReason.SendingUndefined */ && reason <= 1999 /* EventBatchNotificationReason.SendingEventMax */ ?
                            reason - 1000 /* EventBatchNotificationReason.SendingUndefined */ :
                            0 /* SendRequestReason.Undefined */), isSyncRequest !== true]);
                }
            }
            /**
             * This event represents that a batch of events have been successfully sent and a response received
             * @param batches - The notification handler for when the batches have been successfully sent
             * @param reason - For this event the reason will always be EventBatchNotificationReason.Complete
             */
            function _eventsSentEvent(batches, reason) {
                _notifyBatchEvents("eventsSent", batches, reason);
                // Try and schedule the processing timer if we have events
                _scheduleTimer();
            }
            function _eventsDropped(batches, reason, isSyncRequest, sendType) {
                _notifyBatchEvents(strEventsDiscarded, batches, (reason >= 8000 /* EventBatchNotificationReason.EventsDropped */ && reason <= 8999 /* EventBatchNotificationReason.EventsDroppedMax */ ?
                    reason - 8000 /* EventBatchNotificationReason.EventsDropped */ :
                    _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.EventsDiscardedReason.Unknown), sendType);
            }
            function _eventsResponseFail(batches, reason, isSyncRequest, sendType) {
                _notifyBatchEvents(strEventsDiscarded, batches, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.EventsDiscardedReason.NonRetryableStatus, sendType);
                // Try and schedule the processing timer if we have events
                _scheduleTimer();
            }
            function _otherEvent(batches, reason, isSyncRequest, sendType) {
                _notifyBatchEvents(strEventsDiscarded, batches, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.EventsDiscardedReason.Unknown, sendType);
                // Try and schedule the processing timer if we have events
                _scheduleTimer();
            }
            function _setAutoLimits() {
                if (!_disableAutoBatchFlushLimit) {
                    _autoFlushBatchLimit = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.mathMax)(_maxEvtPerBatch * (MaxConnections + 1), _queueSizeLimit / 6);
                }
                else {
                    _autoFlushBatchLimit = 0;
                }
            }
        });
        return _this;
    }
// Removed Stub for PostChannel.prototype.initialize.
// Removed Stub for PostChannel.prototype.processTelemetry.
// Removed Stub for PostChannel.prototype.setEventQueueLimits.
// Removed Stub for PostChannel.prototype.pause.
// Removed Stub for PostChannel.prototype.resume.
// Removed Stub for PostChannel.prototype.addResponseHandler.
// Removed Stub for PostChannel.prototype.flush.
// Removed Stub for PostChannel.prototype.setMsaAuthTicket.
// Removed Stub for PostChannel.prototype.setAuthPluginHeader.
// Removed Stub for PostChannel.prototype.removeAuthPluginHeader.
// Removed Stub for PostChannel.prototype.hasEvents.
// Removed Stub for PostChannel.prototype._loadTransmitProfiles.
// Removed Stub for PostChannel.prototype._setTransmitProfile.
// Removed Stub for PostChannel.prototype._backOffTransmission.
// Removed Stub for PostChannel.prototype._clearBackOff.
// Removed Stub for PostChannel.prototype.getOfflineSupport.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    PostChannel.__ieDyn=1;

    return PostChannel;
}(_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_4__.BaseTelemetryPlugin));

//# sourceMappingURL=PostChannel.js.map

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventBatch: () => (/* binding */ EventBatch)
/* harmony export */ });
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(67);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* EventBatch.ts
* @author Nev Wylie (newylie)
* @copyright Microsoft 2020
*/



function _getEventMsfpc(theEvent) {
    var intWeb = ((theEvent.ext || {})["intweb"]);
    if (intWeb && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_0__.isValueAssigned)(intWeb[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_MSFPC])) {
        return intWeb[_InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_MSFPC];
    }
    return null;
}
function _getMsfpc(theEvents) {
    var msfpc = null;
    for (var lp = 0; msfpc === null && lp < theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]; lp++) {
        msfpc = _getEventMsfpc(theEvents[lp]);
    }
    return msfpc;
}
/**
* This class defines a "batch" events related to a specific iKey, it is used by the PostChannel and HttpManager
* to collect and transfer ownership of events without duplicating them in-memory. This reduces the previous
* array duplication and shared ownership issues that occurred due to race conditions caused by the async nature
* of sending requests.
*/
var EventBatch = /** @class */ (function () {
    /**
     * Private constructor so that caller is forced to use the static create method.
     * @param iKey - The iKey to associate with the events (not validated)
     * @param addEvents - The optional collection of events to assign to this batch - defaults to an empty array.
     */
    function EventBatch(iKey, addEvents) {
        var events = addEvents ? [][_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_CONCAT /* @min:%2econcat */](addEvents) : [];
        var _self = this;
        var _msfpc = _getMsfpc(events);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_I_KEY /* @min:%2eiKey */] = function () {
            return iKey;
        };
        _self.Msfpc = function () {
            // return the cached value unless it's undefined -- used to avoid cpu
            return _msfpc || _InternalConstants__WEBPACK_IMPORTED_MODULE_2__.STR_EMPTY;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_COUNT /* @min:%2ecount */] = function () {
            return events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EVENTS /* @min:%2eevents */] = function () {
            return events;
        };
        _self.addEvent = function (theEvent) {
            if (theEvent) {
                events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PUSH /* @min:%2epush */](theEvent);
                if (!_msfpc) {
                    // Not found so try and find one
                    _msfpc = _getEventMsfpc(theEvent);
                }
                return true;
            }
            return false;
        };
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SPLIT /* @min:%2esplit */] = function (fromEvent, numEvents) {
            // Create a new batch with the same iKey
            var theEvents;
            if (fromEvent < events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
                var cnt = events[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] - fromEvent;
                if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(numEvents)) {
                    cnt = numEvents < cnt ? numEvents : cnt;
                }
                theEvents = events.splice(fromEvent, cnt);
                // reset the fetched msfpc value
                _msfpc = _getMsfpc(events);
            }
            return new EventBatch(iKey, theEvents);
        };
    }
    /**
     * Creates a new Event Batch object
     * @param iKey - The iKey associated with this batch of events
     */
    EventBatch.create = function (iKey, theEvents) {
        return new EventBatch(iKey, theEvents);
    };
    return EventBatch;
}());

//# sourceMappingURL=EventBatch.js.map

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_CACHE_CONTROL: () => (/* binding */ DEFAULT_CACHE_CONTROL),
/* harmony export */   DEFAULT_CONTENT_TYPE: () => (/* binding */ DEFAULT_CONTENT_TYPE),
/* harmony export */   STR_API_KEY: () => (/* binding */ STR_API_KEY),
/* harmony export */   STR_AUTH_WEB_TOKEN: () => (/* binding */ STR_AUTH_WEB_TOKEN),
/* harmony export */   STR_AUTH_XTOKEN: () => (/* binding */ STR_AUTH_XTOKEN),
/* harmony export */   STR_CACHE_CONTROL: () => (/* binding */ STR_CACHE_CONTROL),
/* harmony export */   STR_CLIENT_ID: () => (/* binding */ STR_CLIENT_ID),
/* harmony export */   STR_CLIENT_VERSION: () => (/* binding */ STR_CLIENT_VERSION),
/* harmony export */   STR_CONTENT_TYPE_HEADER: () => (/* binding */ STR_CONTENT_TYPE_HEADER),
/* harmony export */   STR_DISABLED_PROPERTY_NAME: () => (/* binding */ STR_DISABLED_PROPERTY_NAME),
/* harmony export */   STR_DROPPED: () => (/* binding */ STR_DROPPED),
/* harmony export */   STR_EMPTY: () => (/* binding */ STR_EMPTY),
/* harmony export */   STR_KILL_DURATION_HEADER: () => (/* binding */ STR_KILL_DURATION_HEADER),
/* harmony export */   STR_KILL_DURATION_SECONDS_HEADER: () => (/* binding */ STR_KILL_DURATION_SECONDS_HEADER),
/* harmony export */   STR_KILL_TOKENS_HEADER: () => (/* binding */ STR_KILL_TOKENS_HEADER),
/* harmony export */   STR_MSA_DEVICE_TICKET: () => (/* binding */ STR_MSA_DEVICE_TICKET),
/* harmony export */   STR_MSFPC: () => (/* binding */ STR_MSFPC),
/* harmony export */   STR_NO_RESPONSE_BODY: () => (/* binding */ STR_NO_RESPONSE_BODY),
/* harmony export */   STR_OTHER: () => (/* binding */ STR_OTHER),
/* harmony export */   STR_POST_METHOD: () => (/* binding */ STR_POST_METHOD),
/* harmony export */   STR_REQUEUE: () => (/* binding */ STR_REQUEUE),
/* harmony export */   STR_RESPONSE_FAIL: () => (/* binding */ STR_RESPONSE_FAIL),
/* harmony export */   STR_SDK_VERSION: () => (/* binding */ STR_SDK_VERSION),
/* harmony export */   STR_SENDING: () => (/* binding */ STR_SENDING),
/* harmony export */   STR_TIME_DELTA_HEADER: () => (/* binding */ STR_TIME_DELTA_HEADER),
/* harmony export */   STR_TIME_DELTA_TO_APPLY: () => (/* binding */ STR_TIME_DELTA_TO_APPLY),
/* harmony export */   STR_TRACE: () => (/* binding */ STR_TRACE),
/* harmony export */   STR_UPLOAD_TIME: () => (/* binding */ STR_UPLOAD_TIME),
/* harmony export */   STR_USER: () => (/* binding */ STR_USER)
/* harmony export */ });
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

// Licensed under the MIT License.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Generally you should only put values that are used more than 2 times and then only if not already exposed as a constant (such as SdkCoreNames)
// as when using "short" named values from here they will be will be minified smaller than the SdkCoreNames[eSdkCoreNames.xxxx] value.
var STR_EMPTY = "";
var STR_POST_METHOD = "POST";
var STR_DISABLED_PROPERTY_NAME = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
var STR_DROPPED = "drop";
var STR_SENDING = "send";
var STR_REQUEUE = "requeue";
var STR_RESPONSE_FAIL = "rspFail";
var STR_OTHER = "oth";
var DEFAULT_CACHE_CONTROL = "no-cache, no-store";
var DEFAULT_CONTENT_TYPE = "application/x-json-stream";
var STR_CACHE_CONTROL = "cache-control";
var STR_CONTENT_TYPE_HEADER = "content-type";
var STR_KILL_TOKENS_HEADER = "kill-tokens";
var STR_KILL_DURATION_HEADER = "kill-duration";
var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
var STR_TIME_DELTA_HEADER = "time-delta-millis";
var STR_CLIENT_VERSION = "client-version";
var STR_CLIENT_ID = "client-id";
var STR_TIME_DELTA_TO_APPLY = "time-delta-to-apply-millis";
var STR_UPLOAD_TIME = "upload-time";
var STR_API_KEY = "apikey";
var STR_MSA_DEVICE_TICKET = "AuthMsaDeviceTicket";
var STR_AUTH_WEB_TOKEN = "WebAuthToken";
var STR_AUTH_XTOKEN = "AuthXToken";
var STR_SDK_VERSION = "sdk-version";
var STR_NO_RESPONSE_BODY = "NoResponseBody";
var STR_MSFPC = "msfpc";
var STR_TRACE = "trace";
var STR_USER = "user";
//# sourceMappingURL=InternalConstants.js.map

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _DYN_ADD_NO_RESPONSE: () => (/* binding */ _DYN_ADD_NO_RESPONSE),
/* harmony export */   _DYN_ALLOW_REQUEST_SENDIN0: () => (/* binding */ _DYN_ALLOW_REQUEST_SENDIN0),
/* harmony export */   _DYN_ALWAYS_USE_XHR_OVERR7: () => (/* binding */ _DYN_ALWAYS_USE_XHR_OVERR7),
/* harmony export */   _DYN_AUTO_FLUSH_EVENTS_LI14: () => (/* binding */ _DYN_AUTO_FLUSH_EVENTS_LI14),
/* harmony export */   _DYN_AVOID_OPTIONS: () => (/* binding */ _DYN_AVOID_OPTIONS),
/* harmony export */   _DYN_BATCHES: () => (/* binding */ _DYN_BATCHES),
/* harmony export */   _DYN_CAN_SEND_REQUEST: () => (/* binding */ _DYN_CAN_SEND_REQUEST),
/* harmony export */   _DYN_CLEAR_TIMEOUT_OVERRI3: () => (/* binding */ _DYN_CLEAR_TIMEOUT_OVERRI3),
/* harmony export */   _DYN_CONCAT: () => (/* binding */ _DYN_CONCAT),
/* harmony export */   _DYN_COUNT: () => (/* binding */ _DYN_COUNT),
/* harmony export */   _DYN_CREATE_ONE_DSPAYLOAD: () => (/* binding */ _DYN_CREATE_ONE_DSPAYLOAD),
/* harmony export */   _DYN_CREATE_PAYLOAD: () => (/* binding */ _DYN_CREATE_PAYLOAD),
/* harmony export */   _DYN_DISABLE_AUTO_BATCH_F15: () => (/* binding */ _DYN_DISABLE_AUTO_BATCH_F15),
/* harmony export */   _DYN_DISABLE_EVENT_TIMING5: () => (/* binding */ _DYN_DISABLE_EVENT_TIMING5),
/* harmony export */   _DYN_DISABLE_FETCH_KEEP_A6: () => (/* binding */ _DYN_DISABLE_FETCH_KEEP_A6),
/* harmony export */   _DYN_DISABLE_XHR_SYNC: () => (/* binding */ _DYN_DISABLE_XHR_SYNC),
/* harmony export */   _DYN_ENABLE_COMPOUND_KEY: () => (/* binding */ _DYN_ENABLE_COMPOUND_KEY),
/* harmony export */   _DYN_EVENTS: () => (/* binding */ _DYN_EVENTS),
/* harmony export */   _DYN_FETCH_CREDENTIALS: () => (/* binding */ _DYN_FETCH_CREDENTIALS),
/* harmony export */   _DYN_GET_CLOCK_SKEW_HEADE2: () => (/* binding */ _DYN_GET_CLOCK_SKEW_HEADE2),
/* harmony export */   _DYN_GET_OFFLINE_REQUEST_9: () => (/* binding */ _DYN_GET_OFFLINE_REQUEST_9),
/* harmony export */   _DYN_GET_WPARAM: () => (/* binding */ _DYN_GET_WPARAM),
/* harmony export */   _DYN_HDRS: () => (/* binding */ _DYN_HDRS),
/* harmony export */   _DYN_HEADERS: () => (/* binding */ _DYN_HEADERS),
/* harmony export */   _DYN_IDENTIFIER: () => (/* binding */ _DYN_IDENTIFIER),
/* harmony export */   _DYN_IGNORE_MC1_MS0_COOKI13: () => (/* binding */ _DYN_IGNORE_MC1_MS0_COOKI13),
/* harmony export */   _DYN_INITIALIZE: () => (/* binding */ _DYN_INITIALIZE),
/* harmony export */   _DYN_IS_BEACON: () => (/* binding */ _DYN_IS_BEACON),
/* harmony export */   _DYN_IS_TEARDOWN: () => (/* binding */ _DYN_IS_TEARDOWN),
/* harmony export */   _DYN_IS_TENANT_KILLED: () => (/* binding */ _DYN_IS_TENANT_KILLED),
/* harmony export */   _DYN_I_KEY: () => (/* binding */ _DYN_I_KEY),
/* harmony export */   _DYN_LATENCY: () => (/* binding */ _DYN_LATENCY),
/* harmony export */   _DYN_LENGTH: () => (/* binding */ _DYN_LENGTH),
/* harmony export */   _DYN_OVERRIDE_ENDPOINT_UR4: () => (/* binding */ _DYN_OVERRIDE_ENDPOINT_UR4),
/* harmony export */   _DYN_OVERRIDE_INSTRUMENTA16: () => (/* binding */ _DYN_OVERRIDE_INSTRUMENTA16),
/* harmony export */   _DYN_PAYLOAD_BLOB: () => (/* binding */ _DYN_PAYLOAD_BLOB),
/* harmony export */   _DYN_PAYLOAD_PREPROCESSOR: () => (/* binding */ _DYN_PAYLOAD_PREPROCESSOR),
/* harmony export */   _DYN_PUSH: () => (/* binding */ _DYN_PUSH),
/* harmony export */   _DYN_SEND_ATTEMPT: () => (/* binding */ _DYN_SEND_ATTEMPT),
/* harmony export */   _DYN_SEND_QUEUED_REQUESTS: () => (/* binding */ _DYN_SEND_QUEUED_REQUESTS),
/* harmony export */   _DYN_SEND_SYNCHRONOUS_BAT10: () => (/* binding */ _DYN_SEND_SYNCHRONOUS_BAT10),
/* harmony export */   _DYN_SEND_TYPE: () => (/* binding */ _DYN_SEND_TYPE),
/* harmony export */   _DYN_SERIALIZE_OFFLINE_EV8: () => (/* binding */ _DYN_SERIALIZE_OFFLINE_EV8),
/* harmony export */   _DYN_SET_CLOCK_SKEW: () => (/* binding */ _DYN_SET_CLOCK_SKEW),
/* harmony export */   _DYN_SET_KILL_SWITCH_TENA11: () => (/* binding */ _DYN_SET_KILL_SWITCH_TENA11),
/* harmony export */   _DYN_SET_TIMEOUT_OVERRIDE: () => (/* binding */ _DYN_SET_TIMEOUT_OVERRIDE),
/* harmony export */   _DYN_SET_UNLOADING: () => (/* binding */ _DYN_SET_UNLOADING),
/* harmony export */   _DYN_SHOULD_ADD_CLOCK_SKE1: () => (/* binding */ _DYN_SHOULD_ADD_CLOCK_SKE1),
/* harmony export */   _DYN_SPLIT: () => (/* binding */ _DYN_SPLIT),
/* harmony export */   _DYN_SYNC: () => (/* binding */ _DYN_SYNC),
/* harmony export */   _DYN_TIMINGS: () => (/* binding */ _DYN_TIMINGS),
/* harmony export */   _DYN_TO_LOWER_CASE: () => (/* binding */ _DYN_TO_LOWER_CASE),
/* harmony export */   _DYN_USE_HDRS: () => (/* binding */ _DYN_USE_HDRS),
/* harmony export */   _DYN_USE_SEND_BEACON: () => (/* binding */ _DYN_USE_SEND_BEACON),
/* harmony export */   _DYN__BACK_OFF_TRANSMISSI12: () => (/* binding */ _DYN__BACK_OFF_TRANSMISSI12),
/* harmony export */   _DYN__SEND_REASON: () => (/* binding */ _DYN__SEND_REASON),
/* harmony export */   _DYN__THE_PAYLOAD: () => (/* binding */ _DYN__THE_PAYLOAD),
/* harmony export */   _DYN__TRANSPORT: () => (/* binding */ _DYN__TRANSPORT)
/* harmony export */ });
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

// Licensed under the MIT License.
// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES5 which can result in a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_ALLOW_REQUEST_SENDIN0 = "allowRequestSending"; // Count: 3
var _DYN_SHOULD_ADD_CLOCK_SKE1 = "shouldAddClockSkewHeaders"; // Count: 2
var _DYN_GET_CLOCK_SKEW_HEADE2 = "getClockSkewHeaderValue"; // Count: 2
var _DYN_SET_CLOCK_SKEW = "setClockSkew"; // Count: 3
var _DYN_LENGTH = "length"; // Count: 38
var _DYN_CONCAT = "concat"; // Count: 7
var _DYN_I_KEY = "iKey"; // Count: 10
var _DYN_COUNT = "count"; // Count: 19
var _DYN_EVENTS = "events"; // Count: 8
var _DYN_PUSH = "push"; // Count: 15
var _DYN_SPLIT = "split"; // Count: 6
var _DYN_TO_LOWER_CASE = "toLowerCase"; // Count: 3
var _DYN_HDRS = "hdrs"; // Count: 7
var _DYN_USE_HDRS = "useHdrs"; // Count: 4
var _DYN_INITIALIZE = "initialize"; // Count: 5
var _DYN_SET_TIMEOUT_OVERRIDE = "setTimeoutOverride"; // Count: 3
var _DYN_CLEAR_TIMEOUT_OVERRI3 = "clearTimeoutOverride"; // Count: 3
var _DYN_PAYLOAD_PREPROCESSOR = "payloadPreprocessor"; // Count: 2
var _DYN_OVERRIDE_ENDPOINT_UR4 = "overrideEndpointUrl"; // Count: 3
var _DYN_AVOID_OPTIONS = "avoidOptions"; // Count: 3
var _DYN_DISABLE_EVENT_TIMING5 = "disableEventTimings"; // Count: 2
var _DYN_ENABLE_COMPOUND_KEY = "enableCompoundKey"; // Count: 4
var _DYN_DISABLE_XHR_SYNC = "disableXhrSync"; // Count: 6
var _DYN_DISABLE_FETCH_KEEP_A6 = "disableFetchKeepAlive"; // Count: 7
var _DYN_ADD_NO_RESPONSE = "addNoResponse"; // Count: 3
var _DYN_USE_SEND_BEACON = "useSendBeacon"; // Count: 3
var _DYN_FETCH_CREDENTIALS = "fetchCredentials"; // Count: 4
var _DYN_ALWAYS_USE_XHR_OVERR7 = "alwaysUseXhrOverride"; // Count: 3
var _DYN_SERIALIZE_OFFLINE_EV8 = "serializeOfflineEvt"; // Count: 2
var _DYN_GET_OFFLINE_REQUEST_9 = "getOfflineRequestDetails"; // Count: 2
var _DYN_CREATE_PAYLOAD = "createPayload"; // Count: 4
var _DYN_CREATE_ONE_DSPAYLOAD = "createOneDSPayload"; // Count: 4
var _DYN_PAYLOAD_BLOB = "payloadBlob"; // Count: 3
var _DYN_HEADERS = "headers"; // Count: 10
var _DYN__THE_PAYLOAD = "_thePayload"; // Count: 5
var _DYN_BATCHES = "batches"; // Count: 15
var _DYN_SEND_TYPE = "sendType"; // Count: 13
var _DYN_CAN_SEND_REQUEST = "canSendRequest"; // Count: 3
var _DYN_SEND_QUEUED_REQUESTS = "sendQueuedRequests"; // Count: 5
var _DYN_SET_UNLOADING = "setUnloading"; // Count: 3
var _DYN_IS_TENANT_KILLED = "isTenantKilled"; // Count: 3
var _DYN_SEND_SYNCHRONOUS_BAT10 = "sendSynchronousBatch"; // Count: 2
var _DYN__TRANSPORT = "_transport"; // Count: 3
var _DYN_GET_WPARAM = "getWParam"; // Count: 4
var _DYN_IS_BEACON = "isBeacon"; // Count: 4
var _DYN_TIMINGS = "timings"; // Count: 4
var _DYN_IS_TEARDOWN = "isTeardown"; // Count: 3
var _DYN__SEND_REASON = "_sendReason"; // Count: 3
var _DYN_SET_KILL_SWITCH_TENA11 = "setKillSwitchTenants"; // Count: 2
var _DYN__BACK_OFF_TRANSMISSI12 = "_backOffTransmission"; // Count: 2
var _DYN_IDENTIFIER = "identifier"; // Count: 4
var _DYN_IGNORE_MC1_MS0_COOKI13 = "ignoreMc1Ms0CookieProcessing"; // Count: 2
var _DYN_AUTO_FLUSH_EVENTS_LI14 = "autoFlushEventsLimit"; // Count: 2
var _DYN_DISABLE_AUTO_BATCH_F15 = "disableAutoBatchFlushLimit"; // Count: 2
var _DYN_OVERRIDE_INSTRUMENTA16 = "overrideInstrumentationKey"; // Count: 2
var _DYN_SEND_ATTEMPT = "sendAttempt"; // Count: 4
var _DYN_LATENCY = "latency"; // Count: 7
var _DYN_SYNC = "sync"; // Count: 7
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HttpManager: () => (/* binding */ HttpManager)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(60);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(40);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(22);
/* harmony import */ var _ClockSkewManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(70);
/* harmony import */ var _EventBatch__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(66);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(67);
/* harmony import */ var _KillSwitch__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(71);
/* harmony import */ var _RetryPolicy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(72);
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(73);
/* harmony import */ var _TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(74);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(68);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
var _a;
/**
* HttpManager.ts
* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)
* @copyright Microsoft 2018-2020
*/











var strSendAttempt = "sendAttempt";
var _noResponseQs = "&" + _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_NO_RESPONSE_BODY + "=true";
var UrlQueryString = "?cors=true&" + _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CONTENT_TYPE_HEADER[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() + "=" + _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.DEFAULT_CONTENT_TYPE;
/**
 * Identifies the default notification reason to the action names
 */
var _eventActionMap = (_a = {},
    _a[1 /* EventBatchNotificationReason.Paused */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_REQUEUE,
    _a[100 /* EventBatchNotificationReason.RequeueEvents */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_REQUEUE,
    _a[200 /* EventBatchNotificationReason.Complete */] = "sent",
    _a[8004 /* EventBatchNotificationReason.KillSwitch */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_DROPPED,
    _a[8003 /* EventBatchNotificationReason.SizeLimitExceeded */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_DROPPED,
    _a[8006 /* EventBatchNotificationReason.BeaconSendFailure */] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_DROPPED,
    _a);
var _collectorQsHeaders = {};
var _collectorHeaderToQs = {};
function _addCollectorHeaderQsMapping(qsName, headerName, allowQs) {
    _collectorQsHeaders[qsName] = headerName;
    if (allowQs !== false) {
        _collectorHeaderToQs[headerName] = qsName;
    }
}
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_MSA_DEVICE_TICKET, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_MSA_DEVICE_TICKET, false);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CLIENT_VERSION, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CLIENT_VERSION);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CLIENT_ID, "Client-Id");
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_API_KEY, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_API_KEY);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_TIME_DELTA_TO_APPLY, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_TIME_DELTA_TO_APPLY);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_UPLOAD_TIME, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_UPLOAD_TIME);
_addCollectorHeaderQsMapping(_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_AUTH_XTOKEN, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_AUTH_XTOKEN);
function _hasHeader(headers, header) {
    var hasHeader = false;
    if (headers && header) {
        var keys = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.objKeys)(headers);
        if (keys && keys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
            var lowerHeader = header[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
            for (var lp = 0; lp < keys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                var value = keys[lp];
                if (value && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.objHasOwnProperty)(header, value) &&
                    value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === lowerHeader) {
                    hasHeader = true;
                    break;
                }
            }
        }
    }
    return hasHeader;
}
function _addRequestDetails(details, name, value, useHeaders) {
    if (name && value && value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
        if (useHeaders && _collectorQsHeaders[name]) {
            details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HDRS /* @min:%2ehdrs */][_collectorQsHeaders[name]] = value;
            details[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_USE_HDRS /* @min:%2euseHdrs */] = true;
        }
        else {
            details.url += "&" + name + "=" + value;
        }
    }
}
function _addQueryStringParameter(qsParams, name, value) {
    for (var i = 0; i < qsParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; i++) {
        if (qsParams[i].name === name) {
            qsParams[i].value = value;
            return;
        }
    }
    qsParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */]({ name: name, value: value });
}
function _removeQueryStringParameter(qsParams, name) {
    for (var i = 0; i < qsParams[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; i++) {
        if (qsParams[i].name === name) {
            qsParams.splice(i, 1);
            return;
        }
    }
}
/**
 * Class managing the sending of requests.
 */
var HttpManager = /** @class */ (function () {
    /**
     * @constructor
     * @param requestQueue   - The queue that contains the requests to be sent.
     */
    function HttpManager(maxEventsPerBatch, maxConnections, maxRequestRetriesBeforeBackoff, actions) {
        // ------------------------------------------------------------------------------------------------------------------------
        // Only set "Default" values in the _initDefaults() method, unless value are not "reset" during unloading
        // ------------------------------------------------------------------------------------------------------------------------
        var _urlString;
        var _killSwitch;
        var _paused;
        var _clockSkewManager;
        var _useBeacons = false;
        var _outstandingRequests; // Holds the number of outstanding async requests that have not returned a response yet
        var _postManager;
        var _logger;
        var _sendInterfaces;
        var _core;
        var _customHttpInterface;
        var _queryStringParameters;
        var _headers;
        var _batchQueue;
        var _serializer;
        var _enableEventTimings;
        var _cookieMgr;
        var _isUnloading;
        var _useHeaders;
        var _xhrTimeout;
        var _zipPayload;
        var _disableXhrSync;
        var _disableFetchKeepAlive;
        var _canHaveReducedPayload;
        var _addNoResponse;
        var _unloadHooks;
        var _sendHook;
        var _sendListener;
        var _responseHandlers;
        var _isInitialized;
        var _timeoutWrapper;
        var _excludeCsMetaData;
        var _sendPostMgr;
        var _fetchCredentials;
        var _maxEvtPerBatch = maxEventsPerBatch; // Sets default value in case the value is null
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(HttpManager, this, function (_self) {
            _initDefaults();
            var _sendCredentials = true;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_INITIALIZE /* @min:%2einitialize */] = function (theConfig, core, postChannel) {
                if (!_isInitialized) {
                    _core = core;
                    _cookieMgr = core.getCookieMgr();
                    _postManager = postChannel;
                    _logger = _postManager.diagLog();
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrAppend)(_unloadHooks, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_9__.onConfigChange)(theConfig, function (details) {
                        var _a;
                        var coreConfig = details.cfg;
                        var channelConfig = details.cfg.extensionConfig[postChannel.identifier];
                        _timeoutWrapper = (0,_TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_16__.createTimeoutWrapper)(channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SET_TIMEOUT_OVERRIDE /* @min:%2esetTimeoutOverride */], channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CLEAR_TIMEOUT_OVERRI3 /* @min:%2eclearTimeoutOverride */]);
                        if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(coreConfig.anonCookieName)) {
                            _addQueryStringParameter(_queryStringParameters, "anoncknm", coreConfig.anonCookieName);
                        }
                        else {
                            _removeQueryStringParameter(_queryStringParameters, "anoncknm");
                        }
                        _sendHook = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PAYLOAD_PREPROCESSOR /* @min:%2epayloadPreprocessor */];
                        _sendListener = channelConfig.payloadListener;
                        var httpInterface = channelConfig.httpXHROverride;
                        // Override endpointUrl if provided in Post config
                        var endpointUrl = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_OVERRIDE_ENDPOINT_UR4 /* @min:%2eoverrideEndpointUrl */] ? channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_OVERRIDE_ENDPOINT_UR4 /* @min:%2eoverrideEndpointUrl */] : coreConfig.endpointUrl;
                        _urlString = endpointUrl + UrlQueryString;
                        _useHeaders = !(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_AVOID_OPTIONS /* @min:%2eavoidOptions */]) ? !channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_AVOID_OPTIONS /* @min:%2eavoidOptions */] : true;
                        _enableEventTimings = !channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_DISABLE_EVENT_TIMING5 /* @min:%2edisableEventTimings */];
                        var maxEvtCfg = channelConfig.maxEvtPerBatch;
                        _maxEvtPerBatch = maxEvtCfg && maxEvtCfg <= maxEventsPerBatch ? maxEvtCfg : maxEventsPerBatch;
                        var valueSanitizer = channelConfig.valueSanitizer;
                        var stringifyObjects = channelConfig.stringifyObjects;
                        var enableCompoundKey = !!coreConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_ENABLE_COMPOUND_KEY /* @min:%2eenableCompoundKey */];
                        if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_ENABLE_COMPOUND_KEY /* @min:%2eenableCompoundKey */])) {
                            enableCompoundKey = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_ENABLE_COMPOUND_KEY /* @min:%2eenableCompoundKey */];
                        }
                        _xhrTimeout = channelConfig.xhrTimeout;
                        var csStream = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.getInst)("CompressionStream");
                        // Controls whether payload compression (gzip) is enabled.
                        _zipPayload = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.isFeatureEnabled)("zipPayload", coreConfig, false);
                        // if user has payload processor (_sendHook), they may compress the payload themselves
                        // to avoid double compression, we should disable the zipPayload
                        if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.isFunction)(csStream) || _sendHook) {
                            _zipPayload = false;
                        }
                        _disableXhrSync = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_DISABLE_XHR_SYNC /* @min:%2edisableXhrSync */];
                        _disableFetchKeepAlive = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_DISABLE_FETCH_KEEP_A6 /* @min:%2edisableFetchKeepAlive */];
                        _addNoResponse = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_ADD_NO_RESPONSE /* @min:%2eaddNoResponse */] !== false;
                        _excludeCsMetaData = !!channelConfig.excludeCsMetaData;
                        if (!!core.getPlugin("LocalStorage")) {
                            // Always disable fetch keep alive when persisten storage is available
                            _disableFetchKeepAlive = true;
                        }
                        _useBeacons = !(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isReactNative)(); // Only use beacons if not running in React Native
                        _serializer = new _Serializer__WEBPACK_IMPORTED_MODULE_15__.Serializer(_core, valueSanitizer, stringifyObjects, enableCompoundKey, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getCommonSchemaMetaData, _excludeCsMetaData, channelConfig);
                        if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.isNullOrUndefined)(channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_USE_SEND_BEACON /* @min:%2euseSendBeacon */])) {
                            _useBeacons = !!channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_USE_SEND_BEACON /* @min:%2euseSendBeacon */];
                        }
                        if (channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_FETCH_CREDENTIALS /* @min:%2efetchCredentials */]) {
                            _fetchCredentials = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_FETCH_CREDENTIALS /* @min:%2efetchCredentials */];
                        }
                        var sendPostConfig = _getSendPostMgrConfig();
                        // only init it once
                        if (!_sendPostMgr) {
                            _sendPostMgr = new _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_4__.SenderPostManager();
                            _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_INITIALIZE /* @min:%2einitialize */](sendPostConfig, _logger);
                        }
                        else {
                            _sendPostMgr.SetConfig(sendPostConfig);
                        }
                        var syncHttpInterface = httpInterface;
                        var beaconHttpInterface = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_ALWAYS_USE_XHR_OVERR7 /* @min:%2ealwaysUseXhrOverride */] ? httpInterface : null;
                        var fetchSyncHttpInterface = channelConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_ALWAYS_USE_XHR_OVERR7 /* @min:%2ealwaysUseXhrOverride */] ? httpInterface : null;
                        var beaconUnloadTransports = [3 /* TransportType.Beacon */, 2 /* TransportType.Fetch */];
                        if (!httpInterface) {
                            _customHttpInterface = false;
                            // this is handled in SendPostManager now
                            // let location = getLocation();
                            // if (location && location.protocol && location.protocol.toLowerCase() === "file:") {
                            //     // Special case where a local html file fails with a CORS error on Chromium browsers
                            //     _sendCredentials = false;
                            // }
                            var theTransports = [];
                            if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isReactNative)()) {
                                // Use Fetch or XDR/XHR
                                theTransports = [2 /* TransportType.Fetch */, 1 /* TransportType.Xhr */];
                                beaconUnloadTransports = [2 /* TransportType.Fetch */, 1 /* TransportType.Xhr */, 3 /* TransportType.Beacon */];
                            }
                            else {
                                // Use XDR/XHR, Fetch or beacons
                                theTransports = [1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */];
                            }
                            // Prefix any user requested transport(s) values
                            theTransports = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.prependTransports)(theTransports, channelConfig.transports);
                            httpInterface = _getSenderInterface(theTransports, false);
                            if (!httpInterface) {
                                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__._warnToConsole)(_logger, "No available transport to send events");
                            }
                            syncHttpInterface = _getSenderInterface(theTransports, true);
                        }
                        if (!beaconHttpInterface) {
                            // Allow overriding the usage of sendBeacon
                            beaconUnloadTransports = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.prependTransports)(beaconUnloadTransports, channelConfig.unloadTransports);
                            beaconHttpInterface = _getSenderInterface(beaconUnloadTransports, true);
                        }
                        _canHaveReducedPayload = !_customHttpInterface && ((_useBeacons && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isBeaconsSupported)()) || (!_disableFetchKeepAlive && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_6__.isFetchSupported)(true)));
                        _sendInterfaces = (_a = {},
                            _a[0 /* EventSendType.Batched */] = httpInterface,
                            _a[1 /* EventSendType.Synchronous */] = syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */], true),
                            _a[2 /* EventSendType.SendBeacon */] = beaconHttpInterface || syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */], true),
                            _a[3 /* EventSendType.SyncFetch */] = fetchSyncHttpInterface || _getSenderInterface([2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */], true) || syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */], true),
                            _a);
                    }));
                    _isInitialized = true;
                }
            };
            _self.addResponseHandler = function (responseHandler) {
                _responseHandlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */](responseHandler);
                return {
                    rm: function () {
                        var index = _responseHandlers.indexOf(responseHandler);
                        if (index >= 0) {
                            _responseHandlers.splice(index, 1);
                        }
                    }
                };
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SERIALIZE_OFFLINE_EV8 /* @min:%2eserializeOfflineEvt */] = function (evt) {
                try {
                    if (_serializer) {
                        return _serializer.getEventBlob(evt);
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_EMPTY;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_GET_OFFLINE_REQUEST_9 /* @min:%2egetOfflineRequestDetails */] = function () {
                try {
                    // get current url without paramter
                    var payload = _serializer && _serializer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CREATE_PAYLOAD /* @min:%2ecreatePayload */](0, false, false, false, 1 /* SendRequestReason.NormalSchedule */, 0 /* EventSendType.Batched */);
                    return _buildRequestDetails(payload, _useHeaders);
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CREATE_ONE_DSPAYLOAD /* @min:%2ecreateOneDSPayload */] = function (evts, optimize) {
                try {
                    // TODO: optimize
                    var theBatches_1 = [];
                    // create a eventBatch for each event
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(evts, function (evt) {
                        if (optimize) {
                            evt = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.optimizeObject)(evt);
                        }
                        var batch = _EventBatch__WEBPACK_IMPORTED_MODULE_11__.EventBatch.create(evt[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_I_KEY /* @min:%2eiKey */], [evt]);
                        theBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */](batch);
                    });
                    var thePayload = null;
                    while (theBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0 && _serializer) {
                        var theBatch = theBatches_1.shift();
                        if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                            thePayload = thePayload || _serializer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CREATE_PAYLOAD /* @min:%2ecreatePayload */](0, false, false, false, 1 /* SendRequestReason.NormalSchedule */, 0 /* EventSendType.Batched */);
                            _serializer.appendPayload(thePayload, theBatch, _maxEvtPerBatch);
                        }
                    }
                    var requestDetails = _buildRequestDetails(thePayload, _useHeaders);
                    var payloadData = {
                        data: thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PAYLOAD_BLOB /* @min:%2epayloadBlob */],
                        urlString: requestDetails.url,
                        headers: requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HDRS /* @min:%2ehdrs */],
                        timeout: _xhrTimeout,
                        disableXhrSync: _disableXhrSync,
                        disableFetchKeepAlive: _disableFetchKeepAlive
                    };
                    // Only automatically add the following headers if already sending headers and we are not attempting to avoid an options call
                    if (_useHeaders) {
                        if (!_hasHeader(payloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */], _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CACHE_CONTROL)) {
                            payloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */][_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CACHE_CONTROL] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.DEFAULT_CACHE_CONTROL;
                        }
                        if (!_hasHeader(payloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */], _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CONTENT_TYPE_HEADER)) {
                            payloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */][_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CONTENT_TYPE_HEADER] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.DEFAULT_CONTENT_TYPE;
                        }
                    }
                    return payloadData;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            };
            // Special internal method to allow the DebugPlugin to hook embedded objects
            function _getSenderInterface(transports, syncSupport) {
                try {
                    return _sendPostMgr && _sendPostMgr.getSenderInst(transports, syncSupport);
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            _self["_getDbgPlgTargets"] = function () {
                return [_sendInterfaces[0 /* EventSendType.Batched */], _killSwitch, _serializer, _sendInterfaces, _getSendPostMgrConfig(), _urlString, _maxEvtPerBatch];
            };
            function _getSendPostMgrConfig() {
                try {
                    var onCompleteFuncs = {
                        xdrOnComplete: _xdrOncomplete,
                        fetchOnComplete: _fetchOnComplete,
                        xhrOnComplete: _xhrOnComplete,
                        beaconOnRetry: _onBeaconRetry
                    };
                    var config = {
                        enableSendPromise: false,
                        isOneDs: true,
                        disableCredentials: !_sendCredentials,
                        fetchCredentials: _fetchCredentials,
                        disableXhr: false,
                        disableBeacon: !_useBeacons,
                        disableBeaconSync: !_useBeacons,
                        disableFetchKeepAlive: _disableFetchKeepAlive,
                        timeWrapper: _timeoutWrapper,
                        addNoResponse: _addNoResponse,
                        senderOnCompleteCallBack: onCompleteFuncs
                    };
                    return config;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            function _xdrOncomplete(xdr, oncomplete, payload) {
                var response = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.getResponseText)(xdr);
                _doOnComplete(oncomplete, 200, {}, response);
                _handleCollectorResponse(response);
            }
            function _initDefaults() {
                var undefValue;
                _urlString = null;
                _killSwitch = new _KillSwitch__WEBPACK_IMPORTED_MODULE_13__.KillSwitch();
                _paused = false;
                _clockSkewManager = new _ClockSkewManager__WEBPACK_IMPORTED_MODULE_10__.ClockSkewManager();
                _useBeacons = false;
                _outstandingRequests = 0; // Holds the number of outstanding async requests that have not returned a response yet
                _postManager = null;
                _logger = null;
                _sendInterfaces = null;
                _core = null;
                _customHttpInterface = true;
                _queryStringParameters = [];
                _headers = {};
                _batchQueue = [];
                _serializer = null;
                _enableEventTimings = false;
                _cookieMgr = null;
                _isUnloading = false;
                _useHeaders = false;
                _xhrTimeout = undefValue;
                _disableXhrSync = undefValue;
                _disableFetchKeepAlive = undefValue;
                _canHaveReducedPayload = undefValue;
                _addNoResponse = undefValue;
                _unloadHooks = [];
                _sendHook = undefValue;
                _sendListener = undefValue;
                _responseHandlers = [];
                _isInitialized = false;
                _timeoutWrapper = (0,_TimeoutOverrideWrapper__WEBPACK_IMPORTED_MODULE_16__.createTimeoutWrapper)();
                _excludeCsMetaData = false;
                _sendPostMgr = null;
                _maxEvtPerBatch = null;
            }
            function _fetchOnComplete(response, onComplete, resValue, payload) {
                var handleResponse = function (status, headerMap, responseText) {
                    _doOnComplete(onComplete, status, headerMap, responseText);
                    _handleCollectorResponse(responseText);
                };
                var headerMap = {};
                var headers = response[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */];
                if (headers) {
                    headers["forEach"](function (value, name) {
                        headerMap[name] = value;
                    });
                }
                handleResponse(response.status, headerMap, resValue || _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_EMPTY);
            }
            function _xhrOnComplete(request, oncomplete, payload) {
                var response = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.getResponseText)(request);
                _doOnComplete(oncomplete, request.status, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__._getAllResponseHeaders)(request, true), response);
                _handleCollectorResponse(response);
            }
            function _doOnComplete(oncomplete, status, headers, response) {
                try {
                    oncomplete(status, headers, response);
                }
                catch (e) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__._throwInternal)(_logger, 2 /* eLoggingSeverity.WARNING */, 518 /* _eExtendedInternalMessageId.SendPostOnCompleteFailure */, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.dumpObj)(e));
                }
            }
            function _onBeaconRetry(payload, onComplete, canSend) {
                // Custom headers not supported in sendBeacon payload.headers would be ignored
                var internalPayloadData = payload;
                var status = 200;
                var thePayload = internalPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */];
                var theUrl = payload.urlString + (_addNoResponse ? _noResponseQs : _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_EMPTY);
                try {
                    var nav_1 = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.getNavigator)();
                    if (thePayload) {
                        var persistStorage = !!_core.getPlugin("LocalStorage");
                        // Failed to send entire payload so try and split data and try to send as much events as possible
                        var droppedBatches_1 = [];
                        var sentBatches_1 = [];
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                            if (droppedBatches_1 && theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                                var theEvents = theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_EVENTS /* @min:%2eevents */]();
                                for (var lp = 0; lp < theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                                    if (!nav_1.sendBeacon(theUrl, _serializer.getEventBlob(theEvents[lp]))) {
                                        // Can't send anymore, so split the batch and drop the rest
                                        droppedBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */](theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SPLIT /* @min:%2esplit */](lp));
                                        break;
                                    }
                                    else {
                                        sentBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */](theBatch[lp]);
                                    }
                                }
                            }
                            else {
                                // Remove all of the events from the existing batch in the payload as the copy includes the original
                                droppedBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */](theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SPLIT /* @min:%2esplit */](0));
                            }
                        });
                        if (sentBatches_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
                            // Update the payload with the sent batches
                            thePayload.sentEvts = sentBatches_1;
                        }
                        if (!persistStorage) {
                            // Events passed Serializer size validation, log BeaconSendFailure
                            // because it could still be size related but we did not exceed the
                            // configured limit, and sendBeacon could fail for other reasons
                            _sendBatchesNotification(droppedBatches_1, 8006 /* EventBatchNotificationReason.BeaconSendFailure */, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */], true);
                        }
                    }
                    else {
                        status = 0;
                    }
                }
                catch (ex) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__._warnToConsole)(_logger, "Failed to send telemetry using sendBeacon API. Ex:" + (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.dumpObj)(ex));
                    status = 0;
                }
                finally {
                    _doOnComplete(onComplete, status, {}, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_EMPTY);
                }
            }
            function _isBeaconPayload(sendType) {
                // Sync Fetch has the same payload limitation as sendBeacon -- 64kb limit, so treat both as a beacon send
                return sendType === 2 /* EventSendType.SendBeacon */ || sendType === 3 /* EventSendType.SyncFetch */;
            }
            function _adjustSendType(sendType) {
                if (_isUnloading && _isBeaconPayload(sendType)) {
                    sendType = 2 /* EventSendType.SendBeacon */;
                }
                return sendType;
            }
            _self.addHeader = function (name, value) {
                _headers[name] = value;
            };
            _self.removeHeader = function (name) {
                delete _headers[name];
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CAN_SEND_REQUEST /* @min:%2ecanSendRequest */] = function () {
                return _hasIdleConnection() && _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_ALLOW_REQUEST_SENDIN0 /* @min:%2eallowRequestSending */]();
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_QUEUED_REQUESTS /* @min:%2esendQueuedRequests */] = function (sendType, sendReason) {
                if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.isUndefined)(sendType)) {
                    sendType = 0 /* EventSendType.Batched */;
                }
                if (_isUnloading) {
                    sendType = _adjustSendType(sendType);
                    sendReason = 2 /* SendRequestReason.Unload */;
                }
                if (_canSendPayload(_batchQueue, sendType, 0)) {
                    _sendBatches(_clearQueue(), 0, false, sendType, sendReason || 0 /* SendRequestReason.Undefined */);
                }
            };
            _self.isCompletelyIdle = function () {
                return !_paused && _outstandingRequests === 0 && _batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] === 0;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SET_UNLOADING /* @min:%2esetUnloading */] = function (value) {
                _isUnloading = value;
            };
            _self.addBatch = function (theBatch) {
                if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                    // Try and kill the event faster
                    if (_killSwitch.isTenantKilled(theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_I_KEY /* @min:%2eiKey */]())) {
                        return false;
                    }
                    _batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */](theBatch);
                }
                return true;
            };
            /**
             * Queue all the remaining requests to be sent. The requests will be
             * sent using HTML5 Beacons if they are available.
             */
            _self.teardown = function () {
                if (_batchQueue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _sendBatches(_clearQueue(), 0, true, 2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);
                }
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(_unloadHooks, function (hook) {
                    hook && hook.rm && hook.rm();
                });
                _unloadHooks = [];
            };
            /**
             * Pause the sending of requests. No new requests will be sent.
             */
            _self.pause = function () {
                _paused = true;
            };
            /**
             * Resume the sending of requests.
             */
            _self.resume = function () {
                _paused = false;
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_QUEUED_REQUESTS /* @min:%2esendQueuedRequests */](0 /* EventSendType.Batched */, 4 /* SendRequestReason.Resumed */);
            };
            /**
             * Sends a request synchronously to the Aria collector. This api is used to send
             * a request containing a single immediate event.
             *
             * @param batch - The request to be sent.
             * @param sendReason   - The token used to send the request.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_SYNCHRONOUS_BAT10 /* @min:%2esendSynchronousBatch */] = function (batch, sendType, sendReason) {
                // This will not take into account the max connections restriction. Since this is sync, we can
                // only send one of this request at a time and thus should not worry about multiple connections
                // being used to send synchronous events.
                // Increment active connection since we are still going to use a connection to send the request.
                if (batch && batch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                    if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.isNullOrUndefined)(sendType)) {
                        sendType = 1 /* EventSendType.Synchronous */;
                    }
                    if (_isUnloading) {
                        sendType = _adjustSendType(sendType);
                        sendReason = 2 /* SendRequestReason.Unload */;
                    }
                    // For sync requests we will not wait for the clock skew.
                    _sendBatches([batch], 0, false, sendType, sendReason || 0 /* SendRequestReason.Undefined */);
                }
            };
            function _hasIdleConnection() {
                return !_paused && _outstandingRequests < maxConnections;
            }
            function _clearQueue() {
                var theQueue = _batchQueue;
                _batchQueue = [];
                return theQueue;
            }
            function _canSendPayload(theBatches, sendType, retryCnt) {
                var result = false;
                if (theBatches && theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0 && !_paused && _sendInterfaces[sendType] && _serializer) {
                    // Always attempt to send synchronous events don't wait for idle or clockSkew
                    // and don't block retry requests if clockSkew is not yet set
                    result = (sendType !== 0 /* EventSendType.Batched */) || (_hasIdleConnection() && (retryCnt > 0 || _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_ALLOW_REQUEST_SENDIN0 /* @min:%2eallowRequestSending */]()));
                }
                return result;
            }
            function _createDebugBatches(theBatches) {
                var values = {};
                if (theBatches) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(theBatches, function (theBatch, idx) {
                        values[idx] = {
                            iKey: theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_I_KEY /* @min:%2eiKey */](),
                            evts: theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_EVENTS /* @min:%2eevents */]()
                        };
                    });
                }
                return values;
            }
            function _sendBatches(theBatches, retryCount, isTeardown, sendType, sendReason) {
                if (!theBatches || theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] === 0) {
                    // Nothing to do
                    return;
                }
                if (_paused) {
                    _sendBatchesNotification(theBatches, 1 /* EventBatchNotificationReason.Paused */, sendType);
                    return;
                }
                // Make sure that if we are unloading the sendType is a supported version
                sendType = _adjustSendType(sendType);
                try {
                    var orgBatches_1 = theBatches;
                    var isSynchronous_1 = sendType !== 0 /* EventSendType.Batched */;
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.doPerf)(_core, function () { return "HttpManager:_sendBatches"; }, function (perfEvt) {
                        if (perfEvt) {
                            // Perf Monitoring is enabled, so create a "Quick" copy of the original batches so we still report
                            // the original values as part of the perfEvent. This is because theBatches uses .shift() to remove each
                            // batch as they are processed - removing from the original array, so by the time the _createDebugBatches()
                            // function is called the passed in value has changed and therefore the reported value for the perfEvent is incorrect
                            theBatches = theBatches.slice(0);
                        }
                        var droppedBatches = [];
                        var thePayload = null;
                        var serializationStart = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getTime)();
                        var sendInterface = _sendInterfaces[sendType] || (isSynchronous_1 ? _sendInterfaces[1 /* EventSendType.Synchronous */] : _sendInterfaces[0 /* EventSendType.Batched */]);
                        var sendTransport = sendInterface && sendInterface[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__TRANSPORT /* @min:%2e_transport */];
                        // Sync Fetch has the same payload limitation as sendBeacon -- 64kb limit
                        var isReducedPayload = _canHaveReducedPayload && (_isUnloading || _isBeaconPayload(sendType) || (sendTransport === 3 /* TransportType.Beacon */ || (sendInterface._isSync && sendTransport === 2 /* TransportType.Fetch */)));
                        while (_canSendPayload(theBatches, sendType, retryCount)) {
                            var theBatch = theBatches.shift();
                            if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                                if (!_killSwitch.isTenantKilled(theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_I_KEY /* @min:%2eiKey */]())) {
                                    // Make sure we have a payload object
                                    thePayload = thePayload || _serializer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CREATE_PAYLOAD /* @min:%2ecreatePayload */](retryCount, isTeardown, isSynchronous_1, isReducedPayload, sendReason, sendType);
                                    // Add the batch to the current payload
                                    if (!_serializer.appendPayload(thePayload, theBatch, _maxEvtPerBatch)) {
                                        // Entire batch was not added so send the payload and retry adding this batch
                                        _doPayloadSend(thePayload, serializationStart, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getTime)(), sendReason);
                                        serializationStart = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getTime)();
                                        theBatches = [theBatch][_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CONCAT /* @min:%2econcat */](theBatches);
                                        thePayload = null;
                                    }
                                    else if (thePayload.overflow !== null) {
                                        // Total Payload size was exceeded so send the payload and add the unsent as the next batch to send
                                        theBatches = [thePayload.overflow][_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CONCAT /* @min:%2econcat */](theBatches);
                                        thePayload.overflow = null;
                                        _doPayloadSend(thePayload, serializationStart, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getTime)(), sendReason);
                                        serializationStart = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getTime)();
                                        thePayload = null;
                                    }
                                }
                                else {
                                    droppedBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */](theBatch);
                                }
                            }
                        }
                        // Make sure to flush any remaining payload
                        if (thePayload) {
                            _doPayloadSend(thePayload, serializationStart, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getTime)(), sendReason);
                        }
                        if (theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
                            // Add any unsent batches back to the head of the queue
                            _batchQueue = theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_CONCAT /* @min:%2econcat */](_batchQueue);
                        }
                        // Now send notification about any dropped events
                        _sendBatchesNotification(droppedBatches, 8004 /* EventBatchNotificationReason.KillSwitch */, sendType);
                    }, function () { return ({ batches: _createDebugBatches(orgBatches_1), retryCount: retryCount, isTeardown: isTeardown, isSynchronous: isSynchronous_1, sendReason: sendReason, useSendBeacon: _isBeaconPayload(sendType), sendType: sendType }); }, !isSynchronous_1);
                }
                catch (ex) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__._throwInternal)(_logger, 2 /* eLoggingSeverity.WARNING */, 48 /* _eInternalMessageId.CannotSerializeObject */, "Unexpected Exception sending batch: " + (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.dumpObj)(ex));
                }
            }
            function _buildRequestDetails(thePayload, useHeaders) {
                var requestDetails = {
                    url: _urlString,
                    hdrs: {},
                    useHdrs: false // Assume no headers
                };
                if (!useHeaders) {
                    // Attempt to map headers to a query string if possible
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.objForEachKey)(_headers, function (name, value) {
                        if (_collectorHeaderToQs[name]) {
                            _addRequestDetails(requestDetails, _collectorHeaderToQs[name], value, false);
                        }
                        else {
                            // No mapping, so just include in the headers anyway (may not get sent if using sendBeacon())
                            requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HDRS /* @min:%2ehdrs */][name] = value;
                            requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_USE_HDRS /* @min:%2euseHdrs */] = true;
                        }
                    });
                }
                else {
                    // Copy the pre-defined headers into the payload headers
                    requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HDRS /* @min:%2ehdrs */] = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.extend)(requestDetails[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HDRS /* @min:%2ehdrs */], _headers);
                    requestDetails.useHdrs = ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.objKeys)(requestDetails.hdrs)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0);
                }
                _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CLIENT_ID, "NO_AUTH", useHeaders);
                _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CLIENT_VERSION, _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.FullVersionString, useHeaders);
                var apiQsKeys = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_EMPTY;
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(thePayload.apiKeys, function (apiKey) {
                    if (apiQsKeys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        apiQsKeys += ",";
                    }
                    apiQsKeys += apiKey;
                });
                _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_API_KEY, apiQsKeys, useHeaders);
                _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_UPLOAD_TIME, (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.utcNow)().toString(), useHeaders);
                var msfpc = _getMsfpc(thePayload);
                if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(msfpc)) {
                    requestDetails.url += "&ext.intweb.msfpc=" + msfpc;
                }
                if (_clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SHOULD_ADD_CLOCK_SKE1 /* @min:%2eshouldAddClockSkewHeaders */]()) {
                    _addRequestDetails(requestDetails, _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_TIME_DELTA_TO_APPLY, _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_GET_CLOCK_SKEW_HEADE2 /* @min:%2egetClockSkewHeaderValue */](), useHeaders);
                }
                if (_core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_GET_WPARAM /* @min:%2egetWParam */]) {
                    var wParam = _core[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_GET_WPARAM /* @min:%2egetWParam */]();
                    if (wParam >= 0) {
                        requestDetails.url += "&w=" + wParam;
                    }
                }
                for (var i = 0; i < _queryStringParameters[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; i++) {
                    requestDetails.url += "&" + _queryStringParameters[i].name + "=" + _queryStringParameters[i].value;
                }
                return requestDetails;
            }
            function _setTimingValue(timings, name, value) {
                timings[name] = timings[name] || {};
                timings[name][_postManager.identifier] = value;
            }
            function _doPayloadSend(thePayload, serializationStart, serializationCompleted, sendReason) {
                if (thePayload && thePayload.payloadBlob && thePayload.payloadBlob[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var useSendHook_1 = !!_sendHook;
                    var sendInterface_1 = _sendInterfaces[thePayload.sendType];
                    // Send all data using a beacon style transport if closing mode is on or channel was teared down
                    if (!_isBeaconPayload(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */]) && thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_IS_BEACON /* @min:%2eisBeacon */] && thePayload.sendReason === 2 /* SendRequestReason.Unload */) {
                        sendInterface_1 = _sendInterfaces[2 /* EventSendType.SendBeacon */] || _sendInterfaces[3 /* EventSendType.SyncFetch */] || sendInterface_1;
                    }
                    var useHeaders_1 = _useHeaders;
                    // Disable header usage if we know we are using sendBeacon as additional headers are not supported
                    if (thePayload.isBeacon || sendInterface_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__TRANSPORT /* @min:%2e_transport */] === 3 /* TransportType.Beacon */) {
                        useHeaders_1 = false;
                    }
                    var requestDetails_1 = _buildRequestDetails(thePayload, useHeaders_1);
                    useHeaders_1 = useHeaders_1 || requestDetails_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_USE_HDRS /* @min:%2euseHdrs */];
                    var sendEventStart_1 = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getTime)();
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.doPerf)(_core, function () { return "HttpManager:_doPayloadSend"; }, function () {
                        // Increment the send attempt count and add timings after packaging (So it's not serialized in the 1st attempt)
                        for (var batchLp = 0; batchLp < thePayload.batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; batchLp++) {
                            var theBatch = thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_BATCHES /* @min:%2ebatches */][batchLp];
                            var theEvents = theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_EVENTS /* @min:%2eevents */]();
                            for (var evtLp = 0; evtLp < theEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; evtLp++) {
                                var telemetryItem = theEvents[evtLp];
                                if (_enableEventTimings) {
                                    var timings = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_TIMINGS /* @min:%2etimings */] = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_TIMINGS /* @min:%2etimings */] || {};
                                    _setTimingValue(timings, "sendEventStart", sendEventStart_1);
                                    _setTimingValue(timings, "serializationStart", serializationStart);
                                    _setTimingValue(timings, "serializationCompleted", serializationCompleted);
                                }
                                telemetryItem[strSendAttempt] > 0 ? telemetryItem[strSendAttempt]++ : telemetryItem[strSendAttempt] = 1;
                            }
                        }
                        // Note: always sending this notification in a synchronous manner.
                        _sendBatchesNotification(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_BATCHES /* @min:%2ebatches */], (1000 /* EventBatchNotificationReason.SendingUndefined */ + (sendReason || 0 /* SendRequestReason.Undefined */)), thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */], true);
                        // Disabling the use of const because of Issue:
                        // - Task 9227844: [1DS] Some environments and packagers automatically "freeze" objects which are defined as const which causes any mutations to throw
                        // eslint-disable-next-line prefer-const
                        var orgPayloadData = {
                            data: thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PAYLOAD_BLOB /* @min:%2epayloadBlob */],
                            urlString: requestDetails_1.url,
                            headers: requestDetails_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HDRS /* @min:%2ehdrs */],
                            _thePayload: thePayload,
                            _sendReason: sendReason,
                            timeout: _xhrTimeout,
                            disableXhrSync: _disableXhrSync,
                            disableFetchKeepAlive: _disableFetchKeepAlive
                        };
                        // Only automatically add the following headers if already sending headers and we are not attempting to avoid an options call
                        if (useHeaders_1) {
                            if (!_hasHeader(orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */], _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CACHE_CONTROL)) {
                                orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */][_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CACHE_CONTROL] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.DEFAULT_CACHE_CONTROL;
                            }
                            if (!_hasHeader(orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */], _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CONTENT_TYPE_HEADER)) {
                                orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */][_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_CONTENT_TYPE_HEADER] = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.DEFAULT_CONTENT_TYPE;
                            }
                        }
                        var sender = null;
                        if (sendInterface_1) {
                            // Send sync requests if the request is immediate or we are tearing down telemetry.
                            sender = function (payload) {
                                // Notify the clock skew manager that we are sending the first request (Potentially blocking all further requests)
                                _clockSkewManager.firstRequestSent();
                                var onComplete = function (status, headers) {
                                    _retryRequestIfNeeded(status, headers, thePayload, sendReason);
                                };
                                var isSync = thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_IS_TEARDOWN /* @min:%2eisTeardown */] || thePayload.isSync;
                                _sendPostMgr.preparePayload(function (processedPayload) {
                                    try {
                                        sendInterface_1.sendPOST(processedPayload, onComplete, isSync);
                                        if (_sendListener) {
                                            // Send the original payload to the listener
                                            _sendListener(orgPayloadData, processedPayload, isSync, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_IS_BEACON /* @min:%2eisBeacon */]);
                                        }
                                    }
                                    catch (ex) {
                                        _doOnComplete(onComplete, 0, {});
                                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__._warnToConsole)(_logger, "Unexpected exception sending payload. Ex:" + (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.dumpObj)(ex));
                                    }
                                }, _zipPayload, payload, isSync);
                            };
                        }
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.doPerf)(_core, function () { return "HttpManager:_doPayloadSend.sender"; }, function () {
                            if (sender) {
                                if (thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */] === 0 /* EventSendType.Batched */) {
                                    _outstandingRequests++;
                                }
                                // Only call the hook if it's defined and we are not using sendBeacon as additional headers are not supported
                                if (useSendHook_1 && !thePayload.isBeacon && sendInterface_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__TRANSPORT /* @min:%2e_transport */] !== 3 /* TransportType.Beacon */) {
                                    // Create a new IPayloadData that is sent into the hook method, so that the hook method
                                    // can't change the object references to the orgPayloadData (it can still change the content -- mainly the headers)
                                    // Disabling the use of const because of Issue:
                                    // - Task 9227844: [1DS] Some environments and packagers automatically "freeze" objects which are defined as const which causes any mutations to throw
                                    // eslint-disable-next-line prefer-const
                                    var hookData_1 = {
                                        data: orgPayloadData.data,
                                        urlString: orgPayloadData.urlString,
                                        headers: (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.extend)({}, orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_HEADERS /* @min:%2eheaders */]),
                                        timeout: orgPayloadData.timeout,
                                        disableXhrSync: orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_DISABLE_XHR_SYNC /* @min:%2edisableXhrSync */],
                                        disableFetchKeepAlive: orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_DISABLE_FETCH_KEEP_A6 /* @min:%2edisableFetchKeepAlive */]
                                    };
                                    var senderCalled_1 = false;
                                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.doPerf)(_core, function () { return "HttpManager:_doPayloadSend.sendHook"; }, function () {
                                        try {
                                            _sendHook(hookData_1, function (payload) {
                                                senderCalled_1 = true;
                                                // Add back the internal properties
                                                if (!_customHttpInterface && !payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */]) {
                                                    payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */] = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */] || orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__THE_PAYLOAD /* @min:%2e_thePayload */];
                                                    payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__SEND_REASON /* @min:%2e_sendReason */] = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__SEND_REASON /* @min:%2e_sendReason */] || orgPayloadData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__SEND_REASON /* @min:%2e_sendReason */];
                                                }
                                                sender(payload);
                                            }, thePayload.isSync || thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_IS_TEARDOWN /* @min:%2eisTeardown */]);
                                        }
                                        catch (ex) {
                                            if (!senderCalled_1) {
                                                // The hook never called the sender -- assume that it never will
                                                sender(orgPayloadData);
                                            }
                                        }
                                    });
                                }
                                else {
                                    sender(orgPayloadData);
                                }
                            }
                        });
                    }, function () { return ({ thePayload: thePayload, serializationStart: serializationStart, serializationCompleted: serializationCompleted, sendReason: sendReason }); }, thePayload.isSync);
                }
                if (thePayload.sizeExceed && thePayload.sizeExceed[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    // Ensure that we send any discard events for oversize events even when there was no payload to send
                    _sendBatchesNotification(thePayload.sizeExceed, 8003 /* EventBatchNotificationReason.SizeLimitExceeded */, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */]);
                }
                if (thePayload.failedEvts && thePayload.failedEvts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    // Ensure that we send any discard events for events that could not be serialized even when there was no payload to send
                    _sendBatchesNotification(thePayload.failedEvts, 8002 /* EventBatchNotificationReason.InvalidEvent */, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */]);
                }
            }
            function _addEventCompletedTimings(theEvents, sendEventCompleted) {
                if (_enableEventTimings) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(theEvents, function (theEvent) {
                        var timings = theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_TIMINGS /* @min:%2etimings */] = theEvent[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_TIMINGS /* @min:%2etimings */] || {};
                        _setTimingValue(timings, "sendEventCompleted", sendEventCompleted);
                    });
                }
            }
            function _retryRequestIfNeeded(status, headers, thePayload, sendReason) {
                var reason = 9000 /* EventBatchNotificationReason.ResponseFailure */;
                var droppedBatches = null;
                var isRetrying = false;
                var backOffTrans = false;
                try {
                    var shouldRetry = true;
                    if (typeof status !== _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.strShimUndefined) {
                        if (headers) {
                            _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SET_CLOCK_SKEW /* @min:%2esetClockSkew */](headers[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_TIME_DELTA_HEADER]);
                            var killDuration = headers[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_KILL_DURATION_HEADER] || headers["kill-duration-seconds"];
                            (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(_killSwitch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SET_KILL_SWITCH_TENA11 /* @min:%2esetKillSwitchTenants */](headers[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_KILL_TOKENS_HEADER], killDuration), function (killToken) {
                                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_BATCHES /* @min:%2ebatches */], function (theBatch) {
                                    if (theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_I_KEY /* @min:%2eiKey */]() === killToken) {
                                        // Make sure we have initialized the array
                                        droppedBatches = droppedBatches || [];
                                        // Create a copy of the batch with all of the events (and more importantly the action functions)
                                        var removedEvents = theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SPLIT /* @min:%2esplit */](0);
                                        // And then remove the events for the payload batch and reduce the actual number of processed
                                        thePayload.numEvents -= removedEvents[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_COUNT /* @min:%2ecount */]();
                                        droppedBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_PUSH /* @min:%2epush */](removedEvents);
                                    }
                                });
                            });
                        }
                        // Disabling triple-equals rule to avoid httpOverrides from failing because they are returning a string value
                        // tslint:disable-next-line:triple-equals
                        if (status == 200 || status == 204) {
                            // Response was successfully sent
                            reason = 200 /* EventBatchNotificationReason.Complete */;
                            return;
                        }
                        if (!(0,_RetryPolicy__WEBPACK_IMPORTED_MODULE_14__.retryPolicyShouldRetryForStatus)(status) || thePayload.numEvents <= 0) {
                            // Only retry for specific response codes and if there is still events after kill switch processing
                            shouldRetry = false;
                        }
                        // Derive the notification response from the HttpStatus Code
                        reason = 9000 /* EventBatchNotificationReason.ResponseFailure */ + (status % 1000);
                    }
                    if (shouldRetry) {
                        // The events should be retried -- so change notification to requeue them
                        reason = 100 /* EventBatchNotificationReason.RequeueEvents */;
                        var retryCount_1 = thePayload.retryCnt;
                        if (thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */] === 0 /* EventSendType.Batched */) {
                            // attempt to resend the entire batch
                            if (retryCount_1 < maxRequestRetriesBeforeBackoff) {
                                isRetrying = true;
                                _doAction(function () {
                                    // try to resend the same batches
                                    if (thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */] === 0 /* EventSendType.Batched */) {
                                        // Reduce the outstanding request count (if this was an async request) as we didn't reduce the count
                                        // previously and we are about to reschedule our retry attempt and we want an attempt to send
                                        // to occur, it's also required to ensure that a follow up handleRequestFinished() call occurs
                                        _outstandingRequests--;
                                    }
                                    _sendBatches(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_BATCHES /* @min:%2ebatches */], retryCount_1 + 1, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_IS_TEARDOWN /* @min:%2eisTeardown */], _isUnloading ? 2 /* EventSendType.SendBeacon */ : thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */], 5 /* SendRequestReason.Retry */);
                                }, _isUnloading, (0,_RetryPolicy__WEBPACK_IMPORTED_MODULE_14__.retryPolicyGetMillisToBackoffForRetry)(retryCount_1));
                            }
                            else {
                                backOffTrans = true;
                                if (_isUnloading) {
                                    // we are unloading so don't try and requeue the events otherwise let the events get requeued and resent during the backoff sending
                                    // This will also cause the events to be purged based on the priority (if necessary)
                                    reason = 8001 /* EventBatchNotificationReason.NonRetryableStatus */;
                                }
                            }
                        }
                    }
                }
                finally {
                    if (!isRetrying) {
                        // Make sure the clockSkewManager doesn't blocking further sending of requests once we have a proper response
                        // This won't override any previously sent clock Skew value
                        _clockSkewManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SET_CLOCK_SKEW /* @min:%2esetClockSkew */]();
                        _handleRequestFinished(thePayload, reason, sendReason, backOffTrans);
                    }
                    _sendBatchesNotification(droppedBatches, 8004 /* EventBatchNotificationReason.KillSwitch */, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */]);
                }
            }
            function _handleRequestFinished(thePayload, batchReason, sendReason, backOffTrans) {
                try {
                    if (backOffTrans) {
                        // Slow down the transmission requests
                        _postManager[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN__BACK_OFF_TRANSMISSI12 /* @min:%2e_backOffTransmission */]();
                    }
                    var theBatches = thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_BATCHES /* @min:%2ebatches */];
                    if (batchReason === 200 /* EventBatchNotificationReason.Complete */) {
                        theBatches = thePayload.sentEvts || thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_BATCHES /* @min:%2ebatches */];
                        if (!backOffTrans && !thePayload.isSync) {
                            // We have a successful async response, so the lets open the floodgates
                            // The reason for checking isSync is to avoid unblocking if beacon send occurred as it
                            // doesn't wait for a response.
                            _postManager._clearBackOff();
                        }
                        _addCompleteTimings(theBatches);
                    }
                    // Send the notifications synchronously
                    _sendBatchesNotification(theBatches, batchReason, thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */], true);
                }
                finally {
                    if (thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */] === 0 /* EventSendType.Batched */) {
                        // we always need to decrement this value otherwise the httpmanager locks up and won't send any more events
                        _outstandingRequests--;
                        // Don't try to send additional queued events if this is a retry operation as the retried
                        // response will eventually call _handleRequestFinished for the retried event
                        if (sendReason !== 5 /* SendRequestReason.Retry */) {
                            // Try and send any other queued batched events
                            _self.sendQueuedRequests(thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_SEND_TYPE /* @min:%2esendType */], sendReason);
                        }
                    }
                }
            }
            function _addCompleteTimings(theBatches) {
                if (_enableEventTimings) {
                    var sendEventCompleted_1 = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.getTime)();
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_5__.arrForEach)(theBatches, function (theBatch) {
                        if (theBatch && theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                            _addEventCompletedTimings(theBatch[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_EVENTS /* @min:%2eevents */](), sendEventCompleted_1);
                        }
                    });
                }
            }
            function _doAction(cb, isSync, interval) {
                if (isSync) {
                    cb();
                }
                else {
                    _timeoutWrapper.set(cb, interval);
                }
            }
            function _getMsfpc(thePayload) {
                for (var lp = 0; lp < thePayload.batches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                    var msfpc = thePayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_BATCHES /* @min:%2ebatches */][lp].Msfpc();
                    if (msfpc) {
                        return encodeURIComponent(msfpc);
                    }
                }
                return _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_EMPTY;
            }
            function _handleCollectorResponse(responseText) {
                var responseHandlers = _responseHandlers;
                try {
                    for (var i = 0; i < responseHandlers[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */]; i++) {
                        try {
                            responseHandlers[i](responseText);
                        }
                        catch (e) {
                            (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 519 /* _eExtendedInternalMessageId.PostResponseHandler */, "Response handler failed: " + e);
                        }
                    }
                    if (responseText) {
                        var response = JSON.parse(responseText);
                        if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(response.webResult) && (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(response.webResult[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_MSFPC])) {
                            // Set cookie
                            _cookieMgr.set("MSFPC", response.webResult[_InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_MSFPC], 365 * 86400);
                        }
                    }
                }
                catch (ex) {
                    // Doing nothing
                }
            }
            function _sendBatchesNotification(theBatches, batchReason, sendType, sendSync) {
                if (theBatches && theBatches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_17__._DYN_LENGTH /* @min:%2elength */] > 0 && actions) {
                    var theAction_1 = actions[_getNotificationAction(batchReason)];
                    if (theAction_1) {
                        var isSyncRequest_1 = sendType !== 0 /* EventSendType.Batched */;
                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_7__.doPerf)(_core, function () { return "HttpManager:_sendBatchesNotification"; }, function () {
                            _doAction(function () {
                                try {
                                    theAction_1.call(actions, theBatches, batchReason, isSyncRequest_1, sendType);
                                }
                                catch (e) {
                                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_8__._throwInternal)(_logger, 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, "send request notification failed: " + e);
                                }
                            }, sendSync || isSyncRequest_1, 0);
                        }, function () { return ({ batches: _createDebugBatches(theBatches), reason: batchReason, isSync: isSyncRequest_1, sendSync: sendSync, sendType: sendType }); }, !isSyncRequest_1);
                    }
                }
            }
            function _getNotificationAction(reason) {
                var action = _eventActionMap[reason];
                if (!(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isValueAssigned)(action)) {
                    action = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_OTHER;
                    if (reason >= 9000 /* EventBatchNotificationReason.ResponseFailure */ && reason <= 9999 /* EventBatchNotificationReason.ResponseFailureMax */) {
                        action = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_RESPONSE_FAIL;
                    }
                    else if (reason >= 8000 /* EventBatchNotificationReason.EventsDropped */ && reason <= 8999 /* EventBatchNotificationReason.EventsDroppedMax */) {
                        action = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_DROPPED;
                    }
                    else if (reason >= 1000 /* EventBatchNotificationReason.SendingUndefined */ && reason <= 1999 /* EventBatchNotificationReason.SendingEventMax */) {
                        action = _InternalConstants__WEBPACK_IMPORTED_MODULE_12__.STR_SENDING;
                    }
                }
                return action;
            }
        });
    }
// Removed Stub for HttpManager.prototype.initialize.
// Removed Stub for HttpManager.prototype.addHeader.
// Removed Stub for HttpManager.prototype.removeHeader.
// Removed Stub for HttpManager.prototype.addResponseHandler.
// Removed Stub for HttpManager.prototype.addBatch.
// Removed Stub for HttpManager.prototype.canSendRequest.
// Removed Stub for HttpManager.prototype.sendQueuedRequests.
// Removed Stub for HttpManager.prototype.isCompletelyIdle.
// Removed Stub for HttpManager.prototype.setUnloading.
// Removed Stub for HttpManager.prototype.teardown.
// Removed Stub for HttpManager.prototype.pause.
// Removed Stub for HttpManager.prototype.resume.
// Removed Stub for HttpManager.prototype.sendSynchronousBatch.
// Removed Stub for HttpManager.prototype.serializeOfflineEvt.
// Removed Stub for HttpManager.prototype.getOfflineRequestDetails.
// Removed Stub for HttpManager.prototype.createOneDSPayload.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    HttpManager.__ieDyn=1;

    return HttpManager;
}());

//# sourceMappingURL=HttpManager.js.map

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClockSkewManager: () => (/* binding */ ClockSkewManager)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* ClockSkewManager.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
*/


/**
* Class to manage clock skew correction.
*/
var ClockSkewManager = /** @class */ (function () {
    function ClockSkewManager() {
        var _allowRequestSending = true;
        var _shouldAddClockSkewHeaders = true;
        var _isFirstRequest = true;
        var _clockSkewHeaderValue = "use-collector-delta";
        var _clockSkewSet = false;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ClockSkewManager, this, function (_self) {
            /**
             * Determine if requests can be sent.
             * @returns True if requests can be sent, false otherwise.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_ALLOW_REQUEST_SENDIN0 /* @min:%2eallowRequestSending */] = function () {
                return _allowRequestSending;
            };
            /**
             * Tells the ClockSkewManager that it should assume that the first request has now been sent,
             * If this method had not yet been called AND the clock Skew had not been set this will set
             * allowRequestSending to false until setClockSet() is called.
             */
            _self.firstRequestSent = function () {
                if (_isFirstRequest) {
                    _isFirstRequest = false;
                    if (!_clockSkewSet) {
                        // Block sending until we get the first clock Skew
                        _allowRequestSending = false;
                    }
                }
            };
            /**
             * Determine if clock skew headers should be added to the request.
             * @returns True if clock skew headers should be added, false otherwise.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SHOULD_ADD_CLOCK_SKE1 /* @min:%2eshouldAddClockSkewHeaders */] = function () {
                return _shouldAddClockSkewHeaders;
            };
            /**
             * Gets the clock skew header value.
             * @returns The clock skew header value.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_CLOCK_SKEW_HEADE2 /* @min:%2egetClockSkewHeaderValue */] = function () {
                return _clockSkewHeaderValue;
            };
            /**
             * Sets the clock skew header value. Once clock skew is set this method
             * is no-op.
             * @param timeDeltaInMillis - Time delta to be saved as the clock skew header value.
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SET_CLOCK_SKEW /* @min:%2esetClockSkew */] = function (timeDeltaInMillis) {
                if (!_clockSkewSet) {
                    if (timeDeltaInMillis) {
                        _clockSkewHeaderValue = timeDeltaInMillis;
                        _shouldAddClockSkewHeaders = true;
                        _clockSkewSet = true;
                    }
                    else {
                        _shouldAddClockSkewHeaders = false;
                    }
                    // Unblock sending
                    _allowRequestSending = true;
                }
            };
        });
    }
// Removed Stub for ClockSkewManager.prototype.allowRequestSending.
// Removed Stub for ClockSkewManager.prototype.firstRequestSent.
// Removed Stub for ClockSkewManager.prototype.shouldAddClockSkewHeaders.
// Removed Stub for ClockSkewManager.prototype.getClockSkewHeaderValue.
// Removed Stub for ClockSkewManager.prototype.setClockSkew.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    ClockSkewManager.__ieDyn=1;

    return ClockSkewManager;
}());

//# sourceMappingURL=ClockSkewManager.js.map

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KillSwitch: () => (/* binding */ KillSwitch)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* KillSwitch.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
*/



var SecToMsMultiplier = 1000;
/**
* Class to stop certain tenants sending events.
*/
var KillSwitch = /** @class */ (function () {
    function KillSwitch() {
        var _killedTokenDictionary = {};
        function _normalizeTenants(values) {
            var result = [];
            if (values) {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(values, function (value) {
                    result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PUSH /* @min:%2epush */]((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(value));
                });
            }
            return result;
        }
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(KillSwitch, this, function (_self) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SET_KILL_SWITCH_TENA11 /* @min:%2esetKillSwitchTenants */] = function (killTokens, killDuration) {
                if (killTokens && killDuration) {
                    try {
                        var killedTokens = _normalizeTenants(killTokens[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](","));
                        if (killDuration === "this-request-only") {
                            return killedTokens;
                        }
                        var durationMs = parseInt(killDuration, 10) * SecToMsMultiplier;
                        for (var i = 0; i < killedTokens[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */]; ++i) {
                            _killedTokenDictionary[killedTokens[i]] = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.utcNow)() + durationMs;
                        }
                    }
                    catch (ex) {
                        return [];
                    }
                }
                return [];
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_IS_TENANT_KILLED /* @min:%2eisTenantKilled */] = function (tenantToken) {
                var killDictionary = _killedTokenDictionary;
                var name = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(tenantToken);
                if (killDictionary[name] !== undefined && killDictionary[name] > (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.utcNow)()) {
                    return true;
                }
                delete killDictionary[name];
                return false;
            };
        });
    }
// Removed Stub for KillSwitch.prototype.setKillSwitchTenants.
// Removed Stub for KillSwitch.prototype.isTenantKilled.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    KillSwitch.__ieDyn=1;

    return KillSwitch;
}());

//# sourceMappingURL=KillSwitch.js.map

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   retryPolicyGetMillisToBackoffForRetry: () => (/* binding */ retryPolicyGetMillisToBackoffForRetry),
/* harmony export */   retryPolicyShouldRetryForStatus: () => (/* binding */ retryPolicyShouldRetryForStatus)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */

/**
* RetryPolicy.ts
* @author Abhilash Panwar (abpanwar)
* @copyright Microsoft 2018
*/
var RandomizationLowerThreshold = 0.8;
var RandomizationUpperThreshold = 1.2;
var BaseBackoff = 3000;
var MaxBackoff = 600000;
/**
 * Determine if the request should be retried for the given status code.
 * The below expression reads that we should only retry for:
 *      - HttpStatusCodes that are smaller than 300.
 *      - HttpStatusCodes greater or equal to 500 (except for 501-NotImplement
 *        and 505-HttpVersionNotSupport).
 *      - HttpStatusCode 408-RequestTimeout.
 *      - HttpStatusCode 429.
 * This is based on Microsoft.WindowsAzure.Storage.RetryPolicies.ExponentialRetry class
 * @param httpStatusCode - The status code returned for the request.
 * @returns True if request should be retried, false otherwise.
 */
function retryPolicyShouldRetryForStatus(httpStatusCode) {
    /* tslint:disable:triple-equals */
    // Disabling triple-equals rule to avoid httpOverrides from failing because they are returning a string value
    return !((httpStatusCode >= 300 && httpStatusCode < 500 && httpStatusCode != 429)
        || (httpStatusCode == 501)
        || (httpStatusCode == 505));
    /* tslint:enable:triple-equals */
}
/**
 * Gets the number of milliseconds to back off before retrying the request. The
 * back off duration is exponentially scaled based on the number of retries already
 * done for the request.
 * @param retriesSoFar - The number of times the request has already been retried.
 * @returns The back off duration for the request before it can be retried.
 */
function retryPolicyGetMillisToBackoffForRetry(retriesSoFar) {
    var waitDuration = 0;
    var minBackoff = BaseBackoff * RandomizationLowerThreshold;
    var maxBackoff = BaseBackoff * RandomizationUpperThreshold;
    var randomBackoff = (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mathFloor)(Math.random() * (maxBackoff - minBackoff)) + minBackoff;
    waitDuration = Math.pow(2, retriesSoFar) * randomBackoff;
    return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.mathMin)(waitDuration, MaxBackoff);
}
//# sourceMappingURL=RetryPolicy.js.map

/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Serializer: () => (/* binding */ Serializer)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
/* harmony import */ var _EventBatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(66);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(67);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* Serializer.ts
* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)
* @copyright Microsoft 2018-2020
*/
// @skip-file-minify





/**
 * Note: This is an optimization for V8-based browsers. When V8 concatenates a string,
 * the strings are only joined logically using a "cons string" or "constructed/concatenated
 * string". These containers keep references to one another and can result in very large
 * memory usage. For example, if a 2MB string is constructed by concatenating 4 bytes
 * together at a time, the memory usage will be ~44MB; so ~22x increase. The strings are
 * only joined together when an operation requiring their joining takes place, such as
 * substr(). This function is called when adding data to this buffer to ensure these
 * types of strings are periodically joined to reduce the memory footprint.
 * Setting to every 20 events as the JSON.stringify() may have joined many strings
 * and calling this too much causes a minor delay while processing.
 */
var _MAX_STRING_JOINS = 20;
// Max Size set by One Collector: https://msazure.visualstudio.com/OneDsCollector/_git/Collector?path=/Services/Azure/CollectorWorkerRoleAzure/ServiceConfiguration.Cloud.cscfg
var RequestSizeLimitBytes = 3145728; // approx 3.15 Mb
var BeaconRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)
var MaxRecordSize = 2000000; // approx 2 Mb
var MaxBeaconRecordSize = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.mathMin)(MaxRecordSize, BeaconRequestSizeLimitBytes);
var metadata = "metadata";
var f = "f";
var rCheckDot = /\./;
/**
* Class to handle serialization of event and request.
* Currently uses Bond for serialization. Please note that this may be subject to change.
*/
var Serializer = /** @class */ (function () {
    /**
     * Constructs a new instance of the Serializer class
     * @param perfManager - The performance manager to use for tracking performance
     * @param valueSanitizer - The value sanitizer to use for sanitizing field values
     * @param stringifyObjects - Should objects be stringified before being sent
     * @param enableCompoundKey - Should compound keys be enabled (defaults to false)
     * @param getEncodedTypeOverride - The callback to get the encoded type for a property defaults to ({@link getCommonSchemaMetaData }(...))
     * @param excludeCsMetaData - (!DANGER!) Should metadata be populated when encoding the event blob (defaults to false) - PII data will NOT be tagged as PII for backend processing
     * @param cfg channel cfg for setting request and record size limit
     */
    function Serializer(perfManager, valueSanitizer, stringifyObjects, enableCompoundKey, getEncodedTypeOverride, excludeCsMetaData, cfg) {
        var strData = "data";
        var strBaseData = "baseData";
        var strExt = "ext";
        var _checkForCompoundkey = !!enableCompoundKey;
        var _processSubKeys = true;
        var _theSanitizer = valueSanitizer;
        var _isReservedCache = {};
        var _excludeCsMetaData = !!excludeCsMetaData;
        var _getEncodedType = getEncodedTypeOverride || _microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.getCommonSchemaMetaData;
        var _sizeCfg = _getSizeLimtCfg(cfg);
        var _requestSizeLimitBytes = _validateSizeLimit(_sizeCfg.requestLimit, RequestSizeLimitBytes, 0);
        var _beaconRequestSizeLimitBytes = _validateSizeLimit(_sizeCfg.requestLimit, BeaconRequestSizeLimitBytes, 1);
        var _maxRecordSize = _validateSizeLimit(_sizeCfg.recordLimit, MaxRecordSize, 0);
        var _maxBeaconRecordSize = Math.min(_validateSizeLimit(_sizeCfg.recordLimit, MaxBeaconRecordSize, 1), _beaconRequestSizeLimitBytes);
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Serializer, this, function (_self) {
            _self.createPayload = function (retryCnt, isTeardown, isSync, isReducedPayload, sendReason, sendType) {
                return {
                    apiKeys: [],
                    payloadBlob: _InternalConstants__WEBPACK_IMPORTED_MODULE_5__.STR_EMPTY,
                    overflow: null,
                    sizeExceed: [],
                    failedEvts: [],
                    batches: [],
                    numEvents: 0,
                    retryCnt: retryCnt,
                    isTeardown: isTeardown,
                    isSync: isSync,
                    isBeacon: isReducedPayload,
                    sendType: sendType,
                    sendReason: sendReason
                };
            };
            _self.appendPayload = function (payload, theBatch, maxEventsPerBatch) {
                var canAddEvents = payload && theBatch && !payload.overflow;
                if (canAddEvents) {
                    (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.doPerf)(perfManager, function () { return "Serializer:appendPayload"; }, function () {
                        var theEvents = theBatch.events();
                        var payloadBlob = payload.payloadBlob;
                        var payloadEvents = payload.numEvents;
                        var eventsAdded = false;
                        var sizeExceeded = [];
                        var failedEvts = [];
                        var isBeaconPayload = payload.isBeacon;
                        var requestMaxSize = isBeaconPayload ? _beaconRequestSizeLimitBytes : _requestSizeLimitBytes;
                        var recordMaxSize = isBeaconPayload ? _maxBeaconRecordSize : _maxRecordSize;
                        var lp = 0;
                        var joinCount = 0;
                        while (lp < theEvents.length) {
                            var theEvent = theEvents[lp];
                            if (theEvent) {
                                if (payloadEvents >= maxEventsPerBatch) {
                                    // Maximum events per payload reached, so don't add any more
                                    payload.overflow = theBatch.split(lp);
                                    break;
                                }
                                var eventBlob = _self.getEventBlob(theEvent);
                                if (eventBlob && eventBlob.length <= recordMaxSize) {
                                    // This event will fit into the payload
                                    var blobLength = eventBlob.length;
                                    var currentSize = payloadBlob.length;
                                    if (currentSize + blobLength > requestMaxSize) {
                                        // Request or batch size exceeded, so don't add any more to the payload
                                        payload.overflow = theBatch.split(lp);
                                        break;
                                    }
                                    if (payloadBlob) {
                                        payloadBlob += "\n";
                                    }
                                    payloadBlob += eventBlob;
                                    joinCount++;
                                    // v8 memory optimization only
                                    if (joinCount > _MAX_STRING_JOINS) {
                                        // this substr() should cause the constructed string to join
                                        (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.strSubstr)(payloadBlob, 0, 1);
                                        joinCount = 0;
                                    }
                                    eventsAdded = true;
                                    payloadEvents++;
                                }
                                else {
                                    if (eventBlob) {
                                        // Single event size exceeded so remove from the batch
                                        sizeExceeded.push(theEvent);
                                    }
                                    else {
                                        failedEvts.push(theEvent);
                                    }
                                    // We also need to remove this event from the existing array, otherwise a notification will be sent
                                    // indicating that it was successfully sent
                                    theEvents.splice(lp, 1);
                                    lp--;
                                }
                            }
                            lp++;
                        }
                        if (sizeExceeded.length > 0) {
                            payload.sizeExceed.push(_EventBatch__WEBPACK_IMPORTED_MODULE_4__.EventBatch.create(theBatch.iKey(), sizeExceeded));
                            // Remove the exceeded events from the batch
                        }
                        if (failedEvts.length > 0) {
                            payload.failedEvts.push(_EventBatch__WEBPACK_IMPORTED_MODULE_4__.EventBatch.create(theBatch.iKey(), failedEvts));
                            // Remove the failed events from the batch
                        }
                        if (eventsAdded) {
                            payload.batches.push(theBatch);
                            payload.payloadBlob = payloadBlob;
                            payload.numEvents = payloadEvents;
                            var apiKey = theBatch.iKey();
                            if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.arrIndexOf)(payload.apiKeys, apiKey) === -1) {
                                payload.apiKeys.push(apiKey);
                            }
                        }
                    }, function () { return ({ payload: payload, theBatch: { iKey: theBatch.iKey(), evts: theBatch.events() }, max: maxEventsPerBatch }); });
                }
                return canAddEvents;
            };
            _self.getEventBlob = function (eventData) {
                try {
                    return (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_3__.doPerf)(perfManager, function () { return "Serializer.getEventBlob"; }, function () {
                        var serializedEvent = {};
                        // Adding as dynamic keys for v8 performance
                        serializedEvent.name = eventData.name;
                        serializedEvent.time = eventData.time;
                        serializedEvent.ver = eventData.ver;
                        serializedEvent.iKey = "o:" + (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.getTenantId)(eventData.iKey);
                        // Assigning local var so usage in part b/c don't throw if there is no ext
                        var serializedExt = {};
                        var _addMetadataCallback;
                        if (!_excludeCsMetaData) {
                            _addMetadataCallback = function (pathKeys, key, value) {
                                _addJSONPropertyMetaData(_getEncodedType, serializedExt, pathKeys, key, value);
                            };
                        }
                        // Part A
                        var eventExt = eventData[strExt];
                        if (eventExt) {
                            // Only assign ext if the event had one (There are tests covering this use case)
                            serializedEvent[strExt] = serializedExt;
                            (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.objForEachKey)(eventExt, function (key, value) {
                                var data = serializedExt[key] = {};
                                // Don't include a metadata callback as we don't currently set metadata Part A fields
                                _processPathKeys(value, data, "ext." + key, true, null, null, true);
                            });
                        }
                        var serializedData = serializedEvent[strData] = {};
                        serializedData.baseType = eventData.baseType;
                        var serializedBaseData = serializedData[strBaseData] = {};
                        // Part B
                        _processPathKeys(eventData.baseData, serializedBaseData, strBaseData, false, [strBaseData], _addMetadataCallback, _processSubKeys);
                        // Part C
                        _processPathKeys(eventData.data, serializedData, strData, false, [], _addMetadataCallback, _processSubKeys);
                        return JSON.stringify(serializedEvent);
                    }, function () { return ({ item: eventData }); });
                }
                catch (e) {
                    return null;
                }
            };
            function _isReservedField(path, name) {
                var result = _isReservedCache[path];
                if (result === undefined) {
                    if (path.length >= 7) {
                        // Do not allow the changing of fields located in the ext.metadata or ext.web extension
                        result = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.strStartsWith)(path, "ext.metadata") || (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.strStartsWith)(path, "ext.web");
                    }
                    _isReservedCache[path] = result;
                }
                return result;
            }
            function _processPathKeys(srcObj, target, thePath, checkReserved, metadataPathKeys, metadataCallback, processSubKeys) {
                (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.objForEachKey)(srcObj, function (key, srcValue) {
                    var prop = null;
                    if (srcValue || (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.isValueAssigned)(srcValue)) {
                        var path = thePath;
                        var name_1 = key;
                        var theMetaPathKeys = metadataPathKeys;
                        var destObj = target;
                        // Handle keys with embedded '.', like "TestObject.testProperty"
                        if (_checkForCompoundkey && !checkReserved && rCheckDot.test(key)) {
                            var subKeys = key.split(".");
                            var keyLen = subKeys.length;
                            if (keyLen > 1) {
                                if (theMetaPathKeys) {
                                    // Create a copy of the meta path keys so we can add the extra ones
                                    theMetaPathKeys = theMetaPathKeys.slice();
                                }
                                for (var lp = 0; lp < keyLen - 1; lp++) {
                                    var subKey = subKeys[lp];
                                    // Add/reuse the sub key object
                                    destObj = destObj[subKey] = destObj[subKey] || {};
                                    path += "." + subKey;
                                    if (theMetaPathKeys) {
                                        theMetaPathKeys.push(subKey);
                                    }
                                }
                                name_1 = subKeys[keyLen - 1];
                            }
                        }
                        var isReserved = checkReserved && _isReservedField(path, name_1);
                        if (!isReserved && _theSanitizer && _theSanitizer.handleField(path, name_1)) {
                            prop = _theSanitizer.value(path, name_1, srcValue, stringifyObjects);
                        }
                        else {
                            prop = (0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_1__.sanitizeProperty)(name_1, srcValue, stringifyObjects);
                        }
                        if (prop) {
                            // Set the value
                            var newValue = prop.value;
                            destObj[name_1] = newValue;
                            if (metadataCallback) {
                                metadataCallback(theMetaPathKeys, name_1, prop);
                            }
                            if (processSubKeys && typeof newValue === "object" && !(0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(newValue)) {
                                var newPath = theMetaPathKeys;
                                if (newPath) {
                                    newPath = newPath.slice();
                                    newPath.push(name_1);
                                }
                                // Make sure we process sub objects as well (for value sanitization and metadata)
                                _processPathKeys(srcValue, newValue, path + "." + name_1, checkReserved, newPath, metadataCallback, processSubKeys);
                            }
                        }
                    }
                });
            }
        });
    }
// Removed Stub for Serializer.prototype.createPayload.
// Removed Stub for Serializer.prototype.appendPayload.
// Removed Stub for Serializer.prototype.getEventBlob.
// Removed Stub for Serializer.prototype.handleField.
// Removed Stub for Serializer.prototype.getSanitizer.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    Serializer.__ieDyn=1;

    return Serializer;
}());

function _validateSizeLimit(cfgVal, defaultVal, idx) {
    if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(cfgVal)) {
        var val = cfgVal[idx];
        if (val > 0 && val <= defaultVal) {
            return val;
        }
    }
    return defaultVal;
}
function _getSizeLimtCfg(cfg) {
    var defaultCfg = {};
    if (cfg && cfg.requestLimit) {
        return cfg.requestLimit;
    }
    return defaultCfg;
}
/**
 * @ignore
 * @param getEncodedType - The function to get the encoded type for the property
 * @param json - The json object to add the metadata to
 * @param propKeys - The property keys to add to the metadata
 * @param name - The name of the property
 * @param propertyValue - The property value
 */
function _addJSONPropertyMetaData(getEncodedType, json, propKeys, name, propertyValue) {
    if (propertyValue && json) {
        var encodedTypeValue = getEncodedType(propertyValue.value, propertyValue.kind, propertyValue.propertyType);
        if (encodedTypeValue > -1) {
            // Add the root metadata
            var metaData = json[metadata];
            if (!metaData) {
                // Sets the root 'f'
                metaData = json[metadata] = { f: {} };
            }
            var metaTarget = metaData[f];
            if (!metaTarget) {
                // This can occur if someone has manually added an ext.metadata object
                // Such as ext.metadata.privLevel and ext.metadata.privTags
                metaTarget = metaData[f] = {};
            }
            // Traverse the metadata path and build each object (contains an 'f' key) -- if required
            if (propKeys) {
                for (var lp = 0; lp < propKeys.length; lp++) {
                    var key = propKeys[lp];
                    if (!metaTarget[key]) {
                        metaTarget[key] = { f: {} };
                    }
                    var newTarget = metaTarget[key][f];
                    if (!newTarget) {
                        // Not expected, but can occur if the metadata context was pre-created as part of the event
                        newTarget = metaTarget[key][f] = {};
                    }
                    metaTarget = newTarget;
                }
            }
            metaTarget = metaTarget[name] = {};
            if ((0,_microsoft_1ds_core_js__WEBPACK_IMPORTED_MODULE_2__.isArray)(propertyValue.value)) {
                metaTarget["a"] = {
                    t: encodedTypeValue
                };
            }
            else {
                metaTarget["t"] = encodedTypeValue;
            }
        }
    }
}
//# sourceMappingURL=Serializer.js.map

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTimeoutWrapper: () => (/* binding */ createTimeoutWrapper)
/* harmony export */ });
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/*
 * 1DS JS SDK POST plugin, 4.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * (Microsoft Internal Only)
 */
/**
* TimeoutOverrideWrapper.ts
* @author  Nev Wylie (newylie)
* @copyright Microsoft 2022
* Simple internal timeout wrapper
*/

function createTimeoutWrapper(argSetTimeout, argClearTimeout) {
    return {
        set: function (callback, ms) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            return (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_0__.scheduleTimeoutWith)([argSetTimeout, argClearTimeout], callback, ms, args);
        }
    };
}
//# sourceMappingURL=TimeoutOverrideWrapper.js.map

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appInsightsClientFactory: () => (/* binding */ appInsightsClientFactory)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(105);
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


const appInsightsClientFactory = async (connectionString, machineId, sessionId, xhrOverride, replacementOptions) => {
    let appInsightsClient;
    try {
        const basicAISDK = await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 106));
        const extensionConfig = {};
        if (xhrOverride) {
            // Configure the channel to use a XHR Request override since it's not available in node
            const channelConfig = {
                alwaysUseXhrOverride: true,
                httpXHROverride: xhrOverride
            };
            extensionConfig[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_0__.BreezeChannelIdentifier] = channelConfig;
        }
        let instrumentationKey;
        if (!connectionString.startsWith("InstrumentationKey=")) {
            instrumentationKey = connectionString;
        }
        const authConfig = instrumentationKey ? { instrumentationKey } : { connectionString };
        appInsightsClient = new basicAISDK.ApplicationInsights({
            ...authConfig,
            disableAjaxTracking: true,
            disableExceptionTracking: true,
            disableFetchTracking: true,
            disableCorrelationHeaders: true,
            disableCookiesUsage: true,
            autoTrackPageVisitTime: false,
            emitLineDelimitedJson: false,
            disableInstrumentationKeyValidation: true,
            extensionConfig,
        });
    }
    catch (e) {
        return Promise.reject(e);
    }
    // Sets the appinsights client into a standardized form
    const telemetryClient = {
        logEvent: (eventName, data) => {
            const properties = { ...data?.properties, ...data?.measurements };
            if (replacementOptions?.length) {
                _util__WEBPACK_IMPORTED_MODULE_1__.TelemetryUtil.applyReplacements(properties, replacementOptions);
            }
            appInsightsClient?.track({
                name: eventName,
                data: properties,
                baseType: "EventData",
                ext: { user: { id: machineId, authId: machineId }, app: { sesId: sessionId } },
                baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
            });
        },
        flush: async () => {
            appInsightsClient?.flush(false);
        },
        dispose: async () => {
            const unloadPromise = new Promise((resolve) => {
                appInsightsClient?.unload(true, () => {
                    resolve();
                    appInsightsClient = undefined;
                }, 1000);
            });
            return unloadPromise;
        }
    };
    return telemetryClient;
};
//# sourceMappingURL=appInsightsClientFactory.js.map

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnalyticsPluginIdentifier: () => (/* binding */ AnalyticsPluginIdentifier),
/* harmony export */   BreezeChannelIdentifier: () => (/* binding */ BreezeChannelIdentifier),
/* harmony export */   ConfigurationManager: () => (/* reexport safe */ _Interfaces_IConfig__WEBPACK_IMPORTED_MODULE_15__.ConfigurationManager),
/* harmony export */   ConnectionStringParser: () => (/* reexport safe */ _ConnectionStringParser__WEBPACK_IMPORTED_MODULE_2__.ConnectionStringParser),
/* harmony export */   ContextTagKeys: () => (/* reexport safe */ _Interfaces_Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_16__.ContextTagKeys),
/* harmony export */   CtxTagKeys: () => (/* reexport safe */ _Interfaces_PartAExtensions__WEBPACK_IMPORTED_MODULE_19__.CtxTagKeys),
/* harmony export */   DEFAULT_BREEZE_ENDPOINT: () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BREEZE_ENDPOINT),
/* harmony export */   DEFAULT_BREEZE_PATH: () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BREEZE_PATH),
/* harmony export */   Data: () => (/* reexport safe */ _Telemetry_Common_Data__WEBPACK_IMPORTED_MODULE_13__.Data),
/* harmony export */   DisabledPropertyName: () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.DisabledPropertyName),
/* harmony export */   DistributedTracingModes: () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_20__.DistributedTracingModes),
/* harmony export */   Envelope: () => (/* reexport safe */ _Telemetry_Common_Envelope__WEBPACK_IMPORTED_MODULE_5__.Envelope),
/* harmony export */   Event: () => (/* reexport safe */ _Telemetry_Event__WEBPACK_IMPORTED_MODULE_6__.Event),
/* harmony export */   EventPersistence: () => (/* reexport safe */ _Enums__WEBPACK_IMPORTED_MODULE_20__.EventPersistence),
/* harmony export */   Exception: () => (/* reexport safe */ _Telemetry_Exception__WEBPACK_IMPORTED_MODULE_7__.Exception),
/* harmony export */   Extensions: () => (/* reexport safe */ _Interfaces_PartAExtensions__WEBPACK_IMPORTED_MODULE_19__.Extensions),
/* harmony export */   HttpMethod: () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.HttpMethod),
/* harmony export */   Metric: () => (/* reexport safe */ _Telemetry_Metric__WEBPACK_IMPORTED_MODULE_8__.Metric),
/* harmony export */   PageView: () => (/* reexport safe */ _Telemetry_PageView__WEBPACK_IMPORTED_MODULE_9__.PageView),
/* harmony export */   PageViewPerformance: () => (/* reexport safe */ _Telemetry_PageViewPerformance__WEBPACK_IMPORTED_MODULE_12__.PageViewPerformance),
/* harmony export */   ProcessLegacy: () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.ProcessLegacy),
/* harmony export */   PropertiesPluginIdentifier: () => (/* binding */ PropertiesPluginIdentifier),
/* harmony export */   RemoteDependencyData: () => (/* reexport safe */ _Telemetry_RemoteDependencyData__WEBPACK_IMPORTED_MODULE_10__.RemoteDependencyData),
/* harmony export */   RequestHeaders: () => (/* reexport safe */ _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_3__.RequestHeaders),
/* harmony export */   SampleRate: () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.SampleRate),
/* harmony export */   SeverityLevel: () => (/* reexport safe */ _Interfaces_Contracts_SeverityLevel__WEBPACK_IMPORTED_MODULE_14__.SeverityLevel),
/* harmony export */   TelemetryItemCreator: () => (/* reexport safe */ _TelemetryItemCreator__WEBPACK_IMPORTED_MODULE_18__.TelemetryItemCreator),
/* harmony export */   ThrottleMgr: () => (/* reexport safe */ _ThrottleMgr__WEBPACK_IMPORTED_MODULE_1__.ThrottleMgr),
/* harmony export */   Trace: () => (/* reexport safe */ _Telemetry_Trace__WEBPACK_IMPORTED_MODULE_11__.Trace),
/* harmony export */   correlationIdCanIncludeCorrelationHeader: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdCanIncludeCorrelationHeader),
/* harmony export */   correlationIdGetCorrelationContext: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdGetCorrelationContext),
/* harmony export */   correlationIdGetCorrelationContextValue: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdGetCorrelationContextValue),
/* harmony export */   correlationIdGetPrefix: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdGetPrefix),
/* harmony export */   correlationIdSetPrefix: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.correlationIdSetPrefix),
/* harmony export */   createDistributedTraceContextFromTrace: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.createDistributedTraceContextFromTrace),
/* harmony export */   createDomEvent: () => (/* reexport safe */ _DomHelperFuncs__WEBPACK_IMPORTED_MODULE_24__.createDomEvent),
/* harmony export */   createOfflineListener: () => (/* reexport safe */ _Offline__WEBPACK_IMPORTED_MODULE_27__.createOfflineListener),
/* harmony export */   createTelemetryItem: () => (/* reexport safe */ _TelemetryItemCreator__WEBPACK_IMPORTED_MODULE_18__.createTelemetryItem),
/* harmony export */   createTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.createTraceParent),
/* harmony export */   dataSanitizeException: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeException),
/* harmony export */   dataSanitizeId: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeId),
/* harmony export */   dataSanitizeInput: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeInput),
/* harmony export */   dataSanitizeKey: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeKey),
/* harmony export */   dataSanitizeKeyAndAddUniqueness: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeKeyAndAddUniqueness),
/* harmony export */   dataSanitizeMeasurements: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeMeasurements),
/* harmony export */   dataSanitizeMessage: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeMessage),
/* harmony export */   dataSanitizeProperties: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeProperties),
/* harmony export */   dataSanitizeString: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeString),
/* harmony export */   dataSanitizeUrl: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dataSanitizeUrl),
/* harmony export */   dateTimeUtilsDuration: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.dateTimeUtilsDuration),
/* harmony export */   dateTimeUtilsNow: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.dateTimeUtilsNow),
/* harmony export */   dsPadNumber: () => (/* reexport safe */ _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__.dsPadNumber),
/* harmony export */   findAllScripts: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.findAllScripts),
/* harmony export */   findW3cTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.findW3cTraceParent),
/* harmony export */   formatTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.formatTraceParent),
/* harmony export */   getExtensionByName: () => (/* reexport safe */ _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__.getExtensionByName),
/* harmony export */   isBeaconApiSupported: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__.isBeaconsSupported),
/* harmony export */   isCrossOriginError: () => (/* reexport safe */ _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__.isCrossOriginError),
/* harmony export */   isInternalApplicationInsightsEndpoint: () => (/* reexport safe */ _Util__WEBPACK_IMPORTED_MODULE_0__.isInternalApplicationInsightsEndpoint),
/* harmony export */   isSampledFlag: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isSampledFlag),
/* harmony export */   isValidSpanId: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidSpanId),
/* harmony export */   isValidTraceId: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidTraceId),
/* harmony export */   isValidTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isValidTraceParent),
/* harmony export */   msToTimeSpan: () => (/* reexport safe */ _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__.msToTimeSpan),
/* harmony export */   parseConnectionString: () => (/* reexport safe */ _ConnectionStringParser__WEBPACK_IMPORTED_MODULE_2__.parseConnectionString),
/* harmony export */   parseTraceParent: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.parseTraceParent),
/* harmony export */   strNotSpecified: () => (/* reexport safe */ _Constants__WEBPACK_IMPORTED_MODULE_4__.strNotSpecified),
/* harmony export */   stringToBoolOrDefault: () => (/* reexport safe */ _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__.stringToBoolOrDefault),
/* harmony export */   urlGetAbsoluteUrl: () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlGetAbsoluteUrl),
/* harmony export */   urlGetCompleteUrl: () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlGetCompleteUrl),
/* harmony export */   urlGetPathName: () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlGetPathName),
/* harmony export */   urlParseFullHost: () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlParseFullHost),
/* harmony export */   urlParseHost: () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlParseHost),
/* harmony export */   urlParseUrl: () => (/* reexport safe */ _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__.urlParseUrl),
/* harmony export */   utlCanUseLocalStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlCanUseLocalStorage),
/* harmony export */   utlCanUseSessionStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlCanUseSessionStorage),
/* harmony export */   utlDisableStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlDisableStorage),
/* harmony export */   utlEnableStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlEnableStorage),
/* harmony export */   utlGetLocalStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlGetLocalStorage),
/* harmony export */   utlGetSessionStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlGetSessionStorage),
/* harmony export */   utlGetSessionStorageKeys: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlGetSessionStorageKeys),
/* harmony export */   utlRemoveSessionStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlRemoveSessionStorage),
/* harmony export */   utlRemoveStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlRemoveStorage),
/* harmony export */   utlSetLocalStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlSetLocalStorage),
/* harmony export */   utlSetSessionStorage: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlSetSessionStorage),
/* harmony export */   utlSetStoragePrefix: () => (/* reexport safe */ _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__.utlSetStoragePrefix)
/* harmony export */ });
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/* harmony import */ var _ThrottleMgr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83);
/* harmony import */ var _ConnectionStringParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86);
/* harmony import */ var _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(79);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(78);
/* harmony import */ var _Telemetry_Common_Envelope__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(87);
/* harmony import */ var _Telemetry_Event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(88);
/* harmony import */ var _Telemetry_Exception__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(89);
/* harmony import */ var _Telemetry_Metric__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(90);
/* harmony import */ var _Telemetry_PageView__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(92);
/* harmony import */ var _Telemetry_RemoteDependencyData__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(94);
/* harmony import */ var _Telemetry_Trace__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(95);
/* harmony import */ var _Telemetry_PageViewPerformance__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(96);
/* harmony import */ var _Telemetry_Common_Data__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(97);
/* harmony import */ var _Interfaces_Contracts_SeverityLevel__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(98);
/* harmony import */ var _Interfaces_IConfig__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(99);
/* harmony import */ var _Interfaces_Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(100);
/* harmony import */ var _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(80);
/* harmony import */ var _TelemetryItemCreator__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(101);
/* harmony import */ var _Interfaces_PartAExtensions__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(102);
/* harmony import */ var _Enums__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(85);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(93);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(28);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(46);
/* harmony import */ var _DomHelperFuncs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(103);
/* harmony import */ var _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(84);
/* harmony import */ var _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(82);
/* harmony import */ var _Offline__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(104);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */

// Licensed under the



























var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin";
var BreezeChannelIdentifier = "AppInsightsChannelPlugin";
var AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics";
//# sourceMappingURL=applicationinsights-common.js.map

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AjaxHelperParseDependencyPath: () => (/* binding */ AjaxHelperParseDependencyPath),
/* harmony export */   correlationIdCanIncludeCorrelationHeader: () => (/* binding */ correlationIdCanIncludeCorrelationHeader),
/* harmony export */   correlationIdGetCorrelationContext: () => (/* binding */ correlationIdGetCorrelationContext),
/* harmony export */   correlationIdGetCorrelationContextValue: () => (/* binding */ correlationIdGetCorrelationContextValue),
/* harmony export */   correlationIdGetPrefix: () => (/* binding */ correlationIdGetPrefix),
/* harmony export */   correlationIdSetPrefix: () => (/* binding */ correlationIdSetPrefix),
/* harmony export */   createDistributedTraceContextFromTrace: () => (/* binding */ createDistributedTraceContextFromTrace),
/* harmony export */   dateTimeUtilsDuration: () => (/* binding */ dateTimeUtilsDuration),
/* harmony export */   dateTimeUtilsNow: () => (/* binding */ dateTimeUtilsNow),
/* harmony export */   isInternalApplicationInsightsEndpoint: () => (/* binding */ isInternalApplicationInsightsEndpoint)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78);
/* harmony import */ var _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(79);
/* harmony import */ var _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(80);
/* harmony import */ var _UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(82);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(81);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */









// listing only non-geo specific locations
var _internalEndpoints = [
    _Constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BREEZE_ENDPOINT + _Constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BREEZE_PATH,
    "https://breeze.aimon.applicationinsights.io" + _Constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BREEZE_PATH,
    "https://dc-int.services.visualstudio.com" + _Constants__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_BREEZE_PATH
];
var _correlationIdPrefix = "cid-v1:";
function isInternalApplicationInsightsEndpoint(endpointUrl) {
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrIndexOf)(_internalEndpoints, endpointUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]()) !== -1;
}
function correlationIdSetPrefix(prefix) {
    _correlationIdPrefix = prefix;
}
function correlationIdGetPrefix() {
    return _correlationIdPrefix;
}
/**
 * Checks if a request url is not on a excluded domain list and if it is safe to add correlation headers.
 * Headers are always included if the current domain matches the request domain. If they do not match (CORS),
 * they are regex-ed across correlationHeaderDomains and correlationHeaderExcludedDomains to determine if headers are included.
 * Some environments don't give information on currentHost via window.location.host (e.g. Cordova). In these cases, the user must
 * manually supply domains to include correlation headers on. Else, no headers will be included at all.
 */
function correlationIdCanIncludeCorrelationHeader(config, requestUrl, currentHost) {
    if (!requestUrl || (config && config.disableCorrelationHeaders)) {
        return false;
    }
    if (config && config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CORRELATION_HEADER_E0 /* @min:%2ecorrelationHeaderExcludePatterns */]) {
        for (var i = 0; i < config.correlationHeaderExcludePatterns[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */]; i++) {
            if (config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_CORRELATION_HEADER_E0 /* @min:%2ecorrelationHeaderExcludePatterns */][i].test(requestUrl)) {
                return false;
            }
        }
    }
    var requestHost = (0,_UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.urlParseUrl)(requestUrl).host[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
    if (requestHost && ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strIndexOf)(requestHost, ":443") !== -1 || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strIndexOf)(requestHost, ":80") !== -1)) {
        // [Bug #1260] IE can include the port even for http and https URLs so if present
        // try and parse it to remove if it matches the default protocol port
        requestHost = ((0,_UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.urlParseFullHost)(requestUrl, true) || "")[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
    }
    if ((!config || !config.enableCorsCorrelation) && (requestHost && requestHost !== currentHost)) {
        return false;
    }
    var includedDomains = config && config.correlationHeaderDomains;
    if (includedDomains) {
        var matchExists_1;
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(includedDomains, function (domain) {
            var regex = new RegExp(domain.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
            matchExists_1 = matchExists_1 || regex.test(requestHost);
        });
        if (!matchExists_1) {
            return false;
        }
    }
    var excludedDomains = config && config.correlationHeaderExcludedDomains;
    if (!excludedDomains || excludedDomains[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] === 0) {
        return true;
    }
    for (var i = 0; i < excludedDomains[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */]; i++) {
        var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
        if (regex.test(requestHost)) {
            return false;
        }
    }
    // if we don't know anything about the requestHost, require the user to use included/excludedDomains.
    // Previously we always returned false for a falsy requestHost
    return requestHost && requestHost[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0;
}
/**
 * Combines target appId and target role name from response header.
 */
function correlationIdGetCorrelationContext(responseHeader) {
    if (responseHeader) {
        var correlationId = correlationIdGetCorrelationContextValue(responseHeader, _RequestResponseHeaders__WEBPACK_IMPORTED_MODULE_3__.RequestHeaders[1 /* eRequestHeaders.requestContextTargetKey */]);
        if (correlationId && correlationId !== _correlationIdPrefix) {
            return correlationId;
        }
    }
}
/**
 * Gets key from correlation response header
 */
function correlationIdGetCorrelationContextValue(responseHeader, key) {
    if (responseHeader) {
        var keyValues = responseHeader[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_SPLIT /* @min:%2esplit */](",");
        for (var i = 0; i < keyValues[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */]; ++i) {
            var keyValue = keyValues[i][_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_SPLIT /* @min:%2esplit */]("=");
            if (keyValue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] === 2 && keyValue[0] === key) {
                return keyValue[1];
            }
        }
    }
}
function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
    var target, name = commandName, data = commandName;
    if (absoluteUrl && absoluteUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0) {
        var parsedUrl = (0,_UrlHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.urlParseUrl)(absoluteUrl);
        target = parsedUrl.host;
        if (!name) {
            if (parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PATHNAME /* @min:%2epathname */] != null) {
                var pathName = (parsedUrl.pathname[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] === 0) ? "/" : parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PATHNAME /* @min:%2epathname */];
                if (pathName.charAt(0) !== "/") {
                    pathName = "/" + pathName;
                }
                data = parsedUrl[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PATHNAME /* @min:%2epathname */];
                name = (0,_Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeString)(logger, method ? method + " " + pathName : pathName);
            }
            else {
                name = (0,_Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeString)(logger, absoluteUrl);
            }
        }
    }
    else {
        target = commandName;
        name = commandName;
    }
    return {
        target: target,
        name: name,
        data: data
    };
}
function dateTimeUtilsNow() {
    // returns the window or webworker performance object
    var perf = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getPerformance)();
    if (perf && perf.now && perf.timing) {
        var now = perf.now() + perf.timing.navigationStart;
        // Known issue with IE where this calculation can be negative, so if it is then ignore and fallback
        if (now > 0) {
            return now;
        }
    }
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.utcNow)();
}
function dateTimeUtilsDuration(start, end) {
    var result = null;
    if (start !== 0 && end !== 0 && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(start) && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(end)) {
        result = end - start;
    }
    return result;
}
/**
 * Creates a IDistributedTraceContext from an optional telemetryTrace
 * @param telemetryTrace - The telemetryTrace instance that is being wrapped
 * @param parentCtx - An optional parent distributed trace instance, almost always undefined as this scenario is only used in the case of multiple property handlers.
 * @returns A new IDistributedTraceContext instance that is backed by the telemetryTrace or temporary object
 */
function createDistributedTraceContextFromTrace(telemetryTrace, parentCtx) {
    var trace = telemetryTrace || {};
    return {
        getName: function () {
            return trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_NAME /* @min:%2ename */];
        },
        setName: function (newValue) {
            parentCtx && parentCtx.setName(newValue);
            trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_NAME /* @min:%2ename */] = newValue;
        },
        getTraceId: function () {
            return trace.traceID;
        },
        setTraceId: function (newValue) {
            parentCtx && parentCtx.setTraceId(newValue);
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isValidTraceId)(newValue)) {
                trace.traceID = newValue;
            }
        },
        getSpanId: function () {
            return trace.parentID;
        },
        setSpanId: function (newValue) {
            parentCtx && parentCtx.setSpanId(newValue);
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isValidSpanId)(newValue)) {
                trace.parentID = newValue;
            }
        },
        getTraceFlags: function () {
            return trace.traceFlags;
        },
        setTraceFlags: function (newTraceFlags) {
            parentCtx && parentCtx.setTraceFlags(newTraceFlags);
            trace.traceFlags = newTraceFlags;
        }
    };
}
//# sourceMappingURL=Util.js.map

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_BREEZE_ENDPOINT: () => (/* binding */ DEFAULT_BREEZE_ENDPOINT),
/* harmony export */   DEFAULT_BREEZE_PATH: () => (/* binding */ DEFAULT_BREEZE_PATH),
/* harmony export */   DisabledPropertyName: () => (/* binding */ DisabledPropertyName),
/* harmony export */   HttpMethod: () => (/* binding */ HttpMethod),
/* harmony export */   ProcessLegacy: () => (/* binding */ ProcessLegacy),
/* harmony export */   SampleRate: () => (/* binding */ SampleRate),
/* harmony export */   strIkey: () => (/* binding */ strIkey),
/* harmony export */   strNotSpecified: () => (/* binding */ strNotSpecified)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


/**
 * This is an internal property used to cause internal (reporting) requests to be ignored from reporting
 * additional telemetry, to handle polyfil implementations ALL urls used with a disabled request will
 * also be ignored for future requests even when this property is not provided.
 * Tagging as Ignore as this is an internal value and is not expected to be used outside of the SDK
 * @ignore
 */
var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
var SampleRate = "sampleRate";
var ProcessLegacy = "ProcessLegacy";
var HttpMethod = "http.method";
var DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
var DEFAULT_BREEZE_PATH = "/v2/track";
var strNotSpecified = "not_specified";
var strIkey = "iKey";
//# sourceMappingURL=Constants.js.map

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RequestHeaders: () => (/* binding */ RequestHeaders)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var RequestHeaders = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createValueMap)({
    requestContextHeader: [0 /* eRequestHeaders.requestContextHeader */, "Request-Context"],
    requestContextTargetKey: [1 /* eRequestHeaders.requestContextTargetKey */, "appId"],
    requestContextAppIdFormat: [2 /* eRequestHeaders.requestContextAppIdFormat */, "appId=cid-v1:"],
    requestIdHeader: [3 /* eRequestHeaders.requestIdHeader */, "Request-Id"],
    traceParentHeader: [4 /* eRequestHeaders.traceParentHeader */, "traceparent"],
    traceStateHeader: [5 /* eRequestHeaders.traceStateHeader */, "tracestate"],
    sdkContextHeader: [6 /* eRequestHeaders.sdkContextHeader */, "Sdk-Context"],
    sdkContextHeaderAppIdRequest: [7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */, "appId"],
    requestContextHeaderLowerCase: [8 /* eRequestHeaders.requestContextHeaderLowerCase */, "request-context"]
}));
//# sourceMappingURL=RequestResponseHeaders.js.map

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataSanitizeException: () => (/* binding */ dataSanitizeException),
/* harmony export */   dataSanitizeId: () => (/* binding */ dataSanitizeId),
/* harmony export */   dataSanitizeInput: () => (/* binding */ dataSanitizeInput),
/* harmony export */   dataSanitizeKey: () => (/* binding */ dataSanitizeKey),
/* harmony export */   dataSanitizeKeyAndAddUniqueness: () => (/* binding */ dataSanitizeKeyAndAddUniqueness),
/* harmony export */   dataSanitizeMeasurements: () => (/* binding */ dataSanitizeMeasurements),
/* harmony export */   dataSanitizeMessage: () => (/* binding */ dataSanitizeMessage),
/* harmony export */   dataSanitizeProperties: () => (/* binding */ dataSanitizeProperties),
/* harmony export */   dataSanitizeString: () => (/* binding */ dataSanitizeString),
/* harmony export */   dataSanitizeUrl: () => (/* binding */ dataSanitizeUrl),
/* harmony export */   dsPadNumber: () => (/* binding */ dsPadNumber)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
    var origLength = key[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
    var field = dataSanitizeKey(logger, key);
    // validation truncated the length.  We need to add uniqueness
    if (field[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] !== origLength) {
        var i = 0;
        var uniqueField = field;
        while (map[uniqueField] !== undefined) {
            i++;
            uniqueField = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strSubstring)(field, 0, 150 /* DataSanitizerValues.MAX_NAME_LENGTH */ - 3) + dsPadNumber(i);
        }
        field = uniqueField;
    }
    return field;
}
function dataSanitizeKey(logger, name) {
    var nameTrunc;
    if (name) {
        // Remove any leading or trailing whitespace
        name = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strTrim)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.asString)(name));
        // truncate the string to 150 chars
        if (name[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 150 /* DataSanitizerValues.MAX_NAME_LENGTH */) {
            nameTrunc = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strSubstring)(name, 0, 150 /* DataSanitizerValues.MAX_NAME_LENGTH */);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 57 /* _eInternalMessageId.NameTooLong */, "name is too long.  It has been truncated to " + 150 /* DataSanitizerValues.MAX_NAME_LENGTH */ + " characters.", { name: name }, true);
        }
    }
    return nameTrunc || name;
}
function dataSanitizeString(logger, value, maxLength) {
    if (maxLength === void 0) { maxLength = 1024 /* DataSanitizerValues.MAX_STRING_LENGTH */; }
    var valueTrunc;
    if (value) {
        maxLength = maxLength ? maxLength : 1024 /* DataSanitizerValues.MAX_STRING_LENGTH */; // in case default parameters dont work
        value = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strTrim)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.asString)(value));
        if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > maxLength) {
            valueTrunc = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strSubstring)(value, 0, maxLength);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 61 /* _eInternalMessageId.StringValueTooLong */, "string value is too long. It has been truncated to " + maxLength + " characters.", { value: value }, true);
        }
    }
    return valueTrunc || value;
}
function dataSanitizeUrl(logger, url, config) {
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(url)) {
        url = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.fieldRedaction)(url, config);
    }
    return dataSanitizeInput(logger, url, 2048 /* DataSanitizerValues.MAX_URL_LENGTH */, 66 /* _eInternalMessageId.UrlTooLong */);
}
function dataSanitizeMessage(logger, message) {
    var messageTrunc;
    if (message) {
        if (message[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 32768 /* DataSanitizerValues.MAX_MESSAGE_LENGTH */) {
            messageTrunc = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strSubstring)(message, 0, 32768 /* DataSanitizerValues.MAX_MESSAGE_LENGTH */);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 56 /* _eInternalMessageId.MessageTruncated */, "message is too long, it has been truncated to " + 32768 /* DataSanitizerValues.MAX_MESSAGE_LENGTH */ + " characters.", { message: message }, true);
        }
    }
    return messageTrunc || message;
}
function dataSanitizeException(logger, exception) {
    var exceptionTrunc;
    if (exception) {
        // Make surte its a string
        var value = "" + exception;
        if (value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 32768 /* DataSanitizerValues.MAX_EXCEPTION_LENGTH */) {
            exceptionTrunc = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strSubstring)(value, 0, 32768 /* DataSanitizerValues.MAX_EXCEPTION_LENGTH */);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 52 /* _eInternalMessageId.ExceptionTruncated */, "exception is too long, it has been truncated to " + 32768 /* DataSanitizerValues.MAX_EXCEPTION_LENGTH */ + " characters.", { exception: exception }, true);
        }
    }
    return exceptionTrunc || exception;
}
function dataSanitizeProperties(logger, properties) {
    if (properties) {
        var tempProps_1 = {};
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(properties, function (prop, value) {
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.hasJSON)()) {
                // Stringify any part C properties
                try {
                    value = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getJSON)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STRINGIFY /* @min:%2estringify */](value);
                }
                catch (e) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 49 /* _eInternalMessageId.CannotSerializeObjectNonSerializable */, "custom property is not valid", { exception: e }, true);
                }
            }
            value = dataSanitizeString(logger, value, 8192 /* DataSanitizerValues.MAX_PROPERTY_LENGTH */);
            prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1);
            tempProps_1[prop] = value;
        });
        properties = tempProps_1;
    }
    return properties;
}
function dataSanitizeMeasurements(logger, measurements) {
    if (measurements) {
        var tempMeasurements_1 = {};
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)(measurements, function (measure, value) {
            measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1);
            tempMeasurements_1[measure] = value;
        });
        measurements = tempMeasurements_1;
    }
    return measurements;
}
function dataSanitizeId(logger, id) {
    return id ? dataSanitizeInput(logger, id, 128 /* DataSanitizerValues.MAX_ID_LENGTH */, 69 /* _eInternalMessageId.IdTooLong */)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TO_STRING /* @min:%2etoString */]() : id;
}
function dataSanitizeInput(logger, input, maxLength, _msgId) {
    var inputTrunc;
    if (input) {
        input = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strTrim)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.asString)(input));
        if (input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > maxLength) {
            inputTrunc = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strSubstring)(input, 0, maxLength);
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", { data: input }, true);
        }
    }
    return inputTrunc || input;
}
function dsPadNumber(num) {
    var s = "00" + num;
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strSubstr)(s, s[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] - 3);
}
//# sourceMappingURL=DataSanitizer.js.map

/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _DYN_AI_DATA_CONTRACT: () => (/* binding */ _DYN_AI_DATA_CONTRACT),
/* harmony export */   _DYN_ASSEMBLY: () => (/* binding */ _DYN_ASSEMBLY),
/* harmony export */   _DYN_CORRELATION_HEADER_E0: () => (/* binding */ _DYN_CORRELATION_HEADER_E0),
/* harmony export */   _DYN_COUNT: () => (/* binding */ _DYN_COUNT),
/* harmony export */   _DYN_DURATION: () => (/* binding */ _DYN_DURATION),
/* harmony export */   _DYN_EXCEPTIONS: () => (/* binding */ _DYN_EXCEPTIONS),
/* harmony export */   _DYN_EXTENSION_CONFIG: () => (/* binding */ _DYN_EXTENSION_CONFIG),
/* harmony export */   _DYN_FILE_NAME: () => (/* binding */ _DYN_FILE_NAME),
/* harmony export */   _DYN_GET_UTCDATE: () => (/* binding */ _DYN_GET_UTCDATE),
/* harmony export */   _DYN_HAS_FULL_STACK: () => (/* binding */ _DYN_HAS_FULL_STACK),
/* harmony export */   _DYN_INGESTIONENDPOINT: () => (/* binding */ _DYN_INGESTIONENDPOINT),
/* harmony export */   _DYN_LENGTH: () => (/* binding */ _DYN_LENGTH),
/* harmony export */   _DYN_LINE: () => (/* binding */ _DYN_LINE),
/* harmony export */   _DYN_MATCH: () => (/* binding */ _DYN_MATCH),
/* harmony export */   _DYN_MEASUREMENTS: () => (/* binding */ _DYN_MEASUREMENTS),
/* harmony export */   _DYN_MESSAGE: () => (/* binding */ _DYN_MESSAGE),
/* harmony export */   _DYN_NAME: () => (/* binding */ _DYN_NAME),
/* harmony export */   _DYN_PARSED_STACK: () => (/* binding */ _DYN_PARSED_STACK),
/* harmony export */   _DYN_PATHNAME: () => (/* binding */ _DYN_PATHNAME),
/* harmony export */   _DYN_PRE_TRIGGER_DATE: () => (/* binding */ _DYN_PRE_TRIGGER_DATE),
/* harmony export */   _DYN_PROBLEM_GROUP: () => (/* binding */ _DYN_PROBLEM_GROUP),
/* harmony export */   _DYN_PROPERTIES: () => (/* binding */ _DYN_PROPERTIES),
/* harmony export */   _DYN_REMOVE_ITEM: () => (/* binding */ _DYN_REMOVE_ITEM),
/* harmony export */   _DYN_SEVERITY_LEVEL: () => (/* binding */ _DYN_SEVERITY_LEVEL),
/* harmony export */   _DYN_SIZE_IN_BYTES: () => (/* binding */ _DYN_SIZE_IN_BYTES),
/* harmony export */   _DYN_SPLIT: () => (/* binding */ _DYN_SPLIT),
/* harmony export */   _DYN_STRINGIFY: () => (/* binding */ _DYN_STRINGIFY),
/* harmony export */   _DYN_TO_LOWER_CASE: () => (/* binding */ _DYN_TO_LOWER_CASE),
/* harmony export */   _DYN_TO_STRING: () => (/* binding */ _DYN_TO_STRING),
/* harmony export */   _DYN_TYPE_NAME: () => (/* binding */ _DYN_TYPE_NAME)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES5 which can result in a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_SPLIT = "split"; // Count: 6
var _DYN_LENGTH = "length"; // Count: 46
var _DYN_TO_LOWER_CASE = "toLowerCase"; // Count: 6
var _DYN_INGESTIONENDPOINT = "ingestionendpoint"; // Count: 6
var _DYN_TO_STRING = "toString"; // Count: 8
var _DYN_REMOVE_ITEM = "removeItem"; // Count: 3
var _DYN_MESSAGE = "message"; // Count: 5
var _DYN_COUNT = "count"; // Count: 6
var _DYN_PRE_TRIGGER_DATE = "preTriggerDate"; // Count: 4
var _DYN_GET_UTCDATE = "getUTCDate"; // Count: 3
var _DYN_STRINGIFY = "stringify"; // Count: 4
var _DYN_PATHNAME = "pathname"; // Count: 4
var _DYN_MATCH = "match"; // Count: 5
var _DYN_CORRELATION_HEADER_E0 = "correlationHeaderExcludePatterns"; // Count: 2
var _DYN_NAME = "name"; // Count: 10
var _DYN_EXTENSION_CONFIG = "extensionConfig"; // Count: 4
var _DYN_PROPERTIES = "properties"; // Count: 10
var _DYN_MEASUREMENTS = "measurements"; // Count: 9
var _DYN_SIZE_IN_BYTES = "sizeInBytes"; // Count: 4
var _DYN_TYPE_NAME = "typeName"; // Count: 5
var _DYN_EXCEPTIONS = "exceptions"; // Count: 5
var _DYN_SEVERITY_LEVEL = "severityLevel"; // Count: 5
var _DYN_PROBLEM_GROUP = "problemGroup"; // Count: 3
var _DYN_PARSED_STACK = "parsedStack"; // Count: 6
var _DYN_HAS_FULL_STACK = "hasFullStack"; // Count: 5
var _DYN_ASSEMBLY = "assembly"; // Count: 4
var _DYN_FILE_NAME = "fileName"; // Count: 9
var _DYN_LINE = "line"; // Count: 6
var _DYN_AI_DATA_CONTRACT = "aiDataContract"; // Count: 4
var _DYN_DURATION = "duration"; // Count: 4
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   urlGetAbsoluteUrl: () => (/* binding */ urlGetAbsoluteUrl),
/* harmony export */   urlGetCompleteUrl: () => (/* binding */ urlGetCompleteUrl),
/* harmony export */   urlGetPathName: () => (/* binding */ urlGetPathName),
/* harmony export */   urlParseFullHost: () => (/* binding */ urlParseFullHost),
/* harmony export */   urlParseHost: () => (/* binding */ urlParseHost),
/* harmony export */   urlParseUrl: () => (/* binding */ urlParseUrl)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var _document = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)() || {};
var _htmlAnchorIdx = 0;
// Use an array of temporary values as it's possible for multiple calls to parseUrl() will be called with different URLs
// Using a cache size of 5 for now as it current depth usage is at least 2, so adding a minor buffer to handle future updates
var _htmlAnchorElement = [null, null, null, null, null];
function urlParseUrl(url) {
    var anchorIdx = _htmlAnchorIdx;
    var anchorCache = _htmlAnchorElement;
    var tempAnchor = anchorCache[anchorIdx];
    if (!_document.createElement) {
        // Always create the temp instance if createElement is not available
        tempAnchor = { host: urlParseHost(url, true) };
    }
    else if (!anchorCache[anchorIdx]) {
        // Create and cache the unattached anchor instance
        tempAnchor = anchorCache[anchorIdx] = _document.createElement("a");
    }
    tempAnchor.href = url;
    // Move the cache index forward
    anchorIdx++;
    if (anchorIdx >= anchorCache[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */]) {
        anchorIdx = 0;
    }
    _htmlAnchorIdx = anchorIdx;
    return tempAnchor;
}
function urlGetAbsoluteUrl(url) {
    var result;
    var a = urlParseUrl(url);
    if (a) {
        result = a.href;
    }
    return result;
}
function urlGetPathName(url) {
    var result;
    var a = urlParseUrl(url);
    if (a) {
        result = a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PATHNAME /* @min:%2epathname */];
    }
    return result;
}
function urlGetCompleteUrl(method, absoluteUrl) {
    if (method) {
        return method.toUpperCase() + " " + absoluteUrl;
    }
    return absoluteUrl;
}
// Fallback method to grab host from url if document.createElement method is not available
function urlParseHost(url, inclPort) {
    var fullHost = urlParseFullHost(url, inclPort) || "";
    if (fullHost) {
        var match = fullHost[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MATCH /* @min:%2ematch */](/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 3 && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(match[2]) && match[2][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
            return match[2] + (match[3] || "");
        }
    }
    return fullHost;
}
function urlParseFullHost(url, inclPort) {
    var result = null;
    if (url) {
        var match = url[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MATCH /* @min:%2ematch */](/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 2 && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(match[2]) && match[2][_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 0) {
            result = match[2] || "";
            if (inclPort && match[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] > 2) {
                var protocol = (match[1] || "")[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
                var port = match[3] || "";
                // IE includes the standard port so pass it off if it's the same as the protocol
                if (protocol === "http" && port === ":80") {
                    port = "";
                }
                else if (protocol === "https" && port === ":443") {
                    port = "";
                }
                result += port;
            }
        }
    }
    return result;
}
//# sourceMappingURL=UrlHelperFuncs.js.map

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThrottleMgr: () => (/* binding */ ThrottleMgr)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22);
/* harmony import */ var _StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(84);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(81);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var THROTTLE_STORAGE_PREFIX = "appInsightsThrottle";
var ThrottleMgr = /** @class */ (function () {
    function ThrottleMgr(core, namePrefix) {
        var _self = this;
        var _canUseLocalStorage;
        var _logger;
        var _config;
        var _localStorageObj;
        var _isTriggered; //_isTriggered is to make sure that we only trigger throttle once a day
        var _namePrefix;
        var _queue;
        var _isReady = false;
        var _isSpecificDaysGiven = false;
        _initConfig();
        // Special internal method to allow the unit tests and DebugPlugin to hook embedded objects
        _self["_getDbgPlgTargets"] = function () {
            return [_queue];
        };
        _self.getConfig = function () {
            return _config;
        };
        /**
         * Check if it is the correct day to send message.
         * If _isTriggered is true, even if canThrottle returns true, message will not be sent,
         * because we only allow triggering sendMessage() once a day.
         * @returns if the current date is the valid date to send message
         */
        _self.canThrottle = function (msgId) {
            var localObj = _getLocalStorageObjByKey(msgId);
            var cfg = _getCfgByKey(msgId);
            return _canThrottle(cfg, _canUseLocalStorage, localObj);
        };
        /**
         * Check if throttle is triggered on current day(UTC)
         * if canThrottle returns false, isTriggered will return false
         * @returns if throttle is triggered on current day(UTC)
         */
        _self.isTriggered = function (msgId) {
            return _isTrigger(msgId);
        };
        /**
         * Before isReady set to true, all message will be stored in queue.
         * Message will only be sent out after isReady set to true.
         * Initial and default value: false
         * @returns isReady state
         */
        _self.isReady = function () {
            return _isReady;
        };
        /**
         * Flush all message with given message key in queue with isReady state set to true.
         * @returns if message queue is flushed
         */
        _self.flush = function (msgId) {
            try {
                var queue = _getQueueByKey(msgId);
                if (queue && queue[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var items = queue.slice(0);
                    _queue[msgId] = [];
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.arrForEach)(items, function (item) {
                        _flushMessage(item.msgID, item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_MESSAGE /* @min:%2emessage */], item.severity, false);
                    });
                    return true;
                }
            }
            catch (err) {
                // eslint-disable-next-line no-empty
            }
            return false;
        };
        /**
         * Flush all message in queue with isReady state set to true.
         * @returns if message queue is flushed
         */
        _self.flushAll = function () {
            try {
                if (_queue) {
                    var result_1 = true;
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.objForEachKey)(_queue, function (key) {
                        var isFlushed = _self.flush(parseInt(key));
                        result_1 = result_1 && isFlushed;
                    });
                    return result_1;
                }
            }
            catch (err) {
                // eslint-disable-next-line no-empty
            }
            return false;
        };
        /**
         * Set isReady State
         * if isReady set to true, message queue will be flushed automatically.
         * @param isReady - isReady State
         * @pa
         * @returns if message queue is flushed
         */
        _self.onReadyState = function (isReady, flushAll) {
            if (flushAll === void 0) { flushAll = true; }
            _isReady = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(isReady) ? true : isReady;
            if (_isReady && flushAll) {
                return _self.flushAll();
            }
            return null;
        };
        _self.sendMessage = function (msgID, message, severity) {
            return _flushMessage(msgID, message, severity, true);
        };
        function _flushMessage(msgID, message, severity, saveUnsentMsg) {
            if (_isReady) {
                var isSampledIn = _canSampledIn(msgID);
                if (!isSampledIn) {
                    return;
                }
                var cfg = _getCfgByKey(msgID);
                var localStorageObj = _getLocalStorageObjByKey(msgID);
                var canThrottle = _canThrottle(cfg, _canUseLocalStorage, localStorageObj);
                var throttled = false;
                var number = 0;
                var isTriggered = _isTrigger(msgID);
                try {
                    if (canThrottle && !isTriggered) {
                        number = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.mathMin)(cfg.limit.maxSendNumber, localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_COUNT /* @min:%2ecount */] + 1);
                        localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_COUNT /* @min:%2ecount */] = 0;
                        throttled = true;
                        _isTriggered[msgID] = true;
                        localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */] = new Date();
                    }
                    else {
                        _isTriggered[msgID] = canThrottle;
                        localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_COUNT /* @min:%2ecount */] += 1;
                    }
                    var localStorageName = _getLocalStorageName(msgID);
                    _resetLocalStorage(_logger, localStorageName, localStorageObj);
                    for (var i = 0; i < number; i++) {
                        _sendMessage(msgID, _logger, message, severity);
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return {
                    isThrottled: throttled,
                    throttleNum: number
                };
            }
            else {
                if (!!saveUnsentMsg) {
                    var queue = _getQueueByKey(msgID);
                    queue.push({
                        msgID: msgID,
                        message: message,
                        severity: severity
                    });
                }
            }
            return null;
        }
        function _initConfig() {
            _logger = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.safeGetLogger)(core);
            _isTriggered = {};
            _localStorageObj = {};
            _queue = {};
            _config = {};
            _setCfgByKey(109 /* _eInternalMessageId.DefaultThrottleMsgKey */);
            _namePrefix = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNotNullOrUndefined)(namePrefix) ? namePrefix : "";
            core.addUnloadHook((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.onConfigChange)(core.config, function (details) {
                var coreConfig = details.cfg;
                _canUseLocalStorage = (0,_StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.utlCanUseLocalStorage)();
                var configMgr = coreConfig.throttleMgrCfg || {};
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.objForEachKey)(configMgr, function (key, cfg) {
                    _setCfgByKey(parseInt(key), cfg);
                });
            }));
        }
        function _getCfgByKey(msgID) {
            return _config[msgID] || _config[109 /* _eInternalMessageId.DefaultThrottleMsgKey */];
        }
        function _setCfgByKey(msgID, config) {
            var _a, _b;
            try {
                var cfg = config || {};
                var curCfg = {};
                curCfg.disabled = !!cfg.disabled;
                var configInterval = cfg.interval || {};
                _isSpecificDaysGiven = (configInterval === null || configInterval === void 0 ? void 0 : configInterval.daysOfMonth) && (configInterval === null || configInterval === void 0 ? void 0 : configInterval.daysOfMonth[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_LENGTH /* @min:%2elength */]) > 0;
                curCfg.interval = _getIntervalConfig(configInterval);
                var limit = {
                    samplingRate: ((_a = cfg.limit) === null || _a === void 0 ? void 0 : _a.samplingRate) || 100,
                    // dafault: every time sent only 1 event
                    maxSendNumber: ((_b = cfg.limit) === null || _b === void 0 ? void 0 : _b.maxSendNumber) || 1
                };
                curCfg.limit = limit;
                _config[msgID] = curCfg;
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
        }
        function _getIntervalConfig(interval) {
            interval = interval || {};
            var monthInterval = interval === null || interval === void 0 ? void 0 : interval.monthInterval;
            var dayInterval = interval === null || interval === void 0 ? void 0 : interval.dayInterval;
            // default: send data every 3 month each year
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(monthInterval) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(dayInterval)) {
                interval.monthInterval = 3;
                if (!_isSpecificDaysGiven) {
                    // default: send data on 28th
                    interval.daysOfMonth = [28];
                    _isSpecificDaysGiven = true;
                }
            }
            interval = {
                // dafault: sent every three months
                monthInterval: interval === null || interval === void 0 ? void 0 : interval.monthInterval,
                dayInterval: interval === null || interval === void 0 ? void 0 : interval.dayInterval,
                daysOfMonth: interval === null || interval === void 0 ? void 0 : interval.daysOfMonth
            };
            return interval;
        }
        function _canThrottle(config, canUseLocalStorage, localStorageObj) {
            if (config && !config.disabled && canUseLocalStorage && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNotNullOrUndefined)(localStorageObj)) {
                var curDate = _getThrottleDate();
                var date = localStorageObj.date;
                var interval = config.interval;
                var monthCheck = 1;
                if (interval === null || interval === void 0 ? void 0 : interval.monthInterval) {
                    var monthExpand = (curDate.getUTCFullYear() - date.getUTCFullYear()) * 12 + curDate.getUTCMonth() - date.getUTCMonth();
                    monthCheck = _checkInterval(interval.monthInterval, 0, monthExpand);
                }
                var dayCheck = 1;
                if (_isSpecificDaysGiven) {
                    dayCheck = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.arrIndexOf)(interval.daysOfMonth, curDate[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_UTCDATE /* @min:%2egetUTCDate */]());
                }
                else if (interval === null || interval === void 0 ? void 0 : interval.dayInterval) {
                    var daySpan = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.mathFloor)((curDate.getTime() - date.getTime()) / 86400000);
                    dayCheck = _checkInterval(interval.dayInterval, 0, daySpan);
                }
                return monthCheck >= 0 && dayCheck >= 0;
            }
            return false;
        }
        function _getLocalStorageName(msgKey, prefix) {
            var fix = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNotNullOrUndefined)(prefix) ? prefix : "";
            if (msgKey) {
                return THROTTLE_STORAGE_PREFIX + fix + "-" + msgKey;
            }
            return null;
        }
        // returns if throttle is triggered on current Date
        function _isTriggeredOnCurDate(preTriggerDate) {
            try {
                if (preTriggerDate) {
                    var curDate = new Date();
                    return preTriggerDate.getUTCFullYear() === curDate.getUTCFullYear() &&
                        preTriggerDate.getUTCMonth() === curDate.getUTCMonth() &&
                        preTriggerDate[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_UTCDATE /* @min:%2egetUTCDate */]() === curDate[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_GET_UTCDATE /* @min:%2egetUTCDate */]();
                }
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return false;
        }
        // transfer local storage string value to object that identifies start date, current count and preTriggerDate
        function _getLocalStorageObj(value, logger, storageName) {
            try {
                var storageObj = {
                    date: _getThrottleDate(),
                    count: 0
                };
                if (value) {
                    var obj = JSON.parse(value);
                    var curObj = {
                        date: _getThrottleDate(obj.date) || storageObj.date,
                        count: obj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_COUNT /* @min:%2ecount */] || storageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_COUNT /* @min:%2ecount */],
                        preTriggerDate: obj.preTriggerDate ? _getThrottleDate(obj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */]) : undefined
                    };
                    return curObj;
                }
                else {
                    _resetLocalStorage(logger, storageName, storageObj);
                    return storageObj;
                }
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return null;
        }
        // if datestr is not defined, current date will be returned
        function _getThrottleDate(dateStr) {
            // if new Date() can't be created through the provided dateStr, null will be returned.
            try {
                if (dateStr) {
                    var date = new Date(dateStr);
                    //make sure it is a valid Date Object
                    if (!isNaN(date.getDate())) {
                        return date;
                    }
                }
                else {
                    return new Date();
                }
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return null;
        }
        function _resetLocalStorage(logger, storageName, obj) {
            try {
                return (0,_StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.utlSetLocalStorage)(logger, storageName, (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.strTrim)(JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_STRINGIFY /* @min:%2estringify */](obj)));
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return false;
        }
        function _checkInterval(interval, start, current) {
            if (interval <= 0) {
                return 1;
            }
            // count from start year
            return (current >= start) && (current - start) % interval == 0 ? (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.mathFloor)((current - start) / interval) + 1 : -1;
        }
        function _sendMessage(msgID, logger, message, severity) {
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, severity || 1 /* eLoggingSeverity.CRITICAL */, msgID, message);
        }
        // NOTE: config.limit.samplingRate is set to 4 decimal places,
        // so config.limit.samplingRate = 1 means 0.0001%
        function _canSampledIn(msgID) {
            try {
                var cfg = _getCfgByKey(msgID);
                return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.randomValue)(1000000) <= cfg.limit.samplingRate;
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return false;
        }
        function _getLocalStorageObjByKey(key) {
            try {
                var curObj = _localStorageObj[key];
                if (!curObj) {
                    var localStorageName = _getLocalStorageName(key, _namePrefix);
                    curObj = _getLocalStorageObj((0,_StorageHelperFuncs__WEBPACK_IMPORTED_MODULE_5__.utlGetLocalStorage)(_logger, localStorageName), _logger, localStorageName);
                    _localStorageObj[key] = curObj;
                }
                return _localStorageObj[key];
            }
            catch (e) {
                // eslint-disable-next-line no-empty
            }
            return null;
        }
        function _isTrigger(key) {
            var isTrigger = _isTriggered[key];
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(isTrigger)) {
                isTrigger = false;
                var localStorageObj = _getLocalStorageObjByKey(key);
                if (localStorageObj) {
                    isTrigger = _isTriggeredOnCurDate(localStorageObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_6__._DYN_PRE_TRIGGER_DATE /* @min:%2epreTriggerDate */]);
                }
                _isTriggered[key] = isTrigger;
            }
            return _isTriggered[key];
        }
        function _getQueueByKey(key) {
            _queue = _queue || {};
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.isNullOrUndefined)(_queue[key])) {
                _queue[key] = [];
            }
            return _queue[key];
        }
    }
    return ThrottleMgr;
}());

//# sourceMappingURL=ThrottleMgr.js.map

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   utlCanUseLocalStorage: () => (/* binding */ utlCanUseLocalStorage),
/* harmony export */   utlCanUseSessionStorage: () => (/* binding */ utlCanUseSessionStorage),
/* harmony export */   utlDisableStorage: () => (/* binding */ utlDisableStorage),
/* harmony export */   utlEnableStorage: () => (/* binding */ utlEnableStorage),
/* harmony export */   utlGetLocalStorage: () => (/* binding */ utlGetLocalStorage),
/* harmony export */   utlGetSessionStorage: () => (/* binding */ utlGetSessionStorage),
/* harmony export */   utlGetSessionStorageKeys: () => (/* binding */ utlGetSessionStorageKeys),
/* harmony export */   utlRemoveSessionStorage: () => (/* binding */ utlRemoveSessionStorage),
/* harmony export */   utlRemoveStorage: () => (/* binding */ utlRemoveStorage),
/* harmony export */   utlSetLocalStorage: () => (/* binding */ utlSetLocalStorage),
/* harmony export */   utlSetSessionStorage: () => (/* binding */ utlSetSessionStorage),
/* harmony export */   utlSetStoragePrefix: () => (/* binding */ utlSetStoragePrefix)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _Enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var _canUseLocalStorage = undefined;
var _canUseSessionStorage = undefined;
var _storagePrefix = "";
/**
 * Gets the localStorage object if available
 * @returns {Storage} - Returns the storage object if available else returns null
 */
function _getLocalStorageObject() {
    if (utlCanUseLocalStorage()) {
        return _getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_3__.StorageType.LocalStorage);
    }
    return null;
}
/**
 * Tests storage object (localStorage or sessionStorage) to verify that it is usable
 * More details here: https://mathiasbynens.be/notes/localstorage-pattern
 * @param storageType - Type of storage
 * @returns {Storage} Returns storage object verified that it is usable
 */
function _getVerifiedStorageObject(storageType) {
    try {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getGlobal)())) {
            return null;
        }
        var uid = (new Date)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TO_STRING /* @min:%2etoString */]();
        var storage = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getInst)(storageType === _Enums__WEBPACK_IMPORTED_MODULE_3__.StorageType.LocalStorage ? "localStorage" : "sessionStorage");
        var name_1 = _storagePrefix + uid;
        storage.setItem(name_1, uid);
        var fail = storage.getItem(name_1) !== uid;
        storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_REMOVE_ITEM /* @min:%2eremoveItem */](name_1);
        if (!fail) {
            return storage;
        }
    }
    catch (exception) {
        // eslint-disable-next-line no-empty
    }
    return null;
}
/**
 * Gets the sessionStorage object if available
 * @returns {Storage} - Returns the storage object if available else returns null
 */
function _getSessionStorageObject() {
    if (utlCanUseSessionStorage()) {
        return _getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_3__.StorageType.SessionStorage);
    }
    return null;
}
/**
 * Disables the global SDK usage of local or session storage if available
 */
function utlDisableStorage() {
    _canUseLocalStorage = false;
    _canUseSessionStorage = false;
}
function utlSetStoragePrefix(storagePrefix) {
    _storagePrefix = storagePrefix || "";
}
/**
 * Re-enables the global SDK usage of local or session storage if available
 */
function utlEnableStorage() {
    _canUseLocalStorage = utlCanUseLocalStorage(true);
    _canUseSessionStorage = utlCanUseSessionStorage(true);
}
/**
 * Returns whether LocalStorage can be used, if the reset parameter is passed a true this will override
 * any previous disable calls.
 * @param reset - Should the usage be reset and determined only based on whether LocalStorage is available
 */
function utlCanUseLocalStorage(reset) {
    if (reset || _canUseLocalStorage === undefined) {
        _canUseLocalStorage = !!_getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_3__.StorageType.LocalStorage);
    }
    return _canUseLocalStorage;
}
function utlGetLocalStorage(logger, name) {
    var storage = _getLocalStorageObject();
    if (storage !== null) {
        try {
            return storage.getItem(name);
        }
        catch (e) {
            _canUseLocalStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 1 /* _eInternalMessageId.BrowserCannotReadLocalStorage */, "Browser failed read of local storage. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
        }
    }
    return null;
}
function utlSetLocalStorage(logger, name, data) {
    var storage = _getLocalStorageObject();
    if (storage !== null) {
        try {
            storage.setItem(name, data);
            return true;
        }
        catch (e) {
            _canUseLocalStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 3 /* _eInternalMessageId.BrowserCannotWriteLocalStorage */, "Browser failed write to local storage. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
        }
    }
    return false;
}
function utlRemoveStorage(logger, name) {
    var storage = _getLocalStorageObject();
    if (storage !== null) {
        try {
            storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_REMOVE_ITEM /* @min:%2eremoveItem */](name);
            return true;
        }
        catch (e) {
            _canUseLocalStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 5 /* _eInternalMessageId.BrowserFailedRemovalFromLocalStorage */, "Browser failed removal of local storage item. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
        }
    }
    return false;
}
function utlCanUseSessionStorage(reset) {
    if (reset || _canUseSessionStorage === undefined) {
        _canUseSessionStorage = !!_getVerifiedStorageObject(_Enums__WEBPACK_IMPORTED_MODULE_3__.StorageType.SessionStorage);
    }
    return _canUseSessionStorage;
}
function utlGetSessionStorageKeys() {
    var keys = [];
    if (utlCanUseSessionStorage()) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.objForEachKey)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getInst)("sessionStorage"), function (key) {
            keys.push(key);
        });
    }
    return keys;
}
function utlGetSessionStorage(logger, name) {
    var storage = _getSessionStorageObject();
    if (storage !== null) {
        try {
            return storage.getItem(name);
        }
        catch (e) {
            _canUseSessionStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 2 /* _eInternalMessageId.BrowserCannotReadSessionStorage */, "Browser failed read of session storage. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
        }
    }
    return null;
}
function utlSetSessionStorage(logger, name, data) {
    var storage = _getSessionStorageObject();
    if (storage !== null) {
        try {
            storage.setItem(name, data);
            return true;
        }
        catch (e) {
            _canUseSessionStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 4 /* _eInternalMessageId.BrowserCannotWriteSessionStorage */, "Browser failed write to session storage. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
        }
    }
    return false;
}
function utlRemoveSessionStorage(logger, name) {
    var storage = _getSessionStorageObject();
    if (storage !== null) {
        try {
            storage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_REMOVE_ITEM /* @min:%2eremoveItem */](name);
            return true;
        }
        catch (e) {
            _canUseSessionStorage = false;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 6 /* _eInternalMessageId.BrowserFailedRemovalFromSessionStorage */, "Browser failed removal of session storage item. " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.dumpObj)(e) });
        }
    }
    return false;
}
//# sourceMappingURL=StorageHelperFuncs.js.map

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DistributedTracingModes: () => (/* binding */ DistributedTracingModes),
/* harmony export */   EventPersistence: () => (/* binding */ EventPersistence),
/* harmony export */   StorageType: () => (/* binding */ StorageType)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var StorageType = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    LocalStorage: 0 /* eStorageType.LocalStorage */,
    SessionStorage: 1 /* eStorageType.SessionStorage */
}));
var DistributedTracingModes = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    AI: 0 /* eDistributedTracingModes.AI */,
    AI_AND_W3C: 1 /* eDistributedTracingModes.AI_AND_W3C */,
    W3C: 2 /* eDistributedTracingModes.W3C */
}));
/**
 * The EventPersistence contains a set of values that specify the event's persistence.
 */
var EventPersistence = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    /**
     * Normal persistence.
     */
    Normal: 1 /* EventPersistenceValue.Normal */,
    /**
     * Critical persistence.
     */
    Critical: 2 /* EventPersistenceValue.Critical */
}));
//# sourceMappingURL=Enums.js.map

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectionStringParser: () => (/* binding */ ConnectionStringParser),
/* harmony export */   parseConnectionString: () => (/* binding */ parseConnectionString)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var _FIELDS_SEPARATOR = ";";
var _FIELD_KEY_VALUE_SEPARATOR = "=";
function parseConnectionString(connectionString) {
    if (!connectionString) {
        return {};
    }
    var kvPairs = connectionString[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](_FIELDS_SEPARATOR);
    var result = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrReduce)(kvPairs, function (fields, kv) {
        var kvParts = kv[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SPLIT /* @min:%2esplit */](_FIELD_KEY_VALUE_SEPARATOR);
        if (kvParts[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] === 2) { // only save fields with valid formats
            var key = kvParts[0][_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]();
            var value = kvParts[1];
            fields[key] = value;
        }
        return fields;
    }, {});
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.objKeys)(result)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_LENGTH /* @min:%2elength */] > 0) {
        // this is a valid connection string, so parse the results
        if (result.endpointsuffix) {
            // apply the default endpoints
            var locationPrefix = result.location ? result.location + "." : "";
            result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] || ("https://" + locationPrefix + "dc." + result.endpointsuffix);
        }
        // apply user override endpoint or the default endpoints
        result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] || _Constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_BREEZE_ENDPOINT;
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.strEndsWith)(result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */], "/")) {
            result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */] = result[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_INGESTIONENDPOINT /* @min:%2eingestionendpoint */].slice(0, -1);
        }
    }
    return result;
}
var ConnectionStringParser = {
    parse: parseConnectionString
};
//# sourceMappingURL=ConnectionStringParser.js.map

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Envelope: () => (/* binding */ Envelope)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
/* harmony import */ var _DataSanitizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var Envelope = /** @class */ (function () {
    /**
     * Constructs a new instance of telemetry data.
     */
    function Envelope(logger, data, name) {
        var _this = this;
        var _self = this;
        _self.ver = 1;
        _self.sampleRate = 100.0;
        _self.tags = {};
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */] = (0,_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_1__.strNotSpecified;
        _self.data = data;
        _self.time = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.toISOString)(new Date());
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_AI_DATA_CONTRACT /* @min:%2eaiDataContract */] = {
            time: 1 /* FieldType.Required */,
            iKey: 1 /* FieldType.Required */,
            name: 1 /* FieldType.Required */,
            sampleRate: function () {
                return (_this.sampleRate === 100) ? 4 /* FieldType.Hidden */ : 1 /* FieldType.Required */;
            },
            tags: 1 /* FieldType.Required */,
            data: 1 /* FieldType.Required */
        };
    }
    return Envelope;
}());

//# sourceMappingURL=Envelope.js.map

/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* binding */ Event)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var Event = /** @class */ (function () {
    /**
     * Constructs a new instance of the EventTelemetry object
     */
    function Event(logger, name, properties, measurements) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            name: 1 /* FieldType.Required */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_0__.strNotSpecified;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMeasurements)(logger, measurements);
    }
    Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event";
    Event.dataType = "EventData";
    return Event;
}());

//# sourceMappingURL=Event.js.map

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Exception: () => (/* binding */ Exception),
/* harmony export */   _createExDetailsFromInterface: () => (/* binding */ _createExDetailsFromInterface),
/* harmony export */   _createExceptionDetails: () => (/* binding */ _createExceptionDetails),
/* harmony export */   _extractStackFrame: () => (/* binding */ _extractStackFrame),
/* harmony export */   _formatErrorCode: () => (/* binding */ _formatErrorCode),
/* harmony export */   _parsedFrameToInterface: () => (/* binding */ _parsedFrameToInterface)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */








// These Regex covers the following patterns
// 1. Chrome/Firefox/IE/Edge:
//    at functionName (filename:lineNumber:columnNumber)
//    at functionName (filename:lineNumber)
//    at filename:lineNumber:columnNumber
//    at filename:lineNumber
//    at functionName@filename:lineNumber:columnNumber
// 2. Safari / Opera:
//    functionName@filename:lineNumber:columnNumber
//    functionName@filename:lineNumber
//    filename:lineNumber:columnNumber
//    filename:lineNumber
//    Line ## of scriptname script filename:lineNumber:columnNumber
//    Line ## of scriptname script filename
// 3. IE/Edge (Additional formats)
//    at functionName@filename:lineNumber
var STACKFRAME_BASE_SIZE = 58; // '{"method":"","level":,"assembly":"","fileName":"","line":}'.length
/**
 * Check if the string conforms to what looks like a stack frame line and not just a general message
 * comment or other non-stack related info.
 *
 * This  should be used to filter out any leading "message" lines from a stack trace, before attempting to parse
 * the individual stack frames. Once you have estabilsted the start of the stack frames you can then use the
 * FULL_STACK_FRAME_1, FULL_STACK_FRAME_2, FULL_STACK_FRAME_3, and EXTRACT_FILENAME to parse the individual
 * stack frames to extract the method, filename, line number, and column number.
 * These may still provide invalid matches, so the sequence of execution is important to avoid providing
 * an invalid parsed stack.
 */
var IS_FRAME = /^\s{0,50}(from\s|at\s|Line\s{1,5}\d{1,10}\s{1,5}of|\w{1,50}@\w{1,80}|[^\(\s\n]+:[0-9\?]+(?::[0-9\?]+)?)/;
/**
 * Parse a well formed stack frame with both the line and column numbers
 * ----------------------------------
 * **Primary focus of the matching**
 * - at functionName (filename:lineNumber:columnNumber)
 * - at filename:lineNumber:columnNumber
 * - at functionName@filename:lineNumber:columnNumber
 * - functionName (filename:lineNumber:columnNumber)
 * - filename:lineNumber:columnNumber
 * - functionName@filename:lineNumber:columnNumber
 */
var FULL_STACK_FRAME_1 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+):([0-9\?]+)\)?$/;
/**
 * Parse a well formed stack frame with only a line number.
 * ----------------------------------
 * > Note: this WILL also match with line and column number, but the line number is included with the filename
 * > you should attempt to match with FULL_STACK_FRAME_1 first.
 *
 * **Primary focus of the matching (run FULL_STACK_FRAME_1 first)**
 * - at functionName (filename:lineNumber)
 * - at filename:lineNumber
 * - at functionName@filename:lineNumber
 * - functionName (filename:lineNumber)
 * - filename:lineNumber
 * - functionName@filename:lineNumber
 *
 * **Secondary matches**
 * - at functionName (filename:lineNumber:columnNumber)
 * - at filename:lineNumber:columnNumber
 * - at functionName@filename:lineNumber:columnNumber
 * - functionName (filename:lineNumber:columnNumber)
 * - filename:lineNumber:columnNumber
 * - functionName@filename:lineNumber:columnNumber
 */
var FULL_STACK_FRAME_2 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\]]+):([0-9\?]+)\)?$/;
/**
 * Attempt to Parse a frame that doesn't include a line or column number.
 * ----------------------------------
 * > Note: this WILL also match lines with a line or line and column number, you should attempt to match with
 * both FULL_STACK_FRAME_1 and FULL_STACK_FRAME_2 first to avoid false positives.
 *
 * **Unexpected Invalid Matches** (Matches that should be avoided -- by using the FULL_STACK_FRAME_1 and FULL_STACK_FRAME_2 first)
 * - at https://localhost:44365/static/node_bundles/@microsoft/blah/js/bundle.js:144112:27
 * - at https://localhost:44365/static/node_bundles/@microsoft/blah/js/bundle.js:144112:27
 *
 * **Primary focus of the matching (run FULL_STACK_FRAME_1 first)**
 * - at functionName@filename
 * - at functionName (filename)
 * - at functionName filename
 * - at filename  <- Will actuall match this as the "method" and not the filename (care should be taken to avoid this)
 * - functionName@filename
 * - functionName (filename)
 * - functionName filename
 * - functionName
 *
 * **Secondary matches** (The line and column numbers will be included with the matched filename)
 * - at functionName (filename:lineNumber:columnNumber)
 * - at functionName (filename:lineNumber)
 * - at filename:lineNumber:columnNumber
 * - at filename:lineNumber
 * - at functionName@filename:lineNumber:columnNumber
 * - at functionName@filename:lineNumber
 * - functionName (filename:lineNumber:columnNumber)
 * - functionName (filename:lineNumber)
 * - filename:lineNumber:columnNumber
 * - filename:lineNumber
 * - functionName@filename:lineNumber:columnNumber
 * - functionName@filename:lineNumber
  */
var FULL_STACK_FRAME_3 = /^(?:\s{0,50}at)?\s{0,50}([^\@\()\s]+)?\s{0,50}(?:\s|\@|\()\s{0,5}([^\(\s\n\)\]]+)\)?$/;
/**
 * Attempt to extract the filename (with or without line and column numbers) from a string.
 * ----------------------------------
 * > Note: this will only match the filename (with any line or column numbers) and will
 * > return what looks like the filename, however, it will also match random strings that
 * > look like a filename, so care should be taken to ensure that the filename is actually
 * > a filename before using it.
 * >
 * > It is recommended to use this in conjunction with the FULL_STACK_FRAME_1, FULL_STACK_FRAME_2, and FULL_STACK_FRAME_3
 * > to ensure first to reduce false matches, if all of these fail then you can use this to extract the filename from a random
 * > strings to identify any potential filename from a known stack frame line.
 *
 * **Known Invalid matching**
 *
 * This regex will basically match any "final" string of a line or one that is trailed by a comma, so this should not
 * be used as the "only" matching regex, but rather as a final fallback to extract the filename from a string.
 * If you are certain that the string line is a stack frame and not part of the exception message (lines before the stack)
 * or trailing comments, then you can use this to extract the filename and then further parse with PARSE_FILENAME_LINE_COL
 * and PARSE_FILENAME_LINE_ONLY to extract any potential the line and column numbers.
 *
 * **Primary focus of the matching**
 * - at (anonymous) @ VM60:1
 * - Line 21 of linked script file://localhost/C:/Temp/stacktrace.js
 * - Line 11 of inline#1 script in http://localhost:3000/static/js/main.206f4846.js:2:296748
 * - Line 68 of inline#2 script in file://localhost/teststack.html
 * - at Global code (http://example.com/stacktrace.js:11:1)
 */
var EXTRACT_FILENAME = /(?:^|\(|\s{0,10}[\w\)]+\@)?([^\(\n\s\]\)]+)(?:\:([0-9]+)(?:\:([0-9]+))?)?\)?(?:,|$)/;
/**
 * Attempt to extract the filename, line number, and column number from a string.
 */
var PARSE_FILENAME_LINE_COL = /([^\(\s\n]+):([0-9]+):([0-9]+)$/;
/**
 * Attempt to extract the filename and line number from a string.
 */
var PARSE_FILENAME_LINE_ONLY = /([^\(\s\n]+):([0-9]+)$/;
var NoMethod = "<no_method>";
var strError = "error";
var strStack = "stack";
var strStackDetails = "stackDetails";
var strErrorSrc = "errorSrc";
var strMessage = "message";
var strDescription = "description";
var _parseSequence = [
    { re: FULL_STACK_FRAME_1, len: 5, m: 1, fn: 2, ln: 3, col: 4 },
    { chk: _ignoreNative, pre: _scrubAnonymous, re: FULL_STACK_FRAME_2, len: 4, m: 1, fn: 2, ln: 3 },
    { re: FULL_STACK_FRAME_3, len: 3, m: 1, fn: 2, hdl: _handleFilename },
    { re: EXTRACT_FILENAME, len: 2, fn: 1, hdl: _handleFilename }
];
function _scrubAnonymous(frame) {
    return frame.replace(/(\(anonymous\))/, "<anonymous>");
}
function _ignoreNative(frame) {
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(frame, "[native") < 0;
}
function _stringify(value, convertToString) {
    var result = value;
    if (result && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(result)) {
        if (JSON && JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STRINGIFY /* @min:%2estringify */]) {
            result = JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_STRINGIFY /* @min:%2estringify */](value);
            if (convertToString && (!result || result === "{}")) {
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TO_STRING /* @min:%2etoString */])) {
                    result = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TO_STRING /* @min:%2etoString */]();
                }
                else {
                    result = "" + value;
                }
            }
        }
        else {
            result = "" + value + " - (Missing JSON.stringify)";
        }
    }
    return result || "";
}
function _formatMessage(theEvent, errorType) {
    var evtMessage = theEvent;
    if (theEvent) {
        if (evtMessage && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(evtMessage)) {
            evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;
        }
        // Make sure the message is a string
        if (evtMessage && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(evtMessage)) {
            // tslint:disable-next-line: prefer-conditional-expression
            evtMessage = _stringify(evtMessage, true);
        }
        if (theEvent["filename"]) {
            // Looks like an event object with filename
            evtMessage = evtMessage + " @" + (theEvent["filename"] || "") + ":" + (theEvent["lineno"] || "?") + ":" + (theEvent["colno"] || "?");
        }
    }
    // Automatically add the error type to the message if it does already appear to be present
    if (errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(evtMessage || "", errorType) === -1) {
        evtMessage = errorType + ": " + evtMessage;
    }
    return evtMessage || "";
}
function _isExceptionDetailsInternal(value) {
    try {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(value)) {
            return "hasFullStack" in value && "typeName" in value;
        }
    }
    catch (e) {
        // This can happen with some native browser objects, but should not happen for the type we are checking for
    }
    return false;
}
function _isExceptionInternal(value) {
    try {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(value)) {
            return ("ver" in value && "exceptions" in value && "properties" in value);
        }
    }
    catch (e) {
        // This can happen with some native browser objects, but should not happen for the type we are checking for
    }
    return false;
}
function _isStackDetails(details) {
    return details && details.src && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(details.src) && details.obj && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(details.obj);
}
function _convertStackObj(errorStack) {
    var src = errorStack || "";
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(src)) {
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(src[strStack])) {
            src = src[strStack];
        }
        else {
            src = "" + src;
        }
    }
    var items = src[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SPLIT /* @min:%2esplit */]("\n");
    return {
        src: src,
        obj: items
    };
}
function _getOperaStack(errorMessage) {
    var stack = [];
    var lines = errorMessage[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SPLIT /* @min:%2esplit */]("\n");
    for (var lp = 0; lp < lines[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]; lp++) {
        var entry = lines[lp];
        if (lines[lp + 1]) {
            entry += "@" + lines[lp + 1];
            lp++;
        }
        stack.push(entry);
    }
    return {
        src: errorMessage,
        obj: stack
    };
}
function _getStackFromErrorObj(errorObj) {
    var details = null;
    if (errorObj) {
        try {
            /* Using bracket notation is support older browsers (IE 7/8 -- dont remember the version) that throw when using dot
            notation for undefined objects and we don't want to loose the error from being reported */
            if (errorObj[strStack]) {
                // Chrome/Firefox
                details = _convertStackObj(errorObj[strStack]);
            }
            else if (errorObj[strError] && errorObj[strError][strStack]) {
                // Edge error event provides the stack and error object
                details = _convertStackObj(errorObj[strError][strStack]);
            }
            else if (errorObj["exception"] && errorObj.exception[strStack]) {
                details = _convertStackObj(errorObj.exception[strStack]);
            }
            else if (_isStackDetails(errorObj)) {
                details = errorObj;
            }
            else if (_isStackDetails(errorObj[strStackDetails])) {
                details = errorObj[strStackDetails];
            }
            else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getWindow)() && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.getWindow)()["opera"] && errorObj[strMessage]) {
                // Opera
                details = _getOperaStack(errorObj[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */]);
            }
            else if (errorObj["reason"] && errorObj.reason[strStack]) {
                // UnhandledPromiseRejection
                details = _convertStackObj(errorObj.reason[strStack]);
            }
            else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(errorObj)) {
                details = _convertStackObj(errorObj);
            }
            else {
                var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(errorObj[strErrorSrc])) {
                    if (evtMessage) {
                        evtMessage += "\n";
                    }
                    evtMessage += " from " + errorObj[strErrorSrc];
                }
                if (evtMessage) {
                    details = _convertStackObj(evtMessage);
                }
            }
        }
        catch (e) {
            // something unexpected happened so to avoid failing to report any error lets swallow the exception
            // and fallback to the callee/caller method
            details = _convertStackObj(e);
        }
    }
    return details || {
        src: "",
        obj: null
    };
}
function _formatStackTrace(stackDetails) {
    var stack = "";
    if (stackDetails) {
        if (stackDetails.obj) {
            stack = stackDetails.obj.join("\n");
        }
        else {
            stack = stackDetails.src || "";
        }
    }
    return stack;
}
function _parseStack(stack) {
    var parsedStack;
    var frames = stack.obj;
    if (frames && frames[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0) {
        parsedStack = [];
        var level_1 = 0;
        var foundStackStart_1 = false;
        var totalSizeInBytes_1 = 0;
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrForEach)(frames, function (frame) {
            if (foundStackStart_1 || _isStackFrame(frame)) {
                var theFrame = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.asString)(frame);
                // Once we have found the first stack frame we treat the rest of the lines as part of the stack
                foundStackStart_1 = true;
                var parsedFrame = _extractStackFrame(theFrame, level_1);
                if (parsedFrame) {
                    totalSizeInBytes_1 += parsedFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];
                    parsedStack.push(parsedFrame);
                    level_1++;
                }
            }
        });
        // DP Constraint - exception parsed stack must be < 32KB
        // remove frames from the middle to meet the threshold
        var exceptionParsedStackThreshold = 32 * 1024;
        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {
            var left = 0;
            var right = parsedStack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] - 1;
            var size = 0;
            var acceptedLeft = left;
            var acceptedRight = right;
            while (left < right) {
                // check size
                var lSize = parsedStack[left][_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];
                var rSize = parsedStack[right][_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];
                size += lSize + rSize;
                if (size > exceptionParsedStackThreshold) {
                    // remove extra frames from the middle
                    var howMany = acceptedRight - acceptedLeft + 1;
                    parsedStack.splice(acceptedLeft, howMany);
                    break;
                }
                // update pointers
                acceptedLeft = left;
                acceptedRight = right;
                left++;
                right--;
            }
        }
    }
    return parsedStack;
}
function _getErrorType(errorType) {
    // Gets the Error Type by passing the constructor (used to get the true type of native error object).
    var typeName = "";
    if (errorType) {
        typeName = errorType.typeName || errorType[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_NAME /* @min:%2ename */] || "";
        if (!typeName) {
            try {
                var funcNameRegex = /function (.{1,200})\(/;
                var results = (funcNameRegex).exec((errorType).constructor[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TO_STRING /* @min:%2etoString */]());
                typeName = (results && results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 1) ? results[1] : "";
            }
            catch (e) {
                // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do
            }
        }
    }
    return typeName;
}
/**
 * Formats the provided errorObj for display and reporting, it may be a String, Object, integer or undefined depending on the browser.
 * @param errorObj - The supplied errorObj
 */
function _formatErrorCode(errorObj) {
    if (errorObj) {
        try {
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(errorObj)) {
                var errorType = _getErrorType(errorObj);
                var result = _stringify(errorObj, false);
                if (!result || result === "{}") {
                    if (errorObj[strError]) {
                        // Looks like an MS Error Event
                        errorObj = errorObj[strError];
                        errorType = _getErrorType(errorObj);
                    }
                    result = _stringify(errorObj, true);
                }
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strIndexOf)(result, errorType) !== 0 && errorType !== "String") {
                    return errorType + ":" + result;
                }
                return result;
            }
        }
        catch (e) {
            // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do
        }
    }
    // Fallback to just letting the object format itself into a string
    return "" + (errorObj || "");
}
var Exception = /** @class */ (function () {
    /**
     * Constructs a new instance of the ExceptionTelemetry object
     */
    function Exception(logger, exception, properties, measurements, severityLevel, id) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            exceptions: 1 /* FieldType.Required */,
            severityLevel: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2; // TODO: handle the CS"4.0" ==> breeze 2 conversion in a better way
        if (!_isExceptionInternal(exception)) {
            if (!properties) {
                properties = {};
            }
            if (id) {
                properties.id = id;
            }
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EXCEPTIONS /* @min:%2eexceptions */] = [_createExceptionDetails(logger, exception, properties)];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeProperties)(logger, properties);
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeMeasurements)(logger, measurements);
            if (severityLevel) {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = severityLevel;
            }
            if (id) {
                _self.id = id;
            }
        }
        else {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EXCEPTIONS /* @min:%2eexceptions */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EXCEPTIONS /* @min:%2eexceptions */] || [];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROPERTIES /* @min:%2eproperties */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROPERTIES /* @min:%2eproperties */];
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MEASUREMENTS /* @min:%2emeasurements */];
            if (exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */]) {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */];
            }
            if (exception.id) {
                _self.id = exception.id;
                exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROPERTIES /* @min:%2eproperties */].id = exception.id;
            }
            if (exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */]) {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */] = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */];
            }
            // bool/int types, use isNullOrUndefined
            if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(exception.isManual)) {
                _self.isManual = exception.isManual;
            }
        }
    }
    Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
        var errorType = _getErrorType(error || evt || message);
        return {
            message: _formatMessage(message, errorType),
            url: url,
            lineNumber: lineNumber,
            columnNumber: columnNumber,
            error: _formatErrorCode(error || evt || message),
            evt: _formatErrorCode(evt || message),
            typeName: errorType,
            stackDetails: _getStackFromErrorObj(stack || error || evt),
            errorSrc: errorSrc
        };
    };
    Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
        var exceptions = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EXCEPTIONS /* @min:%2eexceptions */]
            && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrMap)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_EXCEPTIONS /* @min:%2eexceptions */], function (ex) { return _createExDetailsFromInterface(logger, ex); });
        var exceptionData = new Exception(logger, (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__assignFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__assignFn)({}, exception), { exceptions: exceptions }), properties, measurements);
        return exceptionData;
    };
    Exception.prototype.toInterface = function () {
        var _a = this, exceptions = _a.exceptions, properties = _a.properties, measurements = _a.measurements, severityLevel = _a.severityLevel, problemGroup = _a.problemGroup, id = _a.id, isManual = _a.isManual;
        var exceptionDetailsInterface = exceptions instanceof Array
            && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrMap)(exceptions, function (exception) { return exception.toInterface(); })
            || undefined;
        return {
            ver: "4.0",
            exceptions: exceptionDetailsInterface,
            severityLevel: severityLevel,
            properties: properties,
            measurements: measurements,
            problemGroup: problemGroup,
            id: id,
            isManual: isManual
        };
    };
    /**
     * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.
     */
    Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
        var _a;
        return {
            exceptions: [
                (_a = {},
                    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HAS_FULL_STACK /* @min:hasFullStack */] = true,
                    _a.message = message,
                    _a.stack = details,
                    _a.typeName = typeName,
                    _a)
            ]
        };
    };
    Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception";
    Exception.dataType = "ExceptionData";
    Exception.formatError = _formatErrorCode;
    return Exception;
}());

var exDetailsAiDataContract = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objFreeze)({
    id: 0 /* FieldType.Default */,
    outerId: 0 /* FieldType.Default */,
    typeName: 1 /* FieldType.Required */,
    message: 1 /* FieldType.Required */,
    hasFullStack: 0 /* FieldType.Default */,
    stack: 0 /* FieldType.Default */,
    parsedStack: 2 /* FieldType.Array */
});
function _toInterface() {
    var _self = this;
    var parsedStack = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PARSED_STACK /* @min:%2eparsedStack */])
        && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrMap)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return _parsedFrameToInterface(frame); });
    var exceptionDetailsInterface = {
        id: _self.id,
        outerId: _self.outerId,
        typeName: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TYPE_NAME /* @min:%2etypeName */],
        message: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */],
        hasFullStack: _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */],
        stack: _self[strStack],
        parsedStack: parsedStack || undefined
    };
    return exceptionDetailsInterface;
}
function _createExceptionDetails(logger, exception, properties) {
    var _a;
    var id;
    var outerId;
    var typeName;
    var message;
    var hasFullStack;
    var theStack;
    var parsedStack;
    if (!_isExceptionDetailsInternal(exception)) {
        var error = exception;
        var evt = error && error.evt;
        if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isError)(error)) {
            error = error[strError] || evt || error;
        }
        typeName = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeString)(logger, _getErrorType(error)) || _Constants__WEBPACK_IMPORTED_MODULE_2__.strNotSpecified;
        message = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeMessage)(logger, _formatMessage(exception || error, typeName)) || _Constants__WEBPACK_IMPORTED_MODULE_2__.strNotSpecified;
        var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
        parsedStack = _parseStack(stack);
        // after parsedStack is inited, iterate over each frame object, sanitize its assembly field
        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(parsedStack)) {
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrMap)(parsedStack, function (frame) {
                frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ASSEMBLY /* @min:%2eassembly */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeString)(logger, frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ASSEMBLY /* @min:%2eassembly */]);
                frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeString)(logger, frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */]);
            });
        }
        theStack = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_4__.dataSanitizeException)(logger, _formatStackTrace(stack));
        hasFullStack = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(parsedStack) && parsedStack[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > 0;
        if (properties) {
            properties[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TYPE_NAME /* @min:%2etypeName */] = properties[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TYPE_NAME /* @min:%2etypeName */] || typeName;
        }
    }
    else {
        typeName = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_TYPE_NAME /* @min:%2etypeName */];
        message = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MESSAGE /* @min:%2emessage */];
        theStack = exception[strStack];
        parsedStack = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PARSED_STACK /* @min:%2eparsedStack */] || [];
        hasFullStack = exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */];
    }
    return _a = {},
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_AI_DATA_CONTRACT /* @min:aiDataContract */] = exDetailsAiDataContract,
        _a.id = id,
        _a.outerId = outerId,
        _a.typeName = typeName,
        _a.message = message,
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_HAS_FULL_STACK /* @min:hasFullStack */] = hasFullStack,
        _a.stack = theStack,
        _a.parsedStack = parsedStack,
        _a.toInterface = _toInterface,
        _a;
}
function _createExDetailsFromInterface(logger, exception) {
    var parsedStack = ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PARSED_STACK /* @min:%2eparsedStack */])
        && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.arrMap)(exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return _stackFrameFromInterface(frame); }))
        || exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_PARSED_STACK /* @min:%2eparsedStack */];
    var exceptionDetails = _createExceptionDetails(logger, (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__assignFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__assignFn)({}, exception), { parsedStack: parsedStack }));
    return exceptionDetails;
}
function _parseFilename(theFrame, fileName) {
    var lineCol = fileName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MATCH /* @min:%2ematch */](PARSE_FILENAME_LINE_COL);
    if (lineCol && lineCol[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] >= 4) {
        theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */] = lineCol[1];
        theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LINE /* @min:%2eline */] = parseInt(lineCol[2]);
    }
    else {
        var lineNo = fileName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MATCH /* @min:%2ematch */](PARSE_FILENAME_LINE_ONLY);
        if (lineNo && lineNo[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] >= 3) {
            theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */] = lineNo[1];
            theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LINE /* @min:%2eline */] = parseInt(lineNo[2]);
        }
        else {
            theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */] = fileName;
        }
    }
}
function _handleFilename(theFrame, sequence, matches) {
    var filename = theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */];
    if (sequence.fn && matches && matches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > sequence.fn) {
        if (sequence.ln && matches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] > sequence.ln) {
            filename = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(matches[sequence.fn] || "");
            theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LINE /* @min:%2eline */] = parseInt((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(matches[sequence.ln] || "")) || 0;
        }
        else {
            filename = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(matches[sequence.fn] || "");
        }
    }
    if (filename) {
        _parseFilename(theFrame, filename);
    }
}
function _isStackFrame(frame) {
    var result = false;
    if (frame && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(frame)) {
        var trimmedFrame = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(frame);
        if (trimmedFrame) {
            result = IS_FRAME.test(trimmedFrame);
        }
    }
    return result;
}
var stackFrameAiDataContract = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objFreeze)({
    level: 1 /* FieldType.Required */,
    method: 1 /* FieldType.Required */,
    assembly: 0 /* FieldType.Default */,
    fileName: 0 /* FieldType.Default */,
    line: 0 /* FieldType.Default */
});
function _extractStackFrame(frame, level) {
    var _a;
    var theFrame;
    if (frame && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(frame) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(frame)) {
        theFrame = (_a = {},
            _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_AI_DATA_CONTRACT /* @min:aiDataContract */] = stackFrameAiDataContract,
            _a.level = level,
            _a.assembly = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(frame),
            _a.method = NoMethod,
            _a.fileName = "",
            _a.line = 0,
            _a.sizeInBytes = 0,
            _a);
        var idx = 0;
        while (idx < _parseSequence[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */]) {
            var sequence = _parseSequence[idx];
            if (sequence.chk && !sequence.chk(frame)) {
                break;
            }
            if (sequence.pre) {
                frame = sequence.pre(frame);
            }
            // Attempt to "parse" the stack frame
            var matches = frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_MATCH /* @min:%2ematch */](sequence.re);
            if (matches && matches[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */] >= sequence.len) {
                if (sequence.m) {
                    theFrame.method = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(matches[sequence.m] || NoMethod);
                }
                if (sequence.hdl) {
                    // Run any custom handler
                    sequence.hdl(theFrame, sequence, matches);
                }
                else if (sequence.fn) {
                    if (sequence.ln) {
                        theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(matches[sequence.fn] || "");
                        theFrame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LINE /* @min:%2eline */] = parseInt((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.strTrim)(matches[sequence.ln] || "")) || 0;
                    }
                    else {
                        _parseFilename(theFrame, matches[sequence.fn] || "");
                    }
                }
                // We found a match so stop looking
                break;
            }
            idx++;
        }
    }
    return _populateFrameSizeInBytes(theFrame);
}
function _stackFrameFromInterface(frame) {
    var _a;
    var parsedFrame = (_a = {},
        _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_AI_DATA_CONTRACT /* @min:aiDataContract */] = stackFrameAiDataContract,
        _a.level = frame.level,
        _a.method = frame.method,
        _a.assembly = frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ASSEMBLY /* @min:%2eassembly */],
        _a.fileName = frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */],
        _a.line = frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LINE /* @min:%2eline */],
        _a.sizeInBytes = 0,
        _a);
    return _populateFrameSizeInBytes(parsedFrame);
}
function _populateFrameSizeInBytes(frame) {
    var sizeInBytes = STACKFRAME_BASE_SIZE;
    if (frame) {
        sizeInBytes += frame.method[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
        sizeInBytes += frame.assembly[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
        sizeInBytes += frame.fileName[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
        sizeInBytes += frame.level.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
        sizeInBytes += frame.line.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LENGTH /* @min:%2elength */];
        frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = sizeInBytes;
    }
    return frame;
}
function _parsedFrameToInterface(frame) {
    return {
        level: frame.level,
        method: frame.method,
        assembly: frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_ASSEMBLY /* @min:%2eassembly */],
        fileName: frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_FILE_NAME /* @min:%2efileName */],
        line: frame[_DynamicConstants__WEBPACK_IMPORTED_MODULE_3__._DYN_LINE /* @min:%2eline */]
    };
}
//# sourceMappingURL=Exception.js.map

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Metric: () => (/* binding */ Metric)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _Common_DataPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var Metric = /** @class */ (function () {
    /**
     * Constructs a new instance of the MetricTelemetry object
     */
    function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            metrics: 1 /* FieldType.Required */,
            properties: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        var dataPoint = new _Common_DataPoint__WEBPACK_IMPORTED_MODULE_2__.DataPoint();
        dataPoint[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_COUNT /* @min:%2ecount */] = count > 0 ? count : undefined;
        dataPoint.max = isNaN(max) || max === null ? undefined : max;
        dataPoint.min = isNaN(min) || min === null ? undefined : min;
        dataPoint[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_0__.strNotSpecified;
        dataPoint.value = value;
        dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? undefined : stdDev;
        _self.metrics = [dataPoint];
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeMeasurements)(logger, measurements);
    }
    Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric";
    Metric.dataType = "MetricData";
    return Metric;
}());

//# sourceMappingURL=Metric.js.map

/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataPoint: () => (/* binding */ DataPoint)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


var DataPoint = /** @class */ (function () {
    function DataPoint() {
        /**
         * The data contract for serializing this object.
         */
        this.aiDataContract = {
            name: 1 /* FieldType.Required */,
            kind: 0 /* FieldType.Default */,
            value: 1 /* FieldType.Required */,
            count: 0 /* FieldType.Default */,
            min: 0 /* FieldType.Default */,
            max: 0 /* FieldType.Default */,
            stdDev: 0 /* FieldType.Default */
        };
        /**
         * Metric type. Single measurement or the aggregated value.
         */
        this.kind = 0 /* DataPointType.Measurement */;
    }
    return DataPoint;
}());

//# sourceMappingURL=DataPoint.js.map

/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PageView: () => (/* binding */ PageView)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var PageView = /** @class */ (function () {
    /**
     * Constructs a new instance of the PageEventTelemetry object
     */
    function PageView(logger, name, url, durationMs, properties, measurements, id) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            name: 0 /* FieldType.Default */,
            url: 0 /* FieldType.Default */,
            duration: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */,
            id: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        _self.id = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeId)(logger, id);
        _self.url = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeUrl)(logger, url);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_0__.strNotSpecified;
        if (!isNaN(durationMs)) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DURATION /* @min:%2eduration */] = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_1__.msToTimeSpan)(durationMs);
        }
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeMeasurements)(logger, measurements);
    }
    PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview";
    PageView.dataType = "PageviewData";
    return PageView;
}());

//# sourceMappingURL=PageView.js.map

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getExtensionByName: () => (/* binding */ getExtensionByName),
/* harmony export */   isCrossOriginError: () => (/* binding */ isCrossOriginError),
/* harmony export */   msToTimeSpan: () => (/* binding */ msToTimeSpan),
/* harmony export */   stringToBoolOrDefault: () => (/* binding */ stringToBoolOrDefault)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var strEmpty = "";
function stringToBoolOrDefault(str, defaultValue) {
    if (defaultValue === void 0) { defaultValue = false; }
    if (str === undefined || str === null) {
        return defaultValue;
    }
    return str.toString()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === "true";
}
/**
 * Convert ms to c# time span format
 */
function msToTimeSpan(totalms) {
    if (isNaN(totalms) || totalms < 0) {
        totalms = 0;
    }
    totalms = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.mathRound)(totalms);
    var ms = strEmpty + totalms % 1000;
    var sec = strEmpty + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.mathFloor)(totalms / 1000) % 60;
    var min = strEmpty + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.mathFloor)(totalms / (1000 * 60)) % 60;
    var hour = strEmpty + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.mathFloor)(totalms / (1000 * 60 * 60)) % 24;
    var days = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.mathFloor)(totalms / (1000 * 60 * 60 * 24));
    ms = ms[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] === 1 ? "00" + ms : ms[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] === 2 ? "0" + ms : ms;
    sec = sec[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] < 2 ? "0" + sec : sec;
    min = min[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] < 2 ? "0" + min : min;
    hour = hour[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_LENGTH /* @min:%2elength */] < 2 ? "0" + hour : hour;
    return (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
}
function getExtensionByName(extensions, identifier) {
    var extension = null;
    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(extensions, function (value) {
        if (value.identifier === identifier) {
            extension = value;
            return -1;
        }
    });
    return extension;
}
function isCrossOriginError(message, url, lineNumber, columnNumber, error) {
    return !error && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isString)(message) && (message === "Script error." || message === "Script error");
}
//# sourceMappingURL=HelperFuncs.js.map

/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RemoteDependencyData: () => (/* binding */ RemoteDependencyData)
/* harmony export */ });
/* harmony import */ var _HelperFuncs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93);
/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var RemoteDependencyData = /** @class */ (function () {
    /**
     * Constructs a new instance of the RemoteDependencyData object
     */
    function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
        if (requestAPI === void 0) { requestAPI = "Ajax"; }
        this.aiDataContract = {
            id: 1 /* FieldType.Required */,
            ver: 1 /* FieldType.Required */,
            name: 0 /* FieldType.Default */,
            resultCode: 0 /* FieldType.Default */,
            duration: 0 /* FieldType.Default */,
            success: 0 /* FieldType.Default */,
            data: 0 /* FieldType.Default */,
            target: 0 /* FieldType.Default */,
            type: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */,
            kind: 0 /* FieldType.Default */,
            value: 0 /* FieldType.Default */,
            count: 0 /* FieldType.Default */,
            min: 0 /* FieldType.Default */,
            max: 0 /* FieldType.Default */,
            stdDev: 0 /* FieldType.Default */,
            dependencyKind: 0 /* FieldType.Default */,
            dependencySource: 0 /* FieldType.Default */,
            commandName: 0 /* FieldType.Default */,
            dependencyTypeName: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        _self.id = id;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DURATION /* @min:%2eduration */] = (0,_HelperFuncs__WEBPACK_IMPORTED_MODULE_0__.msToTimeSpan)(value);
        _self.success = success;
        _self.resultCode = resultCode + "";
        _self.type = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeString)(logger, requestAPI);
        var dependencyFields = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.AjaxHelperParseDependencyPath)(logger, absoluteUrl, method, commandName);
        _self.data = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeUrl)(logger, commandName) || dependencyFields.data; // get a value from hosturl if commandName not available
        _self.target = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeString)(logger, dependencyFields.target);
        if (correlationContext) {
            _self.target = "".concat(_self.target, " | ").concat(correlationContext);
        }
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeString)(logger, dependencyFields[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_NAME /* @min:%2ename */]);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeMeasurements)(logger, measurements);
    }
    RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency";
    RemoteDependencyData.dataType = "RemoteDependencyData";
    return RemoteDependencyData;
}());

//# sourceMappingURL=RemoteDependencyData.js.map

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Trace: () => (/* binding */ Trace)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var Trace = /** @class */ (function () {
    /**
     * Constructs a new instance of the TraceTelemetry object
     */
    function Trace(logger, message, severityLevel, properties, measurements) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            message: 1 /* FieldType.Required */,
            severityLevel: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        message = message || _Constants__WEBPACK_IMPORTED_MODULE_0__.strNotSpecified;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MESSAGE /* @min:%2emessage */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMessage)(logger, message);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMeasurements)(logger, measurements);
        if (severityLevel) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = severityLevel;
        }
    }
    Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message";
    Trace.dataType = "MessageData";
    return Trace;
}());

//# sourceMappingURL=Trace.js.map

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PageViewPerformance: () => (/* binding */ PageViewPerformance)
/* harmony export */ });
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var PageViewPerformance = /** @class */ (function () {
    /**
     * Constructs a new instance of the PageEventTelemetry object
     */
    function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
        this.aiDataContract = {
            ver: 1 /* FieldType.Required */,
            name: 0 /* FieldType.Default */,
            url: 0 /* FieldType.Default */,
            duration: 0 /* FieldType.Default */,
            perfTotal: 0 /* FieldType.Default */,
            networkConnect: 0 /* FieldType.Default */,
            sentRequest: 0 /* FieldType.Default */,
            receivedResponse: 0 /* FieldType.Default */,
            domProcessing: 0 /* FieldType.Default */,
            properties: 0 /* FieldType.Default */,
            measurements: 0 /* FieldType.Default */
        };
        var _self = this;
        _self.ver = 2;
        _self.url = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeUrl)(logger, url);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_NAME /* @min:%2ename */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeString)(logger, name) || _Constants__WEBPACK_IMPORTED_MODULE_0__.strNotSpecified;
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_PROPERTIES /* @min:%2eproperties */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeProperties)(logger, properties);
        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_MEASUREMENTS /* @min:%2emeasurements */] = (0,_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_2__.dataSanitizeMeasurements)(logger, measurements);
        if (cs4BaseData) {
            _self.domProcessing = cs4BaseData.domProcessing;
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DURATION /* @min:%2eduration */] = cs4BaseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_DURATION /* @min:%2eduration */];
            _self.networkConnect = cs4BaseData.networkConnect;
            _self.perfTotal = cs4BaseData.perfTotal;
            _self.receivedResponse = cs4BaseData.receivedResponse;
            _self.sentRequest = cs4BaseData.sentRequest;
        }
    }
    PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance";
    PageViewPerformance.dataType = "PageviewPerformanceData";
    return PageViewPerformance;
}());

//# sourceMappingURL=PageViewPerformance.js.map

/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Data: () => (/* binding */ Data)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


var Data = /** @class */ (function () {
    /**
     * Constructs a new instance of telemetry data.
     */
    function Data(baseType, data) {
        /**
         * The data contract for serializing this object.
         */
        this.aiDataContract = {
            baseType: 1 /* FieldType.Required */,
            baseData: 1 /* FieldType.Required */
        };
        this.baseType = baseType;
        this.baseData = data;
    }
    return Data;
}());

//# sourceMappingURL=Data.js.map

/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SeverityLevel: () => (/* binding */ SeverityLevel)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



/**
 * Defines the level of severity for the event.
 */
var SeverityLevel = ( /* @__PURE__ */(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.createEnumStyle)({
    Verbose: 0 /* eSeverityLevel.Verbose */,
    Information: 1 /* eSeverityLevel.Information */,
    Warning: 2 /* eSeverityLevel.Warning */,
    Error: 3 /* eSeverityLevel.Error */,
    Critical: 4 /* eSeverityLevel.Critical */
}));
//# sourceMappingURL=SeverityLevel.js.map

/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigurationManager: () => (/* binding */ ConfigurationManager)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




var ConfigurationManager = /** @class */ (function () {
    function ConfigurationManager() {
    }
    ConfigurationManager.getConfig = function (config, field, identifier, defaultValue) {
        if (defaultValue === void 0) { defaultValue = false; }
        var configValue;
        if (identifier && config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXTENSION_CONFIG /* @min:%2eextensionConfig */] && config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXTENSION_CONFIG /* @min:%2eextensionConfig */][identifier] && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXTENSION_CONFIG /* @min:%2eextensionConfig */][identifier][field])) {
            configValue = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_EXTENSION_CONFIG /* @min:%2eextensionConfig */][identifier][field];
        }
        else {
            configValue = config[field];
        }
        return !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(configValue) ? configValue : defaultValue;
    };
    return ConfigurationManager;
}());

//# sourceMappingURL=IConfig.js.map

/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContextTagKeys: () => (/* binding */ ContextTagKeys)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */




function _aiNameFunc(baseName) {
    var aiName = "ai." + baseName + ".";
    return function (name) {
        return aiName + name;
    };
}
var _aiApplication = _aiNameFunc("application");
var _aiDevice = _aiNameFunc("device");
var _aiLocation = _aiNameFunc("location");
var _aiOperation = _aiNameFunc("operation");
var _aiSession = _aiNameFunc("session");
var _aiUser = _aiNameFunc("user");
var _aiCloud = _aiNameFunc("cloud");
var _aiInternal = _aiNameFunc("internal");
var ContextTagKeys = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__extendsFn)(ContextTagKeys, _super);
    function ContextTagKeys() {
        return _super.call(this) || this;
    }
    return ContextTagKeys;
}((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.createClassFromInterface)({
    applicationVersion: _aiApplication("ver"),
    applicationBuild: _aiApplication("build"),
    applicationTypeId: _aiApplication("typeId"),
    applicationId: _aiApplication("applicationId"),
    applicationLayer: _aiApplication("layer"),
    deviceId: _aiDevice("id"),
    deviceIp: _aiDevice("ip"),
    deviceLanguage: _aiDevice("language"),
    deviceLocale: _aiDevice("locale"),
    deviceModel: _aiDevice("model"),
    deviceFriendlyName: _aiDevice("friendlyName"),
    deviceNetwork: _aiDevice("network"),
    deviceNetworkName: _aiDevice("networkName"),
    deviceOEMName: _aiDevice("oemName"),
    deviceOS: _aiDevice("os"),
    deviceOSVersion: _aiDevice("osVersion"),
    deviceRoleInstance: _aiDevice("roleInstance"),
    deviceRoleName: _aiDevice("roleName"),
    deviceScreenResolution: _aiDevice("screenResolution"),
    deviceType: _aiDevice("type"),
    deviceMachineName: _aiDevice("machineName"),
    deviceVMName: _aiDevice("vmName"),
    deviceBrowser: _aiDevice("browser"),
    deviceBrowserVersion: _aiDevice("browserVersion"),
    locationIp: _aiLocation("ip"),
    locationCountry: _aiLocation("country"),
    locationProvince: _aiLocation("province"),
    locationCity: _aiLocation("city"),
    operationId: _aiOperation("id"),
    operationName: _aiOperation("name"),
    operationParentId: _aiOperation("parentId"),
    operationRootId: _aiOperation("rootId"),
    operationSyntheticSource: _aiOperation("syntheticSource"),
    operationCorrelationVector: _aiOperation("correlationVector"),
    sessionId: _aiSession("id"),
    sessionIsFirst: _aiSession("isFirst"),
    sessionIsNew: _aiSession("isNew"),
    userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
    userAccountId: _aiUser("accountId"),
    userAgent: _aiUser("userAgent"),
    userId: _aiUser("id"),
    userStoreRegion: _aiUser("storeRegion"),
    userAuthUserId: _aiUser("authUserId"),
    userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
    userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
    cloudName: _aiCloud("name"),
    cloudRole: _aiCloud("role"),
    cloudRoleVer: _aiCloud("roleVer"),
    cloudRoleInstance: _aiCloud("roleInstance"),
    cloudEnvironment: _aiCloud("environment"),
    cloudLocation: _aiCloud("location"),
    cloudDeploymentUnit: _aiCloud("deploymentUnit"),
    internalNodeName: _aiInternal("nodeName"),
    internalSdkVersion: _aiInternal("sdkVersion"),
    internalAgentVersion: _aiInternal("agentVersion"),
    internalSnippet: _aiInternal("snippet"),
    internalSdkSrc: _aiInternal("sdkSrc")
})));

//# sourceMappingURL=ContextTagKeys.js.map

/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TelemetryItemCreator: () => (/* binding */ TelemetryItemCreator),
/* harmony export */   createTelemetryItem: () => (/* binding */ createTelemetryItem)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78);
/* harmony import */ var _Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





/**
 * Create a telemetry item that the 1DS channel understands
 * @param item - domain specific properties; part B
 * @param baseType - telemetry item type. ie PageViewData
 * @param envelopeName - Name of the envelope, e.g., `Microsoft.ApplicationInsights.\<instrumentation key\>.PageView`.
 * @param customProperties - user defined custom properties; part C
 * @param systemProperties - system properties that are added to the context; part A
 * @returns ITelemetryItem that is sent to channel
 */
function createTelemetryItem(item, baseType, envelopeName, logger, customProperties, systemProperties) {
    envelopeName = (0,_Telemetry_Common_DataSanitizer__WEBPACK_IMPORTED_MODULE_3__.dataSanitizeString)(logger, envelopeName) || _Constants__WEBPACK_IMPORTED_MODULE_2__.strNotSpecified;
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(item) ||
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(baseType) ||
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(envelopeName)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.throwError)("Input doesn't contain all required fields");
    }
    var iKey = "";
    if (item[_Constants__WEBPACK_IMPORTED_MODULE_2__.strIkey]) {
        iKey = item[_Constants__WEBPACK_IMPORTED_MODULE_2__.strIkey];
        delete item[_Constants__WEBPACK_IMPORTED_MODULE_2__.strIkey];
    }
    var telemetryItem = {
        name: envelopeName,
        time: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.toISOString)(new Date()),
        iKey: iKey,
        ext: systemProperties ? systemProperties : {},
        tags: [],
        data: {},
        baseType: baseType,
        baseData: item // Part B
    };
    // Part C
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isNullOrUndefined)(customProperties)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(customProperties, function (prop, value) {
            telemetryItem.data[prop] = value;
        });
    }
    return telemetryItem;
}
var TelemetryItemCreator = /** @class */ (function () {
    function TelemetryItemCreator() {
    }
    /**
     * Create a telemetry item that the 1DS channel understands
     * @param item - domain specific properties; part B
     * @param baseType - telemetry item type. ie PageViewData
     * @param envelopeName - Name of the envelope (e.g., Microsoft.ApplicationInsights.[instrumentationKey].PageView).
     * @param customProperties - user defined custom properties; part C
     * @param systemProperties - system properties that are added to the context; part A
     * @returns ITelemetryItem that is sent to channel
     */
    TelemetryItemCreator.create = createTelemetryItem;
    return TelemetryItemCreator;
}());

//# sourceMappingURL=TelemetryItemCreator.js.map

/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CtxTagKeys: () => (/* binding */ CtxTagKeys),
/* harmony export */   Extensions: () => (/* binding */ Extensions)
/* harmony export */ });
/* harmony import */ var _Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */

var Extensions = {
    UserExt: "user",
    DeviceExt: "device",
    TraceExt: "trace",
    WebExt: "web",
    AppExt: "app",
    OSExt: "os",
    SessionExt: "ses",
    SDKExt: "sdk"
};
var CtxTagKeys = new _Contracts_ContextTagKeys__WEBPACK_IMPORTED_MODULE_0__.ContextTagKeys();
//# sourceMappingURL=PartAExtensions.js.map

/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDomEvent: () => (/* binding */ createDomEvent)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



function createDomEvent(eventName) {
    var event = null;
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(Event)) { // Use Event constructor when available
        event = new Event(eventName);
    }
    else { // Event has no constructor in IE
        var doc = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
        if (doc && doc.createEvent) {
            event = doc.createEvent("Event");
            event.initEvent(eventName, true, true);
        }
    }
    return event;
}
//# sourceMappingURL=DomHelperFuncs.js.map

/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOfflineListener: () => (/* binding */ createOfflineListener)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/*
 * Application Insights JavaScript SDK - Common, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */

function _disableEvents(target, evtNamespace) {
    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.eventOff)(target, null, null, evtNamespace);
}
/**
 * Create a new OfflineListener instance to monitor browser online / offline events
 * @param parentEvtNamespace - The parent event namespace to append to any specific events for this instance
 */
function createOfflineListener(parentEvtNamespace) {
    var _document = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)();
    var _navigator = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getNavigator)(); // Gets the window.navigator or workerNavigator depending on the global
    var _isListening = false;
    var listenerList = [];
    // Set the initial state
    // rState is changed by the browser, both via events and when we check the navigator.onLine property
    var rState = 1 /* eOfflineValue.Online */;
    if (_navigator && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(_navigator.onLine) && !_navigator.onLine) { // navigator.onLine is undefined in react-native
        rState = 2 /* eOfflineValue.Offline */;
    }
    // ustate is changed by the user calling setOnlineState
    var uState = 0 /* eOfflineValue.Unknown */;
    // current state would be updated each time rState or uState is changed
    // it is a resolved value of rState and uState
    var _currentState = calCurrentState();
    var _evtNamespace = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeEvtNamespace)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.createUniqueNamespace)("OfflineListener"), parentEvtNamespace);
    try {
        if (_enableEvents((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getWindow)())) {
            _isListening = true;
        }
        if (_document) {
            // Also attach to the document.body or document
            var target = _document.body || _document;
            if (target.ononline) {
                if (_enableEvents(target)) {
                    _isListening = true;
                }
            }
        }
    }
    catch (e) {
        // this makes react-native less angry
        _isListening = false;
    }
    function _enableEvents(target) {
        var enabled = false;
        if (target) {
            enabled = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.eventOn)(target, "online", _setOnline, _evtNamespace);
            if (enabled) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.eventOn)(target, "offline", _setOffline, _evtNamespace);
            }
        }
        return enabled;
    }
    function _isOnline() {
        return _currentState;
    }
    function calCurrentState() {
        if (uState === 2 /* eOfflineValue.Offline */ || rState === 2 /* eOfflineValue.Offline */) {
            return false;
        }
        return true; // if both unknown, then we assume the network is good
    }
    function listnerNoticeCheck() {
        // we were offline and are now online or we were online and now offline
        var newState = calCurrentState();
        if (_currentState !== newState) {
            _currentState = newState; // use the resolved state to update
            // send all the callbacks with the current state
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.arrForEach)(listenerList, function (callback) {
                var offlineState = {
                    isOnline: _currentState,
                    rState: rState,
                    uState: uState
                };
                try {
                    callback(offlineState);
                }
                catch (e) {
                    // Do nothing, just making sure we run all of the callbacks
                }
            });
        }
    }
    function setOnlineState(newState) {
        uState = newState;
        listnerNoticeCheck();
    }
    function _setOnline() {
        rState = 1 /* eOfflineValue.Online */;
        listnerNoticeCheck();
    }
    function _setOffline() {
        rState = 2 /* eOfflineValue.Offline */;
        listnerNoticeCheck();
    }
    function _unload() {
        var win = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.getWindow)();
        if (win && _isListening) {
            _disableEvents(win, _evtNamespace);
            if (_document) {
                // Also attach to the document.body or document
                var target = _document.body || _document;
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(target.ononline)) {
                    _disableEvents(target, _evtNamespace);
                }
            }
            _isListening = false;
        }
    }
    function addListener(callback) {
        listenerList.push(callback);
        // Define rm as an instance of IUnloadHook
        return {
            rm: function () {
                var index = listenerList.indexOf(callback);
                if (index > -1) {
                    return listenerList.splice(index, 1);
                }
                else {
                    return;
                }
            }
        };
    }
    return {
        isOnline: _isOnline,
        isListening: function () { return _isListening; },
        unload: _unload,
        addListener: addListener,
        setOnlineState: setOnlineState
    };
}
//# sourceMappingURL=Offline.js.map

/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TelemetryUtil: () => (/* binding */ TelemetryUtil)
/* harmony export */ });
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
class TelemetryUtil {
    static applyReplacements(data, replacementOptions) {
        for (const key of Object.keys(data)) {
            for (const option of replacementOptions) {
                if (option.lookup.test(key)) {
                    if (option.replacementString !== undefined) {
                        data[key] = option.replacementString;
                    }
                    else {
                        delete data[key];
                    }
                }
            }
        }
    }
    /**
     * Given a key / connection string checks if it is a valid 1DS key
     * @param key The key to check if it's a valid 1DS key
     */
    static shouldUseOneDataSystemSDK(key) {
        // Simple to check to ensure the key is the right length and the dashes are in the right spot
        return (key.length === 74 &&
            key[32] === "-" &&
            key[41] === "-" &&
            key[46] === "-" &&
            key[51] === "-" &&
            key[56] === "-" &&
            key[69] === "-");
    }
    // This also includes the common properties which core mixes in
    // __GDPR__COMMON__ "common.os" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.nodeArch" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.platformversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.extname" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.extversion" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodemachineid" : { "endPoint": "MacAddressHash", "classification": "EndUserPseudonymizedInformation", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodesessionid" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodecommithash" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.vscodeversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.uikind" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.remotename" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.isnewappinstall" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.product" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    // __GDPR__COMMON__ "common.telemetryclientversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
    static getAdditionalCommonProperties(osShim) {
        return {
            "common.os": osShim.platform,
            "common.nodeArch": osShim.architecture,
            "common.platformversion": (osShim.release || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3"),
            // Do not change this string as it gets found and replaced upon packaging
            "common.telemetryclientversion": "1.2.0"
        };
    }
    // Get singleton instance of TelemetryUtil
    static getInstance() {
        if (!TelemetryUtil._instance) {
            TelemetryUtil._instance = new TelemetryUtil();
        }
        return TelemetryUtil._instance;
    }
}
//# sourceMappingURL=util.js.map

/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AppInsightsCore: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.AppInsightsCore),
/* harmony export */   ApplicationInsights: () => (/* binding */ ApplicationInsights),
/* harmony export */   Sender: () => (/* reexport safe */ _microsoft_applicationinsights_channel_js__WEBPACK_IMPORTED_MODULE_1__.Sender),
/* harmony export */   SeverityLevel: () => (/* reexport safe */ _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__.SeverityLevel),
/* harmony export */   arrForEach: () => (/* reexport safe */ _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.arrForEach),
/* harmony export */   isNullOrUndefined: () => (/* reexport safe */ _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.isNullOrUndefined),
/* harmony export */   proxyFunctions: () => (/* reexport safe */ _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.proxyFunctions),
/* harmony export */   throwError: () => (/* reexport safe */ _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.throwError)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _microsoft_applicationinsights_channel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(107);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(22);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(39);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(21);
/* harmony import */ var _nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(17);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(116);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(98);
/*
 * Application Insights JavaScript Web SDK - Basic, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


var _a, _b;







var UNDEFINED_VALUE = undefined;
var defaultConfigValues = (_a = {
        diagnosticLogInterval: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_7__.cfgDfValidate)(_chkDiagLevel, 10000)
    },
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_CONNECTION_STRING /* @min:connectionString */] = UNDEFINED_VALUE,
    _a.endpointUrl = UNDEFINED_VALUE,
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_INSTRUMENTATION_KEY /* @min:instrumentationKey */] = UNDEFINED_VALUE,
    _a.featureOptIn = (_b = {},
        _b["zipPayload"] = { mode: 1 /* FeatureOptInMode.none */ },
        _b),
    _a.extensionConfig = {},
    _a);
function _chkDiagLevel(value) {
    // Make sure we have a value > 0
    return value && value > 0;
}
/**
 * @export
 */
var ApplicationInsights = /** @class */ (function () {
    /**
     * Creates an instance of ApplicationInsights.
     * @param config - The configuration to use for this ApplicationInsights instance
     */
    function ApplicationInsights(config) {
        var core = new _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.AppInsightsCore();
        var _config;
        // initialize the queue and config in case they are undefined
        if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.isNullOrUndefined)(config) ||
            ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.isNullOrUndefined)(config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]) && (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.isNullOrUndefined)(config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_CONNECTION_STRING /* @min:%2econnectionString */]))) {
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.throwError)("Invalid input configuration");
        }
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(ApplicationInsights, this, function (_self) {
            // Define _self.config
            (0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.objDefine)(_self, "config", {
                g: function () { return _config; }
            });
            _initialize();
            _self.initialize = _initialize;
            _self.track = _track;
            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.proxyFunctions)(_self, core, [
                "flush",
                "pollInternalLogs",
                "stopPollingInternalLogs",
                "unload",
                "getPlugin",
                "addPlugin",
                "evtNamespace",
                "addUnloadCb",
                "onCfgChange",
                "getTraceCtx",
                "updateCfg",
                "addTelemetryInitializer"
            ]);
            function _initialize() {
                var cfgHandler = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.createDynamicConfig)(config || {}, defaultConfigValues);
                _config = cfgHandler.cfg;
                core.addUnloadHook((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__.onConfigChange)(cfgHandler, function () {
                    var configCs = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_CONNECTION_STRING /* @min:%2econnectionString */];
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.isPromiseLike)(configCs)) {
                        var ikeyPromise = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_8__.createSyncPromise)(function (resolve, reject) {
                            (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_8__.doAwaitResponse)(configCs, function (res) {
                                var curCs = res.value;
                                var ikey = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];
                                if (!res.rejected && curCs) {
                                    // replace cs with resolved values in case of circular promises
                                    _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_CONNECTION_STRING /* @min:%2econnectionString */] = curCs;
                                    var resolvedCs = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.parseConnectionString)(curCs);
                                    ikey = resolvedCs.instrumentationkey || ikey;
                                }
                                resolve(ikey);
                            });
                        });
                        var urlPromise = (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_8__.createSyncPromise)(function (resolve, reject) {
                            (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_8__.doAwaitResponse)(configCs, function (res) {
                                var curCs = res.value;
                                var url = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];
                                if (!res.rejected && curCs) {
                                    var resolvedCs = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.parseConnectionString)(curCs);
                                    var ingest = resolvedCs.ingestionendpoint;
                                    url = ingest ? ingest + _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_BREEZE_PATH : url;
                                }
                                resolve(url);
                            });
                        });
                        _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = ikeyPromise;
                        _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] || urlPromise;
                    }
                    if ((0,_nevware21_ts_utils__WEBPACK_IMPORTED_MODULE_9__.isString)(configCs)) {
                        var cs = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.parseConnectionString)(configCs);
                        var ingest = cs.ingestionendpoint;
                        _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] ? _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] : (ingest + _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_BREEZE_PATH); // only add /v2/track when from connectionstring
                        _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = cs.instrumentationkey || _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];
                    }
                    // userOverrideEndpointUrl have the highest priority
                    _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] ? _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_USER_OVERRIDE_ENDPOI0 /* @min:%2euserOverrideEndpointUrl */] : _config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_10__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];
                }));
                // initialize core
                core.initialize(_config, [new _microsoft_applicationinsights_channel_js__WEBPACK_IMPORTED_MODULE_1__.Sender()]);
            }
        });
        function _track(item) {
            if (item) {
                // to pass sender.processTelemetry()
                item.baseData = item.baseData || {};
                item.baseType = item.baseType || "EventData";
            }
            core.track(item);
        }
    }
// Removed Stub for ApplicationInsights.prototype.initialize.
// Removed Stub for ApplicationInsights.prototype.track.
// Removed Stub for ApplicationInsights.prototype.flush.
// Removed Stub for ApplicationInsights.prototype.pollInternalLogs.
// Removed Stub for ApplicationInsights.prototype.stopPollingInternalLogs.
// Removed Stub for ApplicationInsights.prototype.unload.
// Removed Stub for ApplicationInsights.prototype.getPlugin.
// Removed Stub for ApplicationInsights.prototype.addPlugin.
// Removed Stub for ApplicationInsights.prototype.evtNamespace.
// Removed Stub for ApplicationInsights.prototype.addUnloadCb.
// Removed Stub for ApplicationInsights.prototype.getTraceCtx.
// Removed Stub for ApplicationInsights.prototype.addTelemetryInitializer.
// Removed Stub for ApplicationInsights.prototype.updateCfg.
// Removed Stub for ApplicationInsights.prototype.onCfgChange.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    ApplicationInsights.__ieDyn=1;

    return ApplicationInsights;
}());




//# sourceMappingURL=index.js.map

/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sender: () => (/* binding */ Sender)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(79);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(78);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(89);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(90);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(92);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(94);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(95);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(96);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(76);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(84);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(104);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(34);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(49);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(36);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(24);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(59);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(60);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(61);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(28);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(40);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(44);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(23);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(22);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(39);
/* harmony import */ var _nevware21_ts_async__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(21);
/* harmony import */ var _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(108);
/* harmony import */ var _SendBuffer__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(111);
/* harmony import */ var _Serializer__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(112);
/* harmony import */ var _TelemetryProcessors_Sample__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(113);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(110);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
var _a, _b;











var UNDEFINED_VALUE = undefined;
var EMPTY_STR = "";
var FetchSyncRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)
function _getResponseText(xhr) {
    try {
        return xhr.responseText;
    }
    catch (e) {
        // Best effort, as XHR may throw while XDR wont so just ignore
    }
    return null;
}
function isOverrideFn(httpXHROverride) {
    return httpXHROverride && httpXHROverride.sendPOST;
}
var defaultAppInsightsChannelConfig = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.objDeepFreeze)((_a = {
        // Use the default value (handles empty string in the configuration)
        endpointUrl: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfValidate)(_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isTruthy, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BREEZE_ENDPOINT + _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_BREEZE_PATH)
    },
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_EMIT_LINE_DELIMITED_0 /* @min:emitLineDelimitedJson */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(),
    _a.maxBatchInterval = 15000,
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:maxBatchSizeInBytes */] = 102400,
    _a.disableTelemetry = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENABLE_SESSION_STORA5 /* @min:enableSessionStorageBuffer */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(true),
    _a.isRetryDisabled = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_IS_BEACON_API_DISABL3 /* @min:isBeaconApiDisabled */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(true),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DISABLE_SEND_BEACON_7 /* @min:disableSendBeaconSplit */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(true),
    _a.disableXhr = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ONUNLOAD_DISABLE_FET6 /* @min:onunloadDisableFetch */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ONUNLOAD_DISABLE_BEA2 /* @min:onunloadDisableBeacon */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_INSTRUMENTATION_KEY /* @min:instrumentationKey */] = UNDEFINED_VALUE,
    _a.namePrefix = UNDEFINED_VALUE,
    _a.samplingPercentage = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfValidate)(_chkSampling, 100),
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_CUSTOM_HEADERS /* @min:customHeaders */] = UNDEFINED_VALUE,
    _a.convertUndefined = UNDEFINED_VALUE,
    _a.eventsLimitInMem = 10000,
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_BUFFER_OVERRIDE /* @min:bufferOverride */] = false,
    _a.httpXHROverride = { isVal: isOverrideFn, v: UNDEFINED_VALUE },
    _a[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ALWAYS_USE_XHR_OVERR4 /* @min:alwaysUseXhrOverride */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_28__.cfgDfBoolean)(),
    _a.transports = UNDEFINED_VALUE,
    _a.retryCodes = UNDEFINED_VALUE,
    _a.corsPolicy = UNDEFINED_VALUE,
    _a.maxRetryCnt = { isVal: _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isNumber, v: 10 },
    _a));
var CrossOriginResourcePolicyHeader = "X-Set-Cross-Origin-Resource-Policy";
function _chkSampling(value) {
    return !isNaN(value) && value > 0 && value <= 100;
}
var EnvelopeTypeCreator = (_b = {},
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__.Event.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__.EventEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Trace.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__.TraceEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.PageView.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__.PageViewEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__.PageViewPerformance.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__.PageViewPerformanceEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_6__.Exception.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__.ExceptionEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__.Metric.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__.MetricEnvelopeCreator,
    _b[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__.RemoteDependencyData.dataType] = _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__.DependencyEnvelopeCreator,
    _b);
var Sender = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__extendsFn)(Sender, _super);
    function Sender() {
        var _this = _super.call(this) || this;
        _this.priority = 1001;
        _this.identifier = _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.BreezeChannelIdentifier;
        // Don't set the defaults here, set them in the _initDefaults() as this is also called during unload
        var _consecutiveErrors; // How many times in a row a retryable error condition has occurred.
        var _retryAt; // The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).
        var _lastSend; // The time of the last send operation.
        var _paused; // Flag indicating that the sending should be paused
        var _timeoutHandle; // Handle to the timer for delayed sending of batches of data.
        var _serializer;
        var _stamp_specific_redirects;
        var _headers;
        var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)
        var _syncUnloadSender; // The identified sender to use for the synchronous unload stage
        var _offlineListener;
        var _evtNamespace;
        var _endpointUrl;
        var _orgEndpointUrl;
        var _maxBatchSizeInBytes;
        var _beaconSupported;
        var _beaconOnUnloadSupported;
        var _beaconNormalSupported;
        var _customHeaders;
        var _disableTelemetry;
        var _instrumentationKey;
        var _convertUndefined;
        var _isRetryDisabled;
        var _maxBatchInterval;
        var _sessionStorageUsed;
        var _bufferOverrideUsed;
        var _namePrefix;
        var _enableSendPromise;
        var _alwaysUseCustomSend;
        var _disableXhr;
        var _fetchKeepAlive;
        var _xhrSend;
        var _fallbackSend;
        var _disableBeaconSplit;
        var _sendPostMgr;
        var _retryCodes;
        var _zipPayload;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Sender, _this, function (_self, _base) {
            _initDefaults();
            _self.pause = function () {
                _clearScheduledTimer();
                _paused = true;
            };
            _self.resume = function () {
                if (_paused) {
                    _paused = false;
                    _retryAt = null;
                    // flush if we have exceeded the max-size already
                    _checkMaxSize();
                    _setupTimer();
                }
            };
            _self.flush = function (isAsync, callBack, sendReason) {
                if (isAsync === void 0) { isAsync = true; }
                if (!_paused) {
                    // Clear the normal schedule timer as we are going to try and flush ASAP
                    _clearScheduledTimer();
                    try {
                        var result_1 = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */](isAsync, null, sendReason || 1 /* SendRequestReason.ManualFlush */);
                        // Handles non-promise and always called if the returned promise resolves or rejects
                        return (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_29__.doAwaitResponse)(result_1, function (rsp) {
                            if (callBack) {
                                callBack(!rsp.rejected);
                                return true;
                            }
                            // When async=true and no callback, return a promise
                            if (isAsync) {
                                return (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_29__.createPromise)(function (resolve) {
                                    resolve(!rsp.rejected);
                                });
                            }
                            return result_1;
                        });
                    }
                    catch (e) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 22 /* _eInternalMessageId.FlushFailed */, "flush failed, telemetry will not be collected: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.dumpObj)(e) });
                    }
                }
            };
            _self.onunloadFlush = function () {
                if (!_paused) {
                    if (_beaconSupported || _alwaysUseCustomSend) {
                        try {
                            return _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, _doUnloadSend, 2 /* SendRequestReason.Unload */);
                        }
                        catch (e) {
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.dumpObj)(e) });
                        }
                    }
                    else {
                        _self.flush(false);
                    }
                }
            };
            _self.addHeader = function (name, value) {
                _headers[name] = value;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {
                if (_self.isInitialized()) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, "Sender is already initialized");
                }
                _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_INITIALIZE /* @min:%2einitialize */](config, core, extensions, pluginChain);
                var identifier = _self.identifier;
                _serializer = new _Serializer__WEBPACK_IMPORTED_MODULE_32__.Serializer(core.logger);
                _consecutiveErrors = 0;
                _retryAt = null;
                _lastSend = 0;
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__SENDER /* @min:%2e_sender */] = null;
                _stamp_specific_redirects = 0;
                var diagLog = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */]();
                _evtNamespace = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_22__.mergeEvtNamespace)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_26__.createUniqueNamespace)("Sender"), core.evtNamespace && core.evtNamespace());
                _offlineListener = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_14__.createOfflineListener)(_evtNamespace);
                // This function will be re-called whenever any referenced configuration is changed
                _self._addHook((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_27__.onConfigChange)(config, function (details) {
                    var config = details.cfg;
                    if (config.storagePrefix) {
                        (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__.utlSetStoragePrefix)(config.storagePrefix);
                    }
                    var ctx = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_25__.createProcessTelemetryContext)(null, config, core);
                    // getExtCfg only finds undefined values from core
                    var senderConfig = ctx.getExtCfg(identifier, defaultAppInsightsChannelConfig);
                    var curExtUrl = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];
                    // if it is not inital change (_endpointUrl has value)
                    // if current sender endpoint url is not changed directly
                    // means ExtCfg is not changed directly
                    // then we need to monitor endpoint url changes from core
                    if (_endpointUrl && curExtUrl === _endpointUrl) {
                        var coreUrl = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];
                        // if core endpoint url is changed
                        if (coreUrl && coreUrl !== curExtUrl) {
                            // and endpoint promise changes is handled by this as well
                            senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = coreUrl;
                        }
                    }
                    var csStream = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.getInst)("CompressionStream");
                    // Determine whether to enable payload compression (zipping).
                    _zipPayload = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.isFeatureEnabled)("zipPayload", config, false);
                    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isFunction)(csStream)) {
                        _zipPayload = false;
                    }
                    var corsPolicy = senderConfig.corsPolicy;
                    if (corsPolicy) {
                        if (corsPolicy === "same-origin" || corsPolicy === "same-site" || corsPolicy === "cross-origin") {
                            _this.addHeader(CrossOriginResourcePolicyHeader, corsPolicy);
                        }
                    }
                    else {
                        delete _headers[CrossOriginResourcePolicyHeader];
                    }
                    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isPromiseLike)(senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */])) {
                        // if it is promise, means the endpoint url is from core.endpointurl
                        senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];
                    }
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.objDefine)(_self, "_senderConfig", {
                        g: function () {
                            return senderConfig;
                        }
                    });
                    // Only update the endpoint if the original config !== the current config
                    // This is so any redirect endpointUrl is not overwritten
                    if (_orgEndpointUrl !== senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]) {
                        if (_orgEndpointUrl) {
                            // TODO: add doc to remind users to flush before changing endpoint, otherwise all unsent payload will be sent to new endpoint
                        }
                        _endpointUrl = _orgEndpointUrl = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENDPOINT_URL /* @min:%2eendpointUrl */];
                    }
                    // or is not string
                    if (core.activeStatus() === _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.ActiveStatus.PENDING) {
                        // waiting for core promises to be resolved
                        // NOTE: if active status is set to pending, stop sending, clear timer here
                        _self.pause();
                    }
                    else if (core.activeStatus() === _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.ActiveStatus.ACTIVE) {
                        // core status changed from pending to other status
                        _self.resume();
                    }
                    if (_customHeaders && _customHeaders !== senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */]) {
                        // Removing any previously defined custom headers as they have changed
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.arrForEach)(_customHeaders, function (customHeader) {
                            delete _headers[customHeader.header];
                        });
                    }
                    _maxBatchSizeInBytes = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:%2emaxBatchSizeInBytes */];
                    _beaconSupported = (senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */] === false || senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */] === false) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isBeaconsSupported)();
                    _beaconOnUnloadSupported = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */] === false && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isBeaconsSupported)();
                    _beaconNormalSupported = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */] === false && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isBeaconsSupported)();
                    _alwaysUseCustomSend = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ALWAYS_USE_XHR_OVERR4 /* @min:%2ealwaysUseXhrOverride */];
                    _disableXhr = !!senderConfig.disableXhr;
                    _retryCodes = senderConfig.retryCodes;
                    var bufferOverride = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */];
                    var canUseSessionStorage = !!senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENABLE_SESSION_STORA5 /* @min:%2eenableSessionStorageBuffer */] &&
                        (!!bufferOverride || (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_13__.utlCanUseSessionStorage)());
                    var namePrefix = senderConfig.namePrefix;
                    //Note: emitLineDelimitedJson and eventsLimitInMem is directly accessed via config in senderBuffer
                    //Therefore, if canUseSessionStorage is not changed, we do not need to re initialize a new one
                    var shouldUpdate = (canUseSessionStorage !== _sessionStorageUsed)
                        || (canUseSessionStorage && (_namePrefix !== namePrefix)) // prefixName is only used in session storage
                        || (canUseSessionStorage && (_bufferOverrideUsed !== bufferOverride));
                    if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */]) {
                        // case1 (Pre and Now enableSessionStorageBuffer settings are same)
                        // if namePrefix changes, transfer current buffer to new buffer
                        // else no action needed
                        //case2 (Pre and Now enableSessionStorageBuffer settings are changed)
                        // transfer current buffer to new buffer
                        if (shouldUpdate) {
                            try {
                                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */] = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */].createNew(diagLog, senderConfig, canUseSessionStorage);
                            }
                            catch (e) {
                                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, "failed to transfer telemetry to different buffer storage, telemetry will be lost: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.dumpObj)(e) });
                            }
                        }
                        _checkMaxSize();
                    }
                    else {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */] = canUseSessionStorage
                            ? new _SendBuffer__WEBPACK_IMPORTED_MODULE_31__.SessionStorageSendBuffer(diagLog, senderConfig) : new _SendBuffer__WEBPACK_IMPORTED_MODULE_31__.ArraySendBuffer(diagLog, senderConfig);
                    }
                    _namePrefix = namePrefix;
                    _sessionStorageUsed = canUseSessionStorage;
                    _bufferOverrideUsed = bufferOverride;
                    _fetchKeepAlive = !senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ONUNLOAD_DISABLE_FET6 /* @min:%2eonunloadDisableFetch */] && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isFetchSupported)(true);
                    _disableBeaconSplit = !!senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DISABLE_SEND_BEACON_7 /* @min:%2edisableSendBeaconSplit */];
                    _self._sample = new _TelemetryProcessors_Sample__WEBPACK_IMPORTED_MODULE_33__.Sample(senderConfig.samplingPercentage, diagLog);
                    _instrumentationKey = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];
                    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isPromiseLike)(_instrumentationKey) && !_validateInstrumentationKey(_instrumentationKey, config)) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(diagLog, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, "Invalid Instrumentation key " + _instrumentationKey);
                    }
                    _customHeaders = senderConfig[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */];
                    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isString)(_endpointUrl) && !(0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.isInternalApplicationInsightsEndpoint)(_endpointUrl) && _customHeaders && _customHeaders[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.arrForEach)(_customHeaders, function (customHeader) {
                            _this.addHeader(customHeader.header, customHeader.value);
                        });
                    }
                    else {
                        _customHeaders = null;
                    }
                    _enableSendPromise = senderConfig.enableSendPromise;
                    var sendPostConfig = _getSendPostMgrConfig();
                    // only init it once
                    if (!_sendPostMgr) {
                        _sendPostMgr = new _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_20__.SenderPostManager();
                        _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_INITIALIZE /* @min:%2einitialize */](sendPostConfig, diagLog);
                    }
                    else {
                        _sendPostMgr.SetConfig(sendPostConfig);
                    }
                    var customInterface = senderConfig.httpXHROverride;
                    var httpInterface = null;
                    var syncInterface = null;
                    // User requested transport(s) values > Beacon > Fetch > XHR
                    // Beacon would be filtered out if user has set disableBeaconApi to true at _getSenderInterface
                    var theTransports = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.prependTransports)([3 /* TransportType.Beacon */, 1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */], senderConfig.transports);
                    httpInterface = _sendPostMgr && _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_GET_SENDER_INST /* @min:%2egetSenderInst */](theTransports, false);
                    var xhrInterface = _sendPostMgr && _sendPostMgr.getFallbackInst();
                    _xhrSend = function (payload, isAsync) {
                        return _doSend(xhrInterface, payload, isAsync);
                    };
                    _fallbackSend = function (payload, isAsync) {
                        return _doSend(xhrInterface, payload, isAsync, false);
                    };
                    httpInterface = _alwaysUseCustomSend ? customInterface : (httpInterface || customInterface || xhrInterface);
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__SENDER /* @min:%2e_sender */] = function (payload, isAsync) {
                        return _doSend(httpInterface, payload, isAsync);
                    };
                    if (_fetchKeepAlive) {
                        // Try and use the fetch with keepalive
                        _syncUnloadSender = _fetchKeepAliveSender;
                    }
                    var syncTransports = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.prependTransports)([3 /* TransportType.Beacon */, 1 /* TransportType.Xhr */], senderConfig.unloadTransports);
                    if (!_fetchKeepAlive) {
                        // remove fetch from theTransports
                        syncTransports = syncTransports.filter(function (transport) { return transport !== 2 /* TransportType.Fetch */; });
                    }
                    syncInterface = _sendPostMgr && _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_GET_SENDER_INST /* @min:%2egetSenderInst */](syncTransports, true);
                    syncInterface = _alwaysUseCustomSend ? customInterface : (syncInterface || customInterface);
                    if ((_alwaysUseCustomSend || senderConfig.unloadTransports || !_syncUnloadSender) && syncInterface) {
                        _syncUnloadSender = function (payload, isAsync) {
                            return _doSend(syncInterface, payload, isAsync);
                        };
                    }
                    if (!_syncUnloadSender) {
                        _syncUnloadSender = _xhrSend;
                    }
                    _disableTelemetry = senderConfig.disableTelemetry;
                    _convertUndefined = senderConfig.convertUndefined || UNDEFINED_VALUE;
                    _isRetryDisabled = senderConfig.isRetryDisabled;
                    _maxBatchInterval = senderConfig.maxBatchInterval;
                }));
            };
            _self.processTelemetry = function (telemetryItem, itemCtx) {
                itemCtx = _self._getTelCtx(itemCtx);
                var diagLogger = itemCtx[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */]();
                try {
                    var isValidate = _validate(telemetryItem, diagLogger);
                    if (!isValidate) {
                        return;
                    }
                    var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);
                    if (!aiEnvelope) {
                        return;
                    }
                    // check if the incoming payload is too large, truncate if necessary
                    var payload = _serializer.serialize(aiEnvelope);
                    // flush if we would exceed the max-size limit by adding this item
                    var buffer = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */];
                    _checkMaxSize(payload);
                    var payloadItem = {
                        item: payload,
                        cnt: 0 // inital cnt will always be 0
                    };
                    // enqueue the payload
                    buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENQUEUE /* @min:%2eenqueue */](payloadItem);
                    // ensure an invocation timeout is set
                    _setupTimer();
                }
                catch (e) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(diagLogger, 2 /* eLoggingSeverity.WARNING */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.dumpObj)(e) });
                }
                // hand off the telemetry item to the next plugin
                _self.processNext(telemetryItem, itemCtx);
            };
            _self.isCompletelyIdle = function () {
                return !_paused && _syncFetchPayload === 0 && _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_COUNT /* @min:%2ecount */]() === 0;
            };
            _self.getOfflineListener = function () {
                return _offlineListener;
            };
            /**
             * xhr state changes
             */
            _self._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {
                // since version 3.2.0, this function is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _xhrReadyStateChange(xhr, payload, countOfItemsInPayload);
            };
            /**
             * Immediately send buffered data
             * @param isAsync - Indicates if the events should be sent asynchronously
             * @param forcedSender - Indicates the forcedSender, undefined if not passed
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */] = function (isAsync, forcedSender, sendReason) {
                if (isAsync === void 0) { isAsync = true; }
                var result;
                if (!_paused) {
                    try {
                        var buffer = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */];
                        // Send data only if disableTelemetry is false
                        if (!_disableTelemetry) {
                            if (buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_COUNT /* @min:%2ecount */]() > 0) {
                                var payload = buffer.getItems();
                                _notifySendRequest(sendReason || 0 /* SendRequestReason.Undefined */, isAsync);
                                // invoke send
                                if (forcedSender) {
                                    result = forcedSender.call(_self, payload, isAsync);
                                }
                                else {
                                    result = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__SENDER /* @min:%2e_sender */](payload, isAsync);
                                }
                            }
                            // update lastSend time to enable throttling
                            _lastSend = +new Date;
                        }
                        else {
                            buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_CLEAR /* @min:%2eclear */]();
                        }
                        _clearScheduledTimer();
                    }
                    catch (e) {
                        /* Ignore this error for IE under v10 */
                        var ieVer = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.getIEVersion)();
                        if (!ieVer || ieVer > 9) {
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 40 /* _eInternalMessageId.TransmissionFailed */, "Telemetry transmission failed, some telemetry will be lost: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.dumpObj)(e) });
                        }
                        // potential place to call countException q3
                    }
                }
                return result;
            };
            _self.getOfflineSupport = function () {
                return {
                    getUrl: function () {
                        return _endpointUrl;
                    },
                    createPayload: _createPayload,
                    serialize: _serialize,
                    batch: _batch,
                    shouldProcess: function (evt) {
                        return !!_validate(evt);
                    }
                };
            };
            _self._doTeardown = function (unloadCtx, unloadState) {
                _self.onunloadFlush();
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_17__.runTargetUnload)(_offlineListener, false);
                _initDefaults();
            };
            /**
             * error handler
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_ERROR /* @min:%2e_onError */] = function (payload, message, event) {
                // since version 3.1.3, string[] is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _onError(payload, message, event);
            };
            /**
             * partial success handler
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */] = function (payload, results) {
                // since version 3.1.3, string[] is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _onPartialSuccess(payload, results);
            };
            /**
             * success handler
             */
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_SUCCESS /* @min:%2e_onSuccess */] = function (payload, countOfItemsInPayload) {
                // since version 3.1.3, string[] is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _onSuccess(payload, countOfItemsInPayload);
                //_self._buffer && _self._buffer.clearSent(payload);
            };
            /**
             * xdr state changes
             */
            _self._xdrOnLoad = function (xdr, payload) {
                // since version 3.1.3, string[] is no-op
                if (_isStringArr(payload)) {
                    return;
                }
                return _xdrOnLoad(xdr, payload);
            };
            // function _getStatsBeat() {
            //     let statsBeatConfig: IStatsBeatState = {
            //         cKey: _self._senderConfig.instrumentationKey,
            //         endpoint: _endpointUrl,
            //         sdkVer: EnvelopeCreator.Version,
            //         type: eStatsType.SDK
            //     };
            //     let core = _self.core;
            //     // During page unload the core may have been cleared and some async events may not have been sent yet
            //     // resulting in the core being null. In this case we don't want to create a statsbeat instance
            //     return core ? core.getStatsBeat(statsBeatConfig) : null;
            // }
            function _xdrOnLoad(xdr, payload) {
                var responseText = _getResponseText(xdr);
                if (xdr && (responseText + "" === "200" || responseText === "")) {
                    _consecutiveErrors = 0;
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, 0);
                }
                else {
                    var results = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.parseResponse)(responseText);
                    if (results && results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] && results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] > results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]
                        && !_isRetryDisabled) {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, results);
                    }
                    else {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_ERROR /* @min:%2e_onError */](payload, (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.formatErrorMessageXdr)(xdr));
                    }
                }
            }
            function _getSendPostMgrConfig() {
                try {
                    var onCompleteFuncs = {
                        xdrOnComplete: function (xdr, oncomplete, payload) {
                            var payloadArr = _getPayloadArr(payload);
                            if (!payloadArr) {
                                return;
                            }
                            //const responseText = _getResponseText(xdr);
                            // let statsbeat = _getStatsBeat();
                            // if (statsbeat) {
                            //     if (xdr && (responseText + "" === "200" || responseText === "")) {
                            //         _consecutiveErrors = 0;
                            //         statsbeat.count(200, payload, _endpointUrl);
                            //     } else {
                            //         const results = parseResponse(responseText);
                            //         if (results && results.itemsReceived && results.itemsReceived > results.itemsAccepted
                            //             && !_isRetryDisabled) {
                            //             statsbeat.count(206, payload, _endpointUrl);
                            //         } else {
                            //             statsbeat.count(499, payload, _endpointUrl);
                            //         }
                            //     }
                            // }
                            return _xdrOnLoad(xdr, payloadArr);
                        },
                        fetchOnComplete: function (response, onComplete, resValue, payload) {
                            var payloadArr = _getPayloadArr(payload);
                            if (!payloadArr) {
                                return;
                            }
                            // let statsbeat = _getStatsBeat();
                            // if (statsbeat) {
                            //     statsbeat.count(response.status, payload, _endpointUrl);
                            // }
                            return _checkResponsStatus(response.status, payloadArr, response.url, payloadArr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */], response.statusText, resValue || "");
                        },
                        xhrOnComplete: function (request, oncomplete, payload) {
                            var payloadArr = _getPayloadArr(payload);
                            if (!payloadArr) {
                                return;
                            }
                            // let statsbeat = _getStatsBeat();
                            // if (statsbeat && request.readyState === 4) {
                            //     statsbeat.count(request.status, payload, _endpointUrl);
                            // }
                            return _xhrReadyStateChange(request, payloadArr, payloadArr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */]);
                        },
                        beaconOnRetry: function (data, onComplete, canSend) {
                            // let statsbeat = _getStatsBeat();
                            // if (statsbeat) {
                            //     statsbeat.count(499, data, _endpointUrl);
                            // }
                            return _onBeaconRetry(data, onComplete, canSend);
                        }
                    };
                    var config = {
                        enableSendPromise: _enableSendPromise,
                        isOneDs: false,
                        disableCredentials: false,
                        disableXhr: _disableXhr,
                        disableBeacon: !_beaconNormalSupported,
                        disableBeaconSync: !_beaconOnUnloadSupported,
                        senderOnCompleteCallBack: onCompleteFuncs
                    };
                    return config;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            /**
             * xhr state changes
             */
            function _xhrReadyStateChange(xhr, payload, countOfItemsInPayload) {
                if (xhr.readyState === 4) {
                    _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.formatErrorMessageXhr)(xhr), _getResponseText(xhr) || xhr.response);
                }
            }
            /**
             * error handler
             */
            function _onError(payload, message, event) {
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, "Failed to send telemetry.", { message: message });
                _self._buffer && _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);
            }
            /**
             * partial success handler
             */
            function _onPartialSuccess(payload, results) {
                var failed = [];
                var retry = [];
                // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.
                var errors = results.errors.reverse();
                for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
                    var error = errors_1[_i];
                    var extracted = payload.splice(error.index, 1)[0];
                    if (_isRetriable(error.statusCode)) {
                        retry[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_PUSH /* @min:%2epush */](extracted);
                    }
                    else {
                        // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).
                        failed[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_PUSH /* @min:%2epush */](extracted);
                    }
                }
                if (payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]);
                }
                if (failed[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_ERROR /* @min:%2e_onError */](failed, (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.formatErrorMessageXhr)(null, ["partial success", results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */], "of", results.itemsReceived].join(" ")));
                }
                if (retry[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    _resendPayload(retry);
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, "Partial success. " +
                        "Delivered: " + payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] + ", Failed: " + failed[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] +
                        ". Will retry to send " + retry[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] + " our of " + results[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] + " items");
                }
            }
            /**
             * success handler
             */
            function _onSuccess(payload, countOfItemsInPayload) {
                _self._buffer && _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);
            }
            function _getPayloadArr(payload) {
                try {
                    if (payload) {
                        var internalPayload = payload;
                        var arr = internalPayload.oriPayload;
                        if (arr && arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */]) {
                            return arr;
                        }
                        return null;
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            function _validate(telemetryItem, diagLogger) {
                if (_disableTelemetry) {
                    // Do not send/save data
                    return false;
                }
                // validate input
                if (!telemetryItem) {
                    diagLogger && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 7 /* _eInternalMessageId.CannotSendEmptyTelemetry */, "Cannot send empty telemetry");
                    return false;
                }
                // validate event
                if (telemetryItem.baseData && !telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_BASE_TYPE /* @min:%2ebaseType */]) {
                    diagLogger && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 70 /* _eInternalMessageId.InvalidEvent */, "Cannot send telemetry without baseData and baseType");
                    return false;
                }
                if (!telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_BASE_TYPE /* @min:%2ebaseType */]) {
                    // Default
                    telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_BASE_TYPE /* @min:%2ebaseType */] = "EventData";
                }
                // ensure a sender was constructed
                if (!_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__SENDER /* @min:%2e_sender */]) {
                    diagLogger && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, "Sender was not initialized");
                    return false;
                }
                // check if this item should be sampled in, else add sampleRate tag
                if (!_isSampledIn(telemetryItem)) {
                    // Item is sampled out, do not send it
                    diagLogger && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(diagLogger, 2 /* eLoggingSeverity.WARNING */, 33 /* _eInternalMessageId.TelemetrySampledAndNotSent */, "Telemetry item was sampled out and not sent", { SampleRate: _self._sample[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_SAMPLE_RATE /* @min:%2esampleRate */] });
                    return false;
                }
                else {
                    telemetryItem[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.SampleRate] = _self._sample[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_SAMPLE_RATE /* @min:%2esampleRate */];
                }
                return true;
            }
            function _getEnvelope(telemetryItem, diagLogger) {
                // construct an envelope that Application Insights endpoint can understand
                // if ikey of telemetry is provided and not empty, envelope will use this iKey instead of senderConfig iKey
                var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey;
                var aiEnvelope = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);
                if (!aiEnvelope) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 47 /* _eInternalMessageId.CreateEnvelopeError */, "Unable to create an AppInsights envelope");
                    return;
                }
                var doNotSendItem = false;
                // this is for running in legacy mode, where customer may already have a custom initializer present
                if (telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TAGS /* @min:%2etags */] && telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TAGS /* @min:%2etags */][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.ProcessLegacy]) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.arrForEach)(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TAGS /* @min:%2etags */][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.ProcessLegacy], function (callBack) {
                        try {
                            if (callBack && callBack(aiEnvelope) === false) {
                                doNotSendItem = true;
                                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._warnToConsole)(diagLogger, "Telemetry processor check returns false");
                            }
                        }
                        catch (e) {
                            // log error but dont stop executing rest of the telemetry initializers
                            // doNotSendItem = true;
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, "One of telemetry initializers failed, telemetry item will not be sent: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.dumpObj)(e) }, true);
                        }
                    });
                    delete telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TAGS /* @min:%2etags */][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.ProcessLegacy];
                }
                if (doNotSendItem) {
                    return; // do not send, no need to execute next plugin
                }
                return aiEnvelope;
            }
            function _serialize(item) {
                var rlt = EMPTY_STR;
                var diagLogger = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */]();
                try {
                    var valid = _validate(item, diagLogger);
                    var envelope = null;
                    if (valid) {
                        envelope = _getEnvelope(item, diagLogger);
                    }
                    if (envelope) {
                        rlt = _serializer.serialize(envelope);
                    }
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return rlt;
            }
            function _batch(arr) {
                var rlt = EMPTY_STR;
                if (arr && arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */]) {
                    rlt = "[" + arr.join(",") + "]";
                }
                return rlt;
            }
            function _createPayload(data) {
                var headers = _getHeaders();
                return {
                    urlString: _endpointUrl,
                    data: data,
                    headers: headers
                };
            }
            function _isSampledIn(envelope) {
                return _self._sample.isSampledIn(envelope);
            }
            function _getOnComplete(payload, status, headers, response) {
                // ***********************************************************************************************
                //TODO: handle other status codes
                if (status === 200 && payload) {
                    _self._onSuccess(payload, payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */]);
                }
                else {
                    response && _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_ERROR /* @min:%2e_onError */](payload, response);
                }
            }
            function _doSend(sendInterface, payload, isAsync, markAsSent) {
                if (markAsSent === void 0) { markAsSent = true; }
                var onComplete = function (status, headers, response) {
                    // let statsbeat = _getStatsBeat();
                    // if (statsbeat) {
                    //     statsbeat.count(status, payloadData, _endpointUrl);
                    // }
                    return _getOnComplete(payload, status, headers, response);
                };
                var payloadData = _getPayload(payload);
                // if (payloadData) {
                //     payloadData.statsBeatData = {startTime: dateNow()};
                // }
                var sendPostFunc = sendInterface && sendInterface.sendPOST;
                if (sendPostFunc && payloadData) {
                    // ***********************************************************************************************
                    // mark payload as sent at the beginning of calling each send function
                    if (markAsSent) {
                        _self._buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);
                    }
                    var result_2;
                    var callbackExecuted_1 = false;
                    var resolveFn_1;
                    var rejectFn_1;
                    _sendPostMgr.preparePayload(function (processedPayload) {
                        result_2 = sendPostFunc(processedPayload, onComplete, !isAsync);
                        callbackExecuted_1 = true;
                        if (resolveFn_1) {
                            (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_29__.doAwait)(result_2, resolveFn_1, rejectFn_1);
                        }
                    }, _zipPayload, payloadData, !isAsync);
                    if (callbackExecuted_1) {
                        return result_2;
                    }
                    // Callback was not executed synchronously, so we need to return a promise
                    return (0,_nevware21_ts_async__WEBPACK_IMPORTED_MODULE_29__.createPromise)(function (resolve, reject) {
                        resolveFn_1 = resolve;
                        rejectFn_1 = reject;
                    });
                }
                return null;
            }
            function _getPayload(payload) {
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isArray)(payload) && payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var batch = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */].batchPayloads(payload);
                    var headers = _getHeaders();
                    var payloadData = {
                        data: batch,
                        urlString: _endpointUrl,
                        headers: headers,
                        disableXhrSync: _disableXhr,
                        disableFetchKeepAlive: !_fetchKeepAlive,
                        oriPayload: payload
                    };
                    return payloadData;
                }
                return null;
            }
            function _getHeaders() {
                try {
                    var headers = _headers || {};
                    if ((0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.isInternalApplicationInsightsEndpoint)(_endpointUrl)) {
                        headers[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.RequestHeaders[6 /* eRequestHeaders.sdkContextHeader */]] = _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.RequestHeaders[7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */];
                    }
                    return headers;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return null;
            }
            function _checkMaxSize(incomingPayload) {
                var incomingSize = incomingPayload ? incomingPayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] : 0;
                if ((_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */].size() + incomingSize) > _maxBatchSizeInBytes) {
                    if (!_offlineListener || _offlineListener.isOnline()) { // only trigger send when currently online
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 10 /* SendRequestReason.MaxBatchSize */);
                    }
                    return true;
                }
                return false;
            }
            function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {
                var response = null;
                if (!_self._appId) {
                    response = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.parseResponse)(res);
                    if (response && response.appId) {
                        _self._appId = response.appId;
                    }
                }
                if ((status < 200 || status >= 300) && status !== 0) {
                    // Update End Point url if permanent redirect or moved permanently
                    // Updates the end point url before retry
                    if (status === 301 || status === 307 || status === 308) {
                        if (!_checkAndUpdateEndPointUrl(responseUrl)) {
                            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);
                            return;
                        }
                    }
                    if (_offlineListener && !_offlineListener.isOnline()) { // offline
                        // Note: Don't check for status == 0, since adblock gives this code
                        if (!_isRetryDisabled) {
                            var offlineBackOffMultiplier = 10; // arbritrary number
                            _resendPayload(payload, offlineBackOffMultiplier);
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". Offline - Response Code: ".concat(status, ". Offline status: ").concat(!_offlineListener.isOnline(), ". Will retry to send ").concat(payload.length, " items."));
                        }
                        return;
                    }
                    if (!_isRetryDisabled && _isRetriable(status)) {
                        _resendPayload(payload);
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " +
                            "Response code " + status + ". Will retry to send " + payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] + " items.");
                    }
                    else {
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);
                    }
                }
                else {
                    // check if the xhr's responseURL or fetch's response.url is same as endpoint url
                    // TODO after 10 redirects force send telemetry with 'redirect=false' as query parameter.
                    _checkAndUpdateEndPointUrl(responseUrl);
                    if (status === 206) {
                        if (!response) {
                            response = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_19__.parseResponse)(res);
                        }
                        if (response && !_isRetryDisabled) {
                            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, response);
                        }
                        else {
                            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);
                        }
                    }
                    else {
                        _consecutiveErrors = 0;
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, countOfItemsInPayload);
                    }
                }
            }
            function _checkAndUpdateEndPointUrl(responseUrl) {
                // Maximum stamp specific redirects allowed(uncomment this when breeze is ready with not allowing redirects feature)
                if (_stamp_specific_redirects >= 10) {
                    //  _self._senderConfig.endpointUrl = () => Sender._getDefaultAppInsightsChannelConfig().endpointUrl()+"/?redirect=false";
                    //  _stamp_specific_redirects = 0;
                    return false;
                }
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isNullOrUndefined)(responseUrl) && responseUrl !== "") {
                    if (responseUrl !== _endpointUrl) {
                        _endpointUrl = responseUrl;
                        ++_stamp_specific_redirects;
                        return true;
                    }
                }
                return false;
            }
            function _doUnloadSend(payload, isAsync) {
                if (_syncUnloadSender) {
                    // We are unloading so always call the sender with sync set to false
                    _syncUnloadSender(payload, false);
                }
                else {
                    // Fallback to the previous beacon Sender (which causes a CORB warning on chrome now)
                    var beaconInst = _sendPostMgr && _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_GET_SENDER_INST /* @min:%2egetSenderInst */]([3 /* TransportType.Beacon */], true);
                    return _doSend(beaconInst, payload, isAsync);
                }
            }
            function _onBeaconRetry(payload, onComplete, canSend) {
                var internalPayload = payload;
                var data = internalPayload && internalPayload.oriPayload;
                if (!_disableBeaconSplit) {
                    // Failed to send entire payload so try and split data and try to send as much events as possible
                    var droppedPayload = [];
                    for (var lp = 0; lp < data[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                        var thePayload = data[lp];
                        var arr = [thePayload];
                        var item = _getPayload(arr);
                        if (!canSend(item, onComplete)) {
                            // Can't send anymore, so split the batch and drop the rest
                            droppedPayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_PUSH /* @min:%2epush */](thePayload);
                        }
                        else {
                            _self._onSuccess(arr, arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */]);
                        }
                    }
                    if (droppedPayload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] > 0) {
                        _fallbackSend && _fallbackSend(droppedPayload, true);
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                    }
                }
                else {
                    _fallbackSend && _fallbackSend(data, true);
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + "Failed to send telemetry with Beacon API, retried with normal sender.");
                }
            }
            function _isStringArr(arr) {
                try {
                    if (arr && arr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */]) {
                        return ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isString)(arr[0]));
                    }
                }
                catch (e) {
                    //TODO: log, sender use IInternalStorageItem instead of string since 3.1.3
                }
                return null;
            }
            function _fetchKeepAliveSender(payload, isAsync) {
                var transport = null;
                if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isArray)(payload)) {
                    var payloadSize = payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */];
                    for (var lp = 0; lp < payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                        payloadSize += payload[lp].item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */];
                    }
                    var syncFetchPayload = _sendPostMgr.getSyncFetchPayload();
                    if ((syncFetchPayload + payloadSize) <= FetchSyncRequestSizeLimitBytes) {
                        transport = 2 /* TransportType.Fetch */;
                    }
                    else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_23__.isBeaconsSupported)()) {
                        // Fallback to beacon sender as we at least get told which events can't be scheduled
                        transport = 3 /* TransportType.Beacon */;
                    }
                    else {
                        // Payload is going to be too big so just try and send via XHR
                        transport = 1 /* TransportType.Xhr */;
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, ". " + "Failed to send telemetry with Beacon API, retried with xhrSender.");
                    }
                    var inst = _sendPostMgr && _sendPostMgr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_GET_SENDER_INST /* @min:%2egetSenderInst */]([transport], true);
                    return _doSend(inst, payload, isAsync);
                }
                return null;
            }
            /**
             * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).
             * @param payload
             */
            function _resendPayload(payload, linearFactor) {
                if (linearFactor === void 0) { linearFactor = 1; }
                if (!payload || payload[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] === 0) {
                    return;
                }
                var buffer = _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */];
                buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);
                _consecutiveErrors++;
                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
                    var item = payload_1[_i];
                    item.cnt = item.cnt || 0; // to make sure we have cnt for each payload
                    item.cnt++; // when resend, increase cnt
                    buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_ENQUEUE /* @min:%2eenqueue */](item);
                }
                // setup timer
                _setRetryTime(linearFactor);
                _setupTimer();
            }
            /**
             * Calculates the time to wait before retrying in case of an error based on
             * http://en.wikipedia.org/wiki/Exponential_backoff
             */
            function _setRetryTime(linearFactor) {
                var SlotDelayInSeconds = 10;
                var delayInSeconds;
                if (_consecutiveErrors <= 1) {
                    delayInSeconds = SlotDelayInSeconds;
                }
                else {
                    var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;
                    // tslint:disable-next-line:insecure-random
                    var backOffDelay = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.mathFloor)(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
                    backOffDelay = linearFactor * backOffDelay;
                    delayInSeconds = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.mathMax)((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.mathMin)(backOffDelay, 3600), SlotDelayInSeconds);
                }
                // TODO: Log the backoff time like the C# version does.
                var retryAfterTimeSpan = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.utcNow)() + (delayInSeconds * 1000);
                // TODO: Log the retry at time like the C# version does.
                _retryAt = retryAfterTimeSpan;
            }
            /**
             * Sets up the timer which triggers actually sending the data.
             */
            function _setupTimer() {
                if (!_timeoutHandle && !_paused) {
                    var retryInterval = _retryAt ? (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.mathMax)(0, _retryAt - (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.utcNow)()) : 0;
                    var timerValue = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.mathMax)(_maxBatchInterval, retryInterval);
                    _timeoutHandle = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.scheduleTimeout)(function () {
                        _timeoutHandle = null;
                        _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 1 /* SendRequestReason.NormalSchedule */);
                    }, timerValue);
                }
            }
            function _clearScheduledTimer() {
                _timeoutHandle && _timeoutHandle.cancel();
                _timeoutHandle = null;
                _retryAt = null;
            }
            /**
             * Checks if the SDK should resend the payload after receiving this status code from the backend.
             * @param statusCode
             */
            function _isRetriable(statusCode) {
                // retryCodes = [] means should not retry
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isNullOrUndefined)(_retryCodes)) {
                    return _retryCodes[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_LENGTH /* @min:%2elength */] && _retryCodes.indexOf(statusCode) > -1;
                }
                return statusCode === 401 // Unauthorized
                    // Removing as private links can return a 403 which causes excessive retries and session storage usage
                    // || statusCode === 403 // Forbidden
                    || statusCode === 408 // Timeout
                    || statusCode === 429 // Too many requests.
                    || statusCode === 500 // Internal server error.
                    || statusCode === 502 // Bad Gateway.
                    || statusCode === 503 // Service unavailable.
                    || statusCode === 504; // Gateway timeout.
            }
            // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6
            function _getNotifyMgr() {
                var func = "getNotifyMgr";
                var result;
                var core = _self.core;
                if (core) {
                    // During page unload the core may have been cleared and some async events may not have been sent yet
                    // resulting in the core being null. In this case we don't want to create a statsbeat instance
                    if (core[func]) {
                        result = core[func]();
                    }
                    else {
                        // using _self.core['_notificationManager'] for backward compatibility
                        result = core["_notificationManager"];
                    }
                }
                return result;
            }
            function _notifySendRequest(sendRequest, isAsync) {
                var manager = _getNotifyMgr();
                if (manager && manager.eventsSendRequest) {
                    try {
                        manager.eventsSendRequest(sendRequest, isAsync);
                    }
                    catch (e) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_24__._throwInternal)(_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, "send request notification failed: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.dumpObj)(e) });
                    }
                }
            }
            /**
             * Validate UUID Format
             * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo
             */
            function _validateInstrumentationKey(instrumentationKey, config) {
                var disableValidation = config.disableInstrumentationKeyValidation;
                var disableIKeyValidationFlag = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isNullOrUndefined)(disableValidation) ? false : disableValidation;
                if (disableIKeyValidationFlag) {
                    return true;
                }
                var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
                var regexp = new RegExp(UUID_Regex);
                return regexp.test(instrumentationKey);
            }
            function _initDefaults() {
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__SENDER /* @min:%2e_sender */] = null;
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_34__._DYN__BUFFER /* @min:%2e_buffer */] = null;
                _self._appId = null;
                _self._sample = null;
                _headers = {};
                _offlineListener = null;
                _consecutiveErrors = 0;
                _retryAt = null;
                _lastSend = null;
                _paused = false;
                _timeoutHandle = null;
                _serializer = null;
                _stamp_specific_redirects = 0;
                _syncFetchPayload = 0;
                _syncUnloadSender = null;
                _evtNamespace = null;
                _endpointUrl = null;
                _orgEndpointUrl = null;
                _maxBatchSizeInBytes = 0;
                _beaconSupported = false;
                _customHeaders = null;
                _disableTelemetry = false;
                _instrumentationKey = null;
                _convertUndefined = UNDEFINED_VALUE;
                _isRetryDisabled = false;
                _sessionStorageUsed = null;
                _namePrefix = UNDEFINED_VALUE;
                _disableXhr = false;
                _fetchKeepAlive = false;
                _disableBeaconSplit = false;
                _xhrSend = null;
                _fallbackSend = null;
                _sendPostMgr = null;
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.objDefine)(_self, "_senderConfig", {
                    g: function () {
                        return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_18__.objExtend)({}, defaultAppInsightsChannelConfig);
                    }
                });
            }
        });
        return _this;
    }
    Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {
        var envelope;
        if (iKey !== orig.iKey && !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_21__.isNullOrUndefined)(iKey)) {
            envelope = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__assignFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__assignFn)({}, orig), { iKey: iKey });
        }
        else {
            envelope = orig;
        }
        var creator = EnvelopeTypeCreator[envelope.baseType] || _EnvelopeCreator__WEBPACK_IMPORTED_MODULE_30__.EventEnvelopeCreator;
        return creator(logger, envelope, convertUndefined);
    };
// Removed Stub for Sender.prototype.pause.
// Removed Stub for Sender.prototype.resume.
// Removed Stub for Sender.prototype.flush.
// Removed Stub for Sender.prototype.onunloadFlush.
// Removed Stub for Sender.prototype.initialize.
// Removed Stub for Sender.prototype.processTelemetry.
// Removed Stub for Sender.prototype._xhrReadyStateChange.
// Removed Stub for Sender.prototype.triggerSend.
// Removed Stub for Sender.prototype._onError.
// Removed Stub for Sender.prototype._onPartialSuccess.
// Removed Stub for Sender.prototype._onSuccess.
// Removed Stub for Sender.prototype._xdrOnLoad.
// Removed Stub for Sender.prototype.addHeader.
// Removed Stub for Sender.prototype.isCompletelyIdle.
// Removed Stub for Sender.prototype.getOfflineSupport.
// Removed Stub for Sender.prototype.getOfflineListener.
    return Sender;
}(_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__.BaseTelemetryPlugin));

//# sourceMappingURL=Sender.js.map

/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DependencyEnvelopeCreator: () => (/* binding */ DependencyEnvelopeCreator),
/* harmony export */   EnvelopeCreator: () => (/* binding */ EnvelopeCreator),
/* harmony export */   EventEnvelopeCreator: () => (/* binding */ EventEnvelopeCreator),
/* harmony export */   ExceptionEnvelopeCreator: () => (/* binding */ ExceptionEnvelopeCreator),
/* harmony export */   MetricEnvelopeCreator: () => (/* binding */ MetricEnvelopeCreator),
/* harmony export */   PageViewEnvelopeCreator: () => (/* binding */ PageViewEnvelopeCreator),
/* harmony export */   PageViewPerformanceEnvelopeCreator: () => (/* binding */ PageViewPerformanceEnvelopeCreator),
/* harmony export */   TraceEnvelopeCreator: () => (/* binding */ TraceEnvelopeCreator)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(90);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(92);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(94);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(95);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(96);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(97);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(80);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(102);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(24);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(28);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(40);
/* harmony import */ var _InternalConstants__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(109);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(110);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





// these two constants are used to filter out properties not needed when trying to extract custom properties and measurements from the incoming payload
var strBaseType = "baseType";
var strBaseData = "baseData";
var strProperties = "properties";
var strTrue = "true";
function _setValueIf(target, field, value) {
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.setValue)(target, field, value, _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isTruthy);
}
/*
 * Maps Part A data from CS 4.0
 */
function _extractPartAExtensions(logger, item, env) {
    // todo: switch to keys from common in this method
    var envTags = env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TAGS /* @min:%2etags */] = env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TAGS /* @min:%2etags */] || {};
    var itmExt = item.ext = item.ext || {};
    var itmTags = item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TAGS /* @min:%2etags */] = item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TAGS /* @min:%2etags */] || [];
    var extUser = itmExt.user;
    if (extUser) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.userAuthUserId, extUser.authId);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.userId, extUser.id || extUser.localId);
    }
    var extApp = itmExt.app;
    if (extApp) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.sessionId, extApp.sesId);
    }
    var extDevice = itmExt.device;
    if (extDevice) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.deviceId, extDevice.id || extDevice.localId);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DEVICE_TYPE /* @min:%2edeviceType */], extDevice.deviceClass);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.deviceIp, extDevice.ip);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.deviceModel, extDevice.model);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DEVICE_TYPE /* @min:%2edeviceType */], extDevice[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DEVICE_TYPE /* @min:%2edeviceType */]);
    }
    var web = item.ext.web;
    if (web) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.deviceLanguage, web.browserLang);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.deviceBrowserVersion, web.browserVer);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.deviceBrowser, web.browser);
        var envData = env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */] = env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */] || {};
        var envBaseData = envData[strBaseData] = envData[strBaseData] || {};
        var envProps = envBaseData[strProperties] = envBaseData[strProperties] || {};
        _setValueIf(envProps, "domain", web.domain);
        _setValueIf(envProps, "isManual", web.isManual ? strTrue : null);
        _setValueIf(envProps, "screenRes", web.screenRes);
        _setValueIf(envProps, "userConsent", web.userConsent ? strTrue : null);
    }
    var extOs = itmExt.os;
    if (extOs) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.deviceOS, extOs[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */]);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.deviceOSVersion, extOs.osVer);
    }
    // No support for mapping Trace.traceState to 2.0 as it is currently empty
    var extTrace = itmExt.trace;
    if (extTrace) {
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.operationParentId, extTrace.parentID);
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.operationName, (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__.dataSanitizeString)(logger, extTrace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */]));
        _setValueIf(envTags, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.operationId, extTrace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TRACE_ID /* @min:%2etraceID */]);
    }
    // Sample 4.0 schema
    //  {
    //     "time" : "2018-09-05T22:51:22.4936Z",
    //     "name" : "MetricWithNamespace",
    //     "iKey" : "ABC-5a4cbd20-e601-4ef5-a3c6-5d6577e4398e",
    //     "ext": {  "cloud": {
    //          "role": "WATSON3",
    //          "roleInstance": "CO4AEAP00000260"
    //      },
    //      "device": {}, "correlation": {} },
    //      "tags": [
    //        { "amazon.region" : "east2" },
    //        { "os.expid" : "wp:02df239" }
    //     ]
    //   }
    var tgs = {};
    // deals with tags.push({object})
    for (var i = itmTags[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_LENGTH /* @min:%2elength */] - 1; i >= 0; i--) {
        var tg = itmTags[i];
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.objForEachKey)(tg, function (key, value) {
            tgs[key] = value;
        });
        itmTags.splice(i, 1);
    }
    // deals with tags[key]=value (and handles hasOwnProperty)
    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.objForEachKey)(itmTags, function (tg, value) {
        tgs[tg] = value;
    });
    var theTags = (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__assignFn)((0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__assignFn)({}, envTags), tgs);
    if (!theTags[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.internalSdkVersion]) {
        // Append a version in case it is not already set
        theTags[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_12__.CtxTagKeys.internalSdkVersion] = (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_11__.dataSanitizeString)(logger, "javascript:".concat(EnvelopeCreator.Version), 64);
    }
    env[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TAGS /* @min:%2etags */] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.optimizeObject)(theTags);
}
function _extractPropsAndMeasurements(data, properties, measurements) {
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(data)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.objForEachKey)(data, function (key, value) {
            if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNumber)(value)) {
                measurements[key] = value;
            }
            else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isString)(value)) {
                properties[key] = value;
            }
            else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.hasJSON)()) {
                properties[key] = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_15__.getJSON)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_STRINGIFY /* @min:%2estringify */](value);
            }
        });
    }
}
function _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue) {
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(properties)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.objForEachKey)(properties, function (key, value) {
            properties[key] = value || customUndefinedValue;
        });
    }
}
// TODO: Do we want this to take logger as arg or use this._logger as nonstatic?
function _createEnvelope(logger, envelopeType, telemetryItem, data) {
    var envelope = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.Envelope(logger, data, envelopeType);
    _setValueIf(envelope, "sampleRate", telemetryItem[_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_1__.SampleRate]);
    if ((telemetryItem[strBaseData] || {}).startTime) {
        // Starting from Version 3.0.3, the time property will be assigned by the startTime value,
        // which records the loadEvent time for the pageView event.
        envelope.time = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.toISOString)(telemetryItem[strBaseData].startTime);
    }
    envelope.iKey = telemetryItem.iKey;
    var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
    envelope[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */] = envelope[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */].replace("{0}", iKeyNoDashes);
    // extract all extensions from ctx
    _extractPartAExtensions(logger, telemetryItem, envelope);
    // loop through the envelope tags (extension of Part A) and pick out the ones that should go in outgoing envelope tags
    telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TAGS /* @min:%2etags */] = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TAGS /* @min:%2etags */] || [];
    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_13__.optimizeObject)(envelope);
}
function EnvelopeCreatorInit(logger, telemetryItem) {
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(telemetryItem[strBaseData])) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 46 /* _eInternalMessageId.TelemetryEnvelopeInvalid */, "telemetryItem.baseData cannot be null.");
    }
}
var EnvelopeCreator = {
    Version: '3.3.11'
};
function DependencyEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var customMeasurements = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    var customProperties = telemetryItem[strBaseData][strProperties] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */], customProperties, customMeasurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    }
    var bd = telemetryItem[strBaseData];
    if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(bd)) {
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_16__._warnToConsole)(logger, "Invalid input for dependency data");
        return null;
    }
    var method = bd[strProperties] && bd[strProperties][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_1__.HttpMethod] ? bd[strProperties][_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_1__.HttpMethod] : "GET";
    var remoteDepData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__.RemoteDependencyData(logger, bd.id, bd.target, bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */], bd[_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_DURATION /* @min:%2eduration */], bd.success, bd.responseCode, method, bd.type, bd.correlationContext, customProperties, customMeasurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__.RemoteDependencyData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */], remoteDepData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_7__.RemoteDependencyData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function EventEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var customProperties = {};
    var customMeasurements = {};
    if (telemetryItem[strBaseType] !== _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.Event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */]) {
        customProperties["baseTypeSource"] = telemetryItem[strBaseType]; // save the passed in base type as a property
    }
    if (telemetryItem[strBaseType] === _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.Event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */]) { // take collection
        customProperties = telemetryItem[strBaseData][strProperties] || {};
        customMeasurements = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    }
    else { // if its not a known type, convert to custom event
        if (telemetryItem[strBaseData]) {
            _extractPropsAndMeasurements(telemetryItem[strBaseData], customProperties, customMeasurements);
        }
    }
    // Extract root level properties from part C telemetryItem.data
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */], customProperties, customMeasurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    }
    var eventName = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */];
    var eventData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.Event(logger, eventName, customProperties, customMeasurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.Event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */], eventData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_3__.Event[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function ExceptionEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    // Extract root level properties from part C telemetryItem.data
    var customMeasurements = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    var customProperties = telemetryItem[strBaseData][strProperties] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */], customProperties, customMeasurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
    }
    var bd = telemetryItem[strBaseData];
    var exData = _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.Exception.CreateFromInterface(logger, bd, customProperties, customMeasurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.Exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */], exData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_4__.Exception[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function MetricEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var baseData = telemetryItem[strBaseData];
    var props = baseData[strProperties] || {};
    var measurements = baseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */], props, measurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
    }
    var baseMetricData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__.Metric(logger, baseData[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */], baseData.average, baseData.sampleCount, baseData.min, baseData.max, baseData.stdDev, props, measurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__.Metric[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */], baseMetricData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_5__.Metric[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function PageViewEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    // Since duration is not part of the domain properties in Common Schema, extract it from part C
    var duration;
    var baseData = telemetryItem[strBaseData];
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(baseData) &&
        !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(baseData[strProperties]) &&
        !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(baseData[strProperties][_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_DURATION])) { // from part B properties
        duration = baseData[strProperties][_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_DURATION];
        delete baseData[strProperties][_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_DURATION];
    }
    else if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */]) &&
        !(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */][_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_DURATION])) { // from custom properties
        duration = telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */][_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_DURATION];
        delete telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */][_InternalConstants__WEBPACK_IMPORTED_MODULE_17__.STR_DURATION];
    }
    var bd = telemetryItem[strBaseData];
    // special case: pageview.id is grabbed from current operation id. Analytics plugin is decoupled from properties plugin, so this is done here instead. This can be made a default telemetry intializer instead if needed to be decoupled from channel
    var currentContextId;
    if (((telemetryItem.ext || {}).trace || {})[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TRACE_ID /* @min:%2etraceID */]) {
        currentContextId = telemetryItem.ext.trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TRACE_ID /* @min:%2etraceID */];
    }
    var id = bd.id || currentContextId;
    var name = bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */];
    var url = bd.uri;
    var properties = bd[strProperties] || {};
    var measurements = bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    // refUri is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(bd.refUri)) {
        properties["refUri"] = bd.refUri;
    }
    // pageType is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(bd.pageType)) {
        properties["pageType"] = bd.pageType;
    }
    // isLoggedIn is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(bd.isLoggedIn)) {
        properties["isLoggedIn"] = bd.isLoggedIn[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_TO_STRING /* @min:%2etoString */]();
    }
    // pageTags is a field that Breeze still does not recognize as part of Part B. For now, put it in Part C until it supports it as a domain property
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(bd[strProperties])) {
        var pageTags = bd[strProperties];
        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.objForEachKey)(pageTags, function (key, value) {
            properties[key] = value;
        });
    }
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */], properties, measurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
    }
    var pageViewData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_6__.PageView(logger, name, url, duration, properties, measurements, id);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_6__.PageView[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */], pageViewData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_6__.PageView[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function PageViewPerformanceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var bd = telemetryItem[strBaseData];
    var name = bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_NAME /* @min:%2ename */];
    var url = bd.uri || bd.url;
    var properties = bd[strProperties] || {};
    var measurements = bd[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */], properties, measurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
    }
    var baseData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__.PageViewPerformance(logger, name, url, undefined, properties, measurements, bd);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__.PageViewPerformance[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */], baseData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_9__.PageViewPerformance[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
function TraceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
    EnvelopeCreatorInit(logger, telemetryItem);
    var message = telemetryItem[strBaseData].message;
    var severityLevel = telemetryItem[strBaseData].severityLevel;
    var props = telemetryItem[strBaseData][strProperties] || {};
    var measurements = telemetryItem[strBaseData][_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_MEASUREMENTS /* @min:%2emeasurements */] || {};
    _extractPropsAndMeasurements(telemetryItem[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA /* @min:%2edata */], props, measurements);
    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_14__.isNullOrUndefined)(customUndefinedValue)) {
        _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
    }
    var baseData = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.Trace(logger, message, severityLevel, props, measurements);
    var data = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_10__.Data(_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.Trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_DATA_TYPE /* @min:%2edataType */], baseData);
    return _createEnvelope(logger, _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_8__.Trace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_18__._DYN_ENVELOPE_TYPE /* @min:%2eenvelopeType */], telemetryItem, data);
}
//# sourceMappingURL=EnvelopeCreator.js.map

/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   STR_DURATION: () => (/* binding */ STR_DURATION)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// ###################################################################################################################################################
// Note: DON'T Export these const from the package as we are still targeting IE/ES5 this will export a mutable variables that someone could change ###
// ###################################################################################################################################################
// Generally you should only put values that are used more than 2 times and then only if not already exposed as a constant (such as SdkCoreNames)
// as when using "short" named values from here they will be will be minified smaller than the SdkCoreNames[eSdkCoreNames.xxxx] value.
var STR_DURATION = "duration";
//# sourceMappingURL=InternalConstants.js.map

/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _DYN_ALWAYS_USE_XHR_OVERR4: () => (/* binding */ _DYN_ALWAYS_USE_XHR_OVERR4),
/* harmony export */   _DYN_BASE_TYPE: () => (/* binding */ _DYN_BASE_TYPE),
/* harmony export */   _DYN_BUFFER_OVERRIDE: () => (/* binding */ _DYN_BUFFER_OVERRIDE),
/* harmony export */   _DYN_CLEAR: () => (/* binding */ _DYN_CLEAR),
/* harmony export */   _DYN_CLEAR_SENT: () => (/* binding */ _DYN_CLEAR_SENT),
/* harmony export */   _DYN_CONCAT: () => (/* binding */ _DYN_CONCAT),
/* harmony export */   _DYN_COUNT: () => (/* binding */ _DYN_COUNT),
/* harmony export */   _DYN_CUSTOM_HEADERS: () => (/* binding */ _DYN_CUSTOM_HEADERS),
/* harmony export */   _DYN_DATA: () => (/* binding */ _DYN_DATA),
/* harmony export */   _DYN_DATA_TYPE: () => (/* binding */ _DYN_DATA_TYPE),
/* harmony export */   _DYN_DEVICE_TYPE: () => (/* binding */ _DYN_DEVICE_TYPE),
/* harmony export */   _DYN_DIAG_LOG: () => (/* binding */ _DYN_DIAG_LOG),
/* harmony export */   _DYN_DISABLE_SEND_BEACON_7: () => (/* binding */ _DYN_DISABLE_SEND_BEACON_7),
/* harmony export */   _DYN_EMIT_LINE_DELIMITED_0: () => (/* binding */ _DYN_EMIT_LINE_DELIMITED_0),
/* harmony export */   _DYN_ENABLE_SESSION_STORA5: () => (/* binding */ _DYN_ENABLE_SESSION_STORA5),
/* harmony export */   _DYN_ENDPOINT_URL: () => (/* binding */ _DYN_ENDPOINT_URL),
/* harmony export */   _DYN_ENQUEUE: () => (/* binding */ _DYN_ENQUEUE),
/* harmony export */   _DYN_ENVELOPE_TYPE: () => (/* binding */ _DYN_ENVELOPE_TYPE),
/* harmony export */   _DYN_GET_HASH_CODE_SCORE: () => (/* binding */ _DYN_GET_HASH_CODE_SCORE),
/* harmony export */   _DYN_GET_SENDER_INST: () => (/* binding */ _DYN_GET_SENDER_INST),
/* harmony export */   _DYN_INITIALIZE: () => (/* binding */ _DYN_INITIALIZE),
/* harmony export */   _DYN_INSTRUMENTATION_KEY: () => (/* binding */ _DYN_INSTRUMENTATION_KEY),
/* harmony export */   _DYN_IS_BEACON_API_DISABL3: () => (/* binding */ _DYN_IS_BEACON_API_DISABL3),
/* harmony export */   _DYN_ITEMS_ACCEPTED: () => (/* binding */ _DYN_ITEMS_ACCEPTED),
/* harmony export */   _DYN_ITEMS_RECEIVED: () => (/* binding */ _DYN_ITEMS_RECEIVED),
/* harmony export */   _DYN_LENGTH: () => (/* binding */ _DYN_LENGTH),
/* harmony export */   _DYN_MARK_AS_SENT: () => (/* binding */ _DYN_MARK_AS_SENT),
/* harmony export */   _DYN_MAX_BATCH_SIZE_IN_BY1: () => (/* binding */ _DYN_MAX_BATCH_SIZE_IN_BY1),
/* harmony export */   _DYN_MEASUREMENTS: () => (/* binding */ _DYN_MEASUREMENTS),
/* harmony export */   _DYN_NAME: () => (/* binding */ _DYN_NAME),
/* harmony export */   _DYN_ONUNLOAD_DISABLE_BEA2: () => (/* binding */ _DYN_ONUNLOAD_DISABLE_BEA2),
/* harmony export */   _DYN_ONUNLOAD_DISABLE_FET6: () => (/* binding */ _DYN_ONUNLOAD_DISABLE_FET6),
/* harmony export */   _DYN_PUSH: () => (/* binding */ _DYN_PUSH),
/* harmony export */   _DYN_SAMPLE_RATE: () => (/* binding */ _DYN_SAMPLE_RATE),
/* harmony export */   _DYN_STRINGIFY: () => (/* binding */ _DYN_STRINGIFY),
/* harmony export */   _DYN_TAGS: () => (/* binding */ _DYN_TAGS),
/* harmony export */   _DYN_TO_STRING: () => (/* binding */ _DYN_TO_STRING),
/* harmony export */   _DYN_TRACE_ID: () => (/* binding */ _DYN_TRACE_ID),
/* harmony export */   _DYN_TRIGGER_SEND: () => (/* binding */ _DYN_TRIGGER_SEND),
/* harmony export */   _DYN__BUFFER: () => (/* binding */ _DYN__BUFFER),
/* harmony export */   _DYN__BUFFER__KEY: () => (/* binding */ _DYN__BUFFER__KEY),
/* harmony export */   _DYN__MAX__BUFFER__SIZE: () => (/* binding */ _DYN__MAX__BUFFER__SIZE),
/* harmony export */   _DYN__ON_ERROR: () => (/* binding */ _DYN__ON_ERROR),
/* harmony export */   _DYN__ON_PARTIAL_SUCCESS: () => (/* binding */ _DYN__ON_PARTIAL_SUCCESS),
/* harmony export */   _DYN__ON_SUCCESS: () => (/* binding */ _DYN__ON_SUCCESS),
/* harmony export */   _DYN__SENDER: () => (/* binding */ _DYN__SENDER),
/* harmony export */   _DYN__SENT__BUFFER__KEY: () => (/* binding */ _DYN__SENT__BUFFER__KEY)
/* harmony export */ });
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES5 which can result in a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_TAGS = "tags"; // Count: 17
var _DYN_DEVICE_TYPE = "deviceType"; // Count: 3
var _DYN_DATA = "data"; // Count: 13
var _DYN_NAME = "name"; // Count: 8
var _DYN_TRACE_ID = "traceID"; // Count: 5
var _DYN_LENGTH = "length"; // Count: 38
var _DYN_STRINGIFY = "stringify"; // Count: 5
var _DYN_MEASUREMENTS = "measurements"; // Count: 7
var _DYN_DATA_TYPE = "dataType"; // Count: 10
var _DYN_ENVELOPE_TYPE = "envelopeType"; // Count: 7
var _DYN_TO_STRING = "toString"; // Count: 7
var _DYN_ENQUEUE = "enqueue"; // Count: 7
var _DYN_COUNT = "count"; // Count: 7
var _DYN_PUSH = "push"; // Count: 9
var _DYN_EMIT_LINE_DELIMITED_0 = "emitLineDelimitedJson"; // Count: 3
var _DYN_CLEAR = "clear"; // Count: 6
var _DYN_MARK_AS_SENT = "markAsSent"; // Count: 4
var _DYN_CLEAR_SENT = "clearSent"; // Count: 5
var _DYN_BUFFER_OVERRIDE = "bufferOverride"; // Count: 3
var _DYN__BUFFER__KEY = "BUFFER_KEY"; // Count: 5
var _DYN__SENT__BUFFER__KEY = "SENT_BUFFER_KEY"; // Count: 8
var _DYN_CONCAT = "concat"; // Count: 6
var _DYN__MAX__BUFFER__SIZE = "MAX_BUFFER_SIZE"; // Count: 5
var _DYN_TRIGGER_SEND = "triggerSend"; // Count: 5
var _DYN_DIAG_LOG = "diagLog"; // Count: 16
var _DYN_INITIALIZE = "initialize"; // Count: 3
var _DYN__SENDER = "_sender"; // Count: 5
var _DYN_ENDPOINT_URL = "endpointUrl"; // Count: 5
var _DYN_INSTRUMENTATION_KEY = "instrumentationKey"; // Count: 5
var _DYN_CUSTOM_HEADERS = "customHeaders"; // Count: 3
var _DYN_MAX_BATCH_SIZE_IN_BY1 = "maxBatchSizeInBytes"; // Count: 2
var _DYN_ONUNLOAD_DISABLE_BEA2 = "onunloadDisableBeacon"; // Count: 3
var _DYN_IS_BEACON_API_DISABL3 = "isBeaconApiDisabled"; // Count: 3
var _DYN_ALWAYS_USE_XHR_OVERR4 = "alwaysUseXhrOverride"; // Count: 2
var _DYN_ENABLE_SESSION_STORA5 = "enableSessionStorageBuffer"; // Count: 2
var _DYN__BUFFER = "_buffer"; // Count: 9
var _DYN_ONUNLOAD_DISABLE_FET6 = "onunloadDisableFetch"; // Count: 2
var _DYN_DISABLE_SEND_BEACON_7 = "disableSendBeaconSplit"; // Count: 2
var _DYN_GET_SENDER_INST = "getSenderInst"; // Count: 4
var _DYN__ON_ERROR = "_onError"; // Count: 7
var _DYN__ON_PARTIAL_SUCCESS = "_onPartialSuccess"; // Count: 3
var _DYN__ON_SUCCESS = "_onSuccess"; // Count: 6
var _DYN_ITEMS_RECEIVED = "itemsReceived"; // Count: 3
var _DYN_ITEMS_ACCEPTED = "itemsAccepted"; // Count: 3
var _DYN_BASE_TYPE = "baseType"; // Count: 4
var _DYN_SAMPLE_RATE = "sampleRate"; // Count: 4
var _DYN_GET_HASH_CODE_SCORE = "getHashCodeScore"; // Count: 4
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArraySendBuffer: () => (/* binding */ ArraySendBuffer),
/* harmony export */   SessionStorageSendBuffer: () => (/* binding */ SessionStorageSendBuffer)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(110);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var BaseSendBuffer = /** @class */ (function () {
    function BaseSendBuffer(logger, config) {
        var _buffer = [];
        var _bufferFullMessageSent = false;
        var _maxRetryCnt = config.maxRetryCnt;
        this._get = function () {
            return _buffer;
        };
        this._set = function (buffer) {
            _buffer = buffer;
            return _buffer;
        };
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(BaseSendBuffer, this, function (_self) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_ENQUEUE /* @min:%2eenqueue */] = function (payload) {
                if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_COUNT /* @min:%2ecount */]() >= config.eventsLimitInMem) {
                    // sent internal log only once per page view
                    if (!_bufferFullMessageSent) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 105 /* _eInternalMessageId.InMemoryStorageBufferFull */, "Maximum in-memory buffer size reached: " + _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_COUNT /* @min:%2ecount */](), true);
                        _bufferFullMessageSent = true;
                    }
                    return;
                }
                payload.cnt = payload.cnt || 0;
                // max retry is defined, and max retry is reached, do not add the payload to buffer
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(_maxRetryCnt)) {
                    if (payload.cnt > _maxRetryCnt) {
                        // TODO: add log here on dropping payloads
                        // will log statsbeat exception later here
                        return;
                    }
                }
                _buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_PUSH /* @min:%2epush */](payload);
                return;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_COUNT /* @min:%2ecount */] = function () {
                return _buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */];
            };
            _self.size = function () {
                var size = _buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */];
                for (var lp = 0; lp < _buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */]; lp++) {
                    size += (_buffer[lp].item)[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */];
                }
                if (!config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_EMIT_LINE_DELIMITED_0 /* @min:%2eemitLineDelimitedJson */]) {
                    size += 2;
                }
                return size;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CLEAR /* @min:%2eclear */] = function () {
                _buffer = [];
                _bufferFullMessageSent = false;
            };
            _self.getItems = function () {
                return _buffer.slice(0);
            };
            _self.batchPayloads = function (payloads) {
                if (payloads && payloads[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */] > 0) {
                    var payloadStr_1 = [];
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.arrForEach)(payloads, function (payload) {
                        payloadStr_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_PUSH /* @min:%2epush */](payload.item);
                    });
                    var batch = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_EMIT_LINE_DELIMITED_0 /* @min:%2eemitLineDelimitedJson */] ?
                        payloadStr_1.join("\n") :
                        "[" + payloadStr_1.join(",") + "]";
                    return batch;
                }
                return null;
            };
            _self.createNew = function (newLogger, newConfig, canUseSessionStorage) {
                var items = _buffer.slice(0);
                newLogger = newLogger || logger;
                newConfig = newConfig || {};
                var newBuffer = !!canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.arrForEach)(items, function (payload) {
                    newBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_ENQUEUE /* @min:%2eenqueue */](payload);
                });
                return newBuffer;
            };
        });
    }
// Removed Stub for BaseSendBuffer.prototype.enqueue.
// Removed Stub for BaseSendBuffer.prototype.count.
// Removed Stub for BaseSendBuffer.prototype.size.
// Removed Stub for BaseSendBuffer.prototype.clear.
// Removed Stub for BaseSendBuffer.prototype.getItems.
// Removed Stub for BaseSendBuffer.prototype.batchPayloads.
// Removed Stub for BaseSendBuffer.prototype.createNew.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    BaseSendBuffer.__ieDyn=1;

    return BaseSendBuffer;
}());
/*
 * An array based send buffer.
 */
var ArraySendBuffer = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__extendsFn)(ArraySendBuffer, _super);
    function ArraySendBuffer(logger, config) {
        var _this = _super.call(this, logger, config) || this;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(ArraySendBuffer, _this, function (_self, _base) {
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_MARK_AS_SENT /* @min:%2emarkAsSent */] = function (payload) {
                _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CLEAR /* @min:%2eclear */]();
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CLEAR_SENT /* @min:%2eclearSent */] = function (payload) {
                // not supported
            };
        });
        return _this;
    }
// Removed Stub for ArraySendBuffer.prototype.markAsSent.
// Removed Stub for ArraySendBuffer.prototype.clearSent.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    ArraySendBuffer.__ieDyn=1;

    return ArraySendBuffer;
}(BaseSendBuffer));

var PREVIOUS_KEYS = ["AI_buffer", "AI_sentBuffer"];
/*
 * Session storage buffer holds a copy of all unsent items in the browser session storage.
 */
var SessionStorageSendBuffer = /** @class */ (function (_super) {
    (0,_microsoft_applicationinsights_shims__WEBPACK_IMPORTED_MODULE_0__.__extendsFn)(SessionStorageSendBuffer, _super);
    function SessionStorageSendBuffer(logger, config) {
        var _this = _super.call(this, logger, config) || this;
        var _bufferFullMessageSent = false;
        //Note: should not use config.namePrefix directly, because it will always refers to the latest namePrefix
        var _namePrefix = config === null || config === void 0 ? void 0 : config.namePrefix;
        // TODO: add remove buffer override as well
        var _b = config[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */] || { getItem: _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.utlGetSessionStorage, setItem: _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.utlSetSessionStorage }, getItem = _b.getItem, setItem = _b.setItem;
        var _maxRetryCnt = config.maxRetryCnt;
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_1__["default"])(SessionStorageSendBuffer, _this, function (_self, _base) {
            var bufferItems = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */]);
            var itemsInSentBuffer = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);
            var previousItems = _getPreviousEvents();
            var notDeliveredItems = itemsInSentBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CONCAT /* @min:%2econcat */](previousItems);
            var buffer = _self._set(bufferItems[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CONCAT /* @min:%2econcat */](notDeliveredItems));
            // If the buffer has too many items, drop items from the end.
            if (buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */] > SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {
                buffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */] = SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */];
            }
            _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], []);
            _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], buffer);
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_ENQUEUE /* @min:%2eenqueue */] = function (payload) {
                if (_self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_COUNT /* @min:%2ecount */]() >= SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {
                    // sent internal log only once per page view
                    if (!_bufferFullMessageSent) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 67 /* _eInternalMessageId.SessionStorageBufferFull */, "Maximum buffer size reached: " + _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_COUNT /* @min:%2ecount */](), true);
                        _bufferFullMessageSent = true;
                    }
                    return;
                }
                payload.cnt = payload.cnt || 0;
                // max retry is defined, and max retry is reached, do not add the payload to buffer
                if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isNullOrUndefined)(_maxRetryCnt)) {
                    if (payload.cnt > _maxRetryCnt) {
                        // TODO: add log here on dropping payloads
                        return;
                    }
                }
                _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_ENQUEUE /* @min:%2eenqueue */](payload);
                _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], _self._get());
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CLEAR /* @min:%2eclear */] = function () {
                _base[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CLEAR /* @min:%2eclear */]();
                _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], _self._get());
                _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], []);
                _bufferFullMessageSent = false;
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_MARK_AS_SENT /* @min:%2emarkAsSent */] = function (payload) {
                _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], _self._set(_removePayloadsFromBuffer(payload, _self._get())));
                var sentElements = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);
                if (sentElements instanceof Array && payload instanceof Array) {
                    sentElements = sentElements[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CONCAT /* @min:%2econcat */](payload);
                    if (sentElements[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */] > SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {
                        // We send telemetry normally. If the SENT_BUFFER is too big we don't add new elements
                        // until we receive a response from the backend and the buffer has free space again (see clearSent method)
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 67 /* _eInternalMessageId.SessionStorageBufferFull */, "Sent buffer reached its maximum size: " + sentElements[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */], true);
                        sentElements[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_LENGTH /* @min:%2elength */] = SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */];
                    }
                    _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], sentElements);
                }
            };
            _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CLEAR_SENT /* @min:%2eclearSent */] = function (payload) {
                var sentElements = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);
                sentElements = _removePayloadsFromBuffer(payload, sentElements);
                _setBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], sentElements);
            };
            _self.createNew = function (newLogger, newConfig, canUseSessionStorage) {
                canUseSessionStorage = !!canUseSessionStorage;
                var unsentItems = _self._get().slice(0);
                var sentItems = _getBuffer(SessionStorageSendBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]).slice(0);
                newLogger = newLogger || logger;
                newConfig = newConfig || {};
                // to make sure that we do not send duplicated payloads when it is switched back to previous one
                _self[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CLEAR /* @min:%2eclear */]();
                var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.arrForEach)(unsentItems, function (payload) {
                    newBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_ENQUEUE /* @min:%2eenqueue */](payload);
                });
                if (canUseSessionStorage) {
                    // arr buffer will clear all payloads if markAsSent() is called
                    newBuffer[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](sentItems);
                }
                return newBuffer;
            };
            function _removePayloadsFromBuffer(payloads, buffer) {
                var remaining = [];
                var payloadStr = [];
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.arrForEach)(payloads, function (payload) {
                    payloadStr[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_PUSH /* @min:%2epush */](payload.item);
                });
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.arrForEach)(buffer, function (value) {
                    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isFunction)(value) && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.arrIndexOf)(payloadStr, value.item) === -1) {
                        remaining[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_PUSH /* @min:%2epush */](value);
                    }
                });
                return remaining;
            }
            function _getBuffer(key) {
                var prefixedKey = key;
                prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                return _getBufferBase(prefixedKey);
            }
            function _getBufferBase(key) {
                try {
                    var bufferJson = getItem(logger, key);
                    if (bufferJson) {
                        var buffer_1 = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.getJSON)().parse(bufferJson);
                        if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isString)(buffer_1)) {
                            // When using some version prototype.js the stringify / parse cycle does not decode array's correctly
                            buffer_1 = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_5__.getJSON)().parse(buffer_1);
                        }
                        if (buffer_1 && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.isArray)(buffer_1)) {
                            return buffer_1;
                        }
                    }
                }
                catch (e) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 42 /* _eInternalMessageId.FailedToRestoreStorageBuffer */, " storage key: " + key + ", " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.getExceptionName)(e), { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.dumpObj)(e) });
                }
                return [];
            }
            function _setBuffer(key, buffer) {
                var prefixedKey = key;
                try {
                    prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                    var bufferJson = JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_STRINGIFY /* @min:%2estringify */](buffer);
                    setItem(logger, prefixedKey, bufferJson);
                }
                catch (e) {
                    // if there was an error, clear the buffer
                    // telemetry is stored in the _buffer array so we won't loose any items
                    setItem(logger, prefixedKey, JSON[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_STRINGIFY /* @min:%2estringify */]([]));
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 41 /* _eInternalMessageId.FailedToSetStorageBuffer */, " storage key: " + prefixedKey + ", " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.getExceptionName)(e) + ". Buffer cleared", { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.dumpObj)(e) });
                }
            }
            // this removes buffer with prefix+key
            function _getPreviousEvents() {
                var items = [];
                try {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.arrForEach)(PREVIOUS_KEYS, function (key) {
                        var events = _getItemsFromPreviousKey(key);
                        items = items[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CONCAT /* @min:%2econcat */](events);
                        // to make sure that we also transfer items from old prefixed + key buffer
                        if (_namePrefix) {
                            var prefixedKey = _namePrefix + "_" + key;
                            var prefixEvents = _getItemsFromPreviousKey(prefixedKey);
                            items = items[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_CONCAT /* @min:%2econcat */](prefixEvents);
                        }
                    });
                    return items;
                }
                catch (e) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_6__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 41 /* _eInternalMessageId.FailedToSetStorageBuffer */, "Transfer events from previous buffers: " + (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__.getExceptionName)(e) + ". previous Buffer items can not be removed", { exception: (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.dumpObj)(e) });
                }
                return [];
            }
            // transform string[] to IInternalStorageItem[]
            function _getItemsFromPreviousKey(key) {
                try {
                    var items = _getBufferBase(key);
                    var transFormedItems_1 = [];
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_4__.arrForEach)(items, function (item) {
                        var internalItem = {
                            item: item,
                            cnt: 0 // previous events will be default to 0 count
                        };
                        transFormedItems_1[_DynamicConstants__WEBPACK_IMPORTED_MODULE_7__._DYN_PUSH /* @min:%2epush */](internalItem);
                    });
                    // remove the session storage if we can add events back
                    (0,_microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_2__.utlRemoveSessionStorage)(logger, key);
                    return transFormedItems_1;
                }
                catch (e) {
                    // eslint-disable-next-line no-empty
                }
                return [];
            }
        });
        return _this;
    }
// Removed Stub for SessionStorageSendBuffer.prototype.enqueue.
// Removed Stub for SessionStorageSendBuffer.prototype.clear.
// Removed Stub for SessionStorageSendBuffer.prototype.markAsSent.
// Removed Stub for SessionStorageSendBuffer.prototype.clearSent.
// Removed Stub for SessionStorageSendBuffer.prototype.createNew.
    var _a;
    _a = SessionStorageSendBuffer;
    SessionStorageSendBuffer.VERSION = "_1";
    SessionStorageSendBuffer.BUFFER_KEY = "AI_buffer" + _a.VERSION;
    SessionStorageSendBuffer.SENT_BUFFER_KEY = "AI_sentBuffer" + _a.VERSION;
    // Maximum number of payloads stored in the buffer. If the buffer is full, new elements will be dropped.
    SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2000;
    return SessionStorageSendBuffer;
}(BaseSendBuffer));

//# sourceMappingURL=SendBuffer.js.map

/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Serializer: () => (/* binding */ Serializer)
/* harmony export */ });
/* harmony import */ var _microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(110);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



var Serializer = /** @class */ (function () {
    function Serializer(logger) {
        (0,_microsoft_dynamicproto_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Serializer, this, function (_self) {
            /**
             * Serializes the current object to a JSON string.
             */
            _self.serialize = function (input) {
                var output = _serializeObject(input, "root");
                try {
                    return (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.getJSON)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_STRINGIFY /* @min:%2estringify */](output);
                }
                catch (e) {
                    // if serialization fails return an empty string
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.CannotSerializeObject */, (e && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TO_STRING /* @min:%2etoString */])) ? e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TO_STRING /* @min:%2etoString */]() : "Error serializing object", null, true);
                }
            };
            function _serializeObject(source, name) {
                var circularReferenceCheck = "__aiCircularRefCheck";
                var output = {};
                if (!source) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.CannotSerializeObject */, "cannot serialize object because it is null or undefined", { name: name }, true);
                    return output;
                }
                if (source[circularReferenceCheck]) {
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 50 /* _eInternalMessageId.CircularReferenceDetected */, "Circular reference detected while serializing object", { name: name }, true);
                    return output;
                }
                if (!source.aiDataContract) {
                    // special case for measurements/properties/tags
                    if (name === "measurements") {
                        output = _serializeStringMap(source, "number", name);
                    }
                    else if (name === "properties") {
                        output = _serializeStringMap(source, "string", name);
                    }
                    else if (name === "tags") {
                        output = _serializeStringMap(source, "string", name);
                    }
                    else if ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
                        output = _serializeArray(source, name);
                    }
                    else {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 2 /* eLoggingSeverity.WARNING */, 49 /* _eInternalMessageId.CannotSerializeObjectNonSerializable */, "Attempting to serialize an object which does not implement ISerializable", { name: name }, true);
                        try {
                            // verify that the object can be stringified
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_2__.getJSON)()[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_STRINGIFY /* @min:%2estringify */](source);
                            output = source;
                        }
                        catch (e) {
                            // if serialization fails return an empty string
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 48 /* _eInternalMessageId.CannotSerializeObject */, (e && (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TO_STRING /* @min:%2etoString */])) ? e[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TO_STRING /* @min:%2etoString */]() : "Error serializing object", null, true);
                        }
                    }
                    return output;
                }
                source[circularReferenceCheck] = true;
                (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(source.aiDataContract, function (field, contract) {
                    var isRequired = ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(contract)) ? (contract() & 1 /* FieldType.Required */) : (contract & 1 /* FieldType.Required */);
                    var isHidden = ((0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(contract)) ? (contract() & 4 /* FieldType.Hidden */) : (contract & 4 /* FieldType.Hidden */);
                    var isArray = contract & 2 /* FieldType.Array */;
                    var isPresent = source[field] !== undefined;
                    var isObj = (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(source[field]) && source[field] !== null;
                    if (isRequired && !isPresent && !isArray) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 24 /* _eInternalMessageId.MissingRequiredFieldSpecification */, "Missing required field specification. The field is required but not present on source", { field: field, name: name });
                        // If not in debug mode, continue and hope the error is permissible
                    }
                    else if (!isHidden) { // Don't serialize hidden fields
                        var value = void 0;
                        if (isObj) {
                            if (isArray) {
                                // special case; recurse on each object in the source array
                                value = _serializeArray(source[field], field);
                            }
                            else {
                                // recurse on the source object in this field
                                value = _serializeObject(source[field], field);
                            }
                        }
                        else {
                            // assign the source field to the output even if undefined or required
                            value = source[field];
                        }
                        // only emit this field if the value is defined
                        if (value !== undefined) {
                            output[field] = value;
                        }
                    }
                });
                delete source[circularReferenceCheck];
                return output;
            }
            function _serializeArray(sources, name) {
                var output;
                if (!!sources) {
                    if (!(0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(sources)) {
                        (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, 54 /* _eInternalMessageId.ItemNotInArray */, "This field was specified as an array in the contract but the item is not an array.\r\n", { name: name }, true);
                    }
                    else {
                        output = [];
                        for (var i = 0; i < sources[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_LENGTH /* @min:%2elength */]; i++) {
                            var source = sources[i];
                            var item = _serializeObject(source, name + "[" + i + "]");
                            output[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_PUSH /* @min:%2epush */](item);
                        }
                    }
                }
                return output;
            }
            function _serializeStringMap(map, expectedType, name) {
                var output;
                if (map) {
                    output = {};
                    (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.objForEachKey)(map, function (field, value) {
                        if (expectedType === "string") {
                            if (value === undefined) {
                                output[field] = "undefined";
                            }
                            else if (value === null) {
                                output[field] = "null";
                            }
                            else if (!value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TO_STRING /* @min:%2etoString */]) {
                                output[field] = "invalid field: toString() is not defined.";
                            }
                            else {
                                output[field] = value[_DynamicConstants__WEBPACK_IMPORTED_MODULE_4__._DYN_TO_STRING /* @min:%2etoString */]();
                            }
                        }
                        else if (expectedType === "number") {
                            if (value === undefined) {
                                output[field] = "undefined";
                            }
                            else if (value === null) {
                                output[field] = "null";
                            }
                            else {
                                var num = parseFloat(value);
                                output[field] = num;
                            }
                        }
                        else {
                            output[field] = "invalid field: " + name + " is of unknown type.";
                            (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_3__._throwInternal)(logger, 1 /* eLoggingSeverity.CRITICAL */, output[field], null, true);
                        }
                    });
                }
                return output;
            }
        });
    }
// Removed Stub for Serializer.prototype.serialize.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    Serializer.__ieDyn=1;

    return Serializer;
}());

//# sourceMappingURL=Serializer.js.map

/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sample: () => (/* binding */ Sample)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90);
/* harmony import */ var _microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(110);
/* harmony import */ var _SamplingScoreGenerators_SamplingScoreGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(114);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */






var Sample = /** @class */ (function () {
    function Sample(sampleRate, logger) {
        // We're using 32 bit math, hence max value is (2^31 - 1)
        this.INT_MAX_VALUE = 2147483647;
        var _logger = logger || (0,_microsoft_applicationinsights_core_js__WEBPACK_IMPORTED_MODULE_1__.safeGetLogger)(null);
        if (sampleRate > 100 || sampleRate < 0) {
            _logger.throwInternal(2 /* eLoggingSeverity.WARNING */, 58 /* _eInternalMessageId.SampleRateOutOfRange */, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", { samplingRate: sampleRate }, true);
            sampleRate = 100;
        }
        this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SAMPLE_RATE /* @min:%2esampleRate */] = sampleRate;
        this.samplingScoreGenerator = new _SamplingScoreGenerators_SamplingScoreGenerator__WEBPACK_IMPORTED_MODULE_3__.SamplingScoreGenerator();
    }
    /**
    * Determines if an envelope is sampled in (i.e. will be sent) or not (i.e. will be dropped).
    */
    Sample.prototype.isSampledIn = function (envelope) {
        var samplingPercentage = this[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_SAMPLE_RATE /* @min:%2esampleRate */]; // 0 - 100
        var isSampledIn = false;
        if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {
            return true;
        }
        else if (envelope.baseType === _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_0__.Metric[_DynamicConstants__WEBPACK_IMPORTED_MODULE_2__._DYN_DATA_TYPE /* @min:%2edataType */]) {
            // exclude MetricData telemetry from sampling
            return true;
        }
        isSampledIn = this.samplingScoreGenerator.getSamplingScore(envelope) < samplingPercentage;
        return isSampledIn;
    };
    return Sample;
}());

//# sourceMappingURL=Sample.js.map

/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SamplingScoreGenerator: () => (/* binding */ SamplingScoreGenerator)
/* harmony export */ });
/* harmony import */ var _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);
/* harmony import */ var _HashCodeScoreGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(115);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */





var SamplingScoreGenerator = /** @class */ (function () {
    function SamplingScoreGenerator() {
        var _self = this;
        var hashCodeGenerator = new _HashCodeScoreGenerator__WEBPACK_IMPORTED_MODULE_2__.HashCodeScoreGenerator();
        var keys = new _microsoft_applicationinsights_common__WEBPACK_IMPORTED_MODULE_0__.ContextTagKeys();
        _self.getSamplingScore = function (item) {
            var score = 0;
            if (item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TAGS /* @min:%2etags */] && item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TAGS /* @min:%2etags */][keys.userId]) { // search in tags first, then ext
                score = hashCodeGenerator.getHashCodeScore(item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TAGS /* @min:%2etags */][keys.userId]);
            }
            else if (item.ext && item.ext.user && item.ext.user.id) {
                score = hashCodeGenerator[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_GET_HASH_CODE_SCORE /* @min:%2egetHashCodeScore */](item.ext.user.id);
            }
            else if (item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TAGS /* @min:%2etags */] && item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TAGS /* @min:%2etags */][keys.operationId]) { // search in tags first, then ext
                score = hashCodeGenerator.getHashCodeScore(item[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TAGS /* @min:%2etags */][keys.operationId]);
            }
            else if (item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_ID /* @min:%2etraceID */]) {
                score = hashCodeGenerator.getHashCodeScore(item.ext.telemetryTrace[_DynamicConstants__WEBPACK_IMPORTED_MODULE_1__._DYN_TRACE_ID /* @min:%2etraceID */]);
            }
            else {
                // tslint:disable-next-line:insecure-random
                score = (Math.random() * 100);
            }
            return score;
        };
    }
    return SamplingScoreGenerator;
}());

//# sourceMappingURL=SamplingScoreGenerator.js.map

/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HashCodeScoreGenerator: () => (/* binding */ HashCodeScoreGenerator)
/* harmony export */ });
/* harmony import */ var _DynamicConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(110);
/*
 * Application Insights JavaScript SDK - Channel, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */



// (Magic number) DJB algorithm can't work on shorter strings (results in poor distribution
var MIN_INPUT_LENGTH = 8;
var HashCodeScoreGenerator = /** @class */ (function () {
    function HashCodeScoreGenerator() {
    }
    HashCodeScoreGenerator.prototype.getHashCodeScore = function (key) {
        var score = this.getHashCode(key) / HashCodeScoreGenerator.INT_MAX_VALUE;
        return score * 100;
    };
    HashCodeScoreGenerator.prototype.getHashCode = function (input) {
        if (input === "") {
            return 0;
        }
        while (input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */] < MIN_INPUT_LENGTH) {
            input = input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_CONCAT /* @min:%2econcat */](input);
        }
        // 5381 is a magic number: http://stackoverflow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function
        var hash = 5381;
        for (var i = 0; i < input[_DynamicConstants__WEBPACK_IMPORTED_MODULE_0__._DYN_LENGTH /* @min:%2elength */]; ++i) {
            hash = ((hash << 5) + hash) + input.charCodeAt(i);
            // 'hash' is of number type which means 53 bit integer (http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types-number-type)
            // 'hash & hash' will keep it 32 bit integer - just to make it clearer what the result is.
            hash = hash & hash;
        }
        return Math.abs(hash);
    };
    // We're using 32 bit math, hence max value is (2^31 - 1)
    HashCodeScoreGenerator.INT_MAX_VALUE = 2147483647;
    return HashCodeScoreGenerator;
}());

//# sourceMappingURL=HashCodeScoreGenerator.js.map

/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _DYN_CONNECTION_STRING: () => (/* binding */ _DYN_CONNECTION_STRING),
/* harmony export */   _DYN_ENDPOINT_URL: () => (/* binding */ _DYN_ENDPOINT_URL),
/* harmony export */   _DYN_INSTRUMENTATION_KEY: () => (/* binding */ _DYN_INSTRUMENTATION_KEY),
/* harmony export */   _DYN_USER_OVERRIDE_ENDPOI0: () => (/* binding */ _DYN_USER_OVERRIDE_ENDPOI0)
/* harmony export */ });
/*
 * Application Insights JavaScript Web SDK - Basic, 3.3.11
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */


// @skip-file-minify
// ##############################################################
// AUTO GENERATED FILE: This file is Auto Generated during build.
// ##############################################################
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Note: DON'T Export these const from the package as we are still targeting ES5 which can result in a mutable variables that someone could change!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
var _DYN_INSTRUMENTATION_KEY = "instrumentationKey"; // Count: 6
var _DYN_CONNECTION_STRING = "connectionString"; // Count: 4
var _DYN_ENDPOINT_URL = "endpointUrl"; // Count: 5
var _DYN_USER_OVERRIDE_ENDPOI0 = "userOverrideEndpointUrl"; // Count: 5
//# sourceMappingURL=__DynamicConstants.js.map

/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTelemetryReporter: () => (/* binding */ BaseTelemetryReporter)
/* harmony export */ });
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
class BaseTelemetryReporter {
    constructor(telemetrySender, vscodeAPI, initializationOptions) {
        this.telemetrySender = telemetrySender;
        this.vscodeAPI = vscodeAPI;
        this.userOptIn = false;
        this.errorOptIn = false;
        this.disposables = [];
        this._onDidChangeTelemetryLevel = new this.vscodeAPI.EventEmitter();
        this.onDidChangeTelemetryLevel = this._onDidChangeTelemetryLevel.event;
        this.telemetryLogger = this.vscodeAPI.env.createTelemetryLogger(this.telemetrySender, initializationOptions);
        // Keep track of the user's opt-in status
        this.updateUserOptIn();
        this.telemetryLogger.onDidChangeEnableStates(() => {
            this.updateUserOptIn();
        });
    }
    /**
     * Updates the user's telemetry opt-in status
     */
    updateUserOptIn() {
        this.errorOptIn = this.telemetryLogger.isErrorsEnabled;
        this.userOptIn = this.telemetryLogger.isUsageEnabled;
        // The sender is lazy loaded so if telemetry is off it's not loaded in
        if (this.telemetryLogger.isErrorsEnabled || this.telemetryLogger.isUsageEnabled) {
            this.telemetrySender.instantiateSender();
        }
        this._onDidChangeTelemetryLevel.fire(this.telemetryLevel);
    }
    get telemetryLevel() {
        if (this.errorOptIn && this.userOptIn) {
            return "all";
        }
        else if (this.errorOptIn) {
            return "error";
        }
        else {
            return "off";
        }
    }
    /**
     * Internal function which logs telemetry events and takes extra options.
     * @param eventName The name of the event
     * @param properties The properties of the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures
     * @param dangerous Whether or not to ignore telemetry level
     */
    internalSendTelemetryEvent(eventName, properties, measurements, dangerous) {
        // If it's dangerous we skip going through the logger as the logger checks opt-in status, etc.
        if (dangerous) {
            this.telemetrySender.sendEventData(eventName, { properties, measurements });
        }
        else {
            this.telemetryLogger.logUsage(eventName, { properties, measurements });
        }
    }
    /**
     * Given an event name, some properties, and measurements sends a telemetry event.
     * Properties are sanitized on best-effort basis to remove sensitive data prior to sending.
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     */
    sendTelemetryEvent(eventName, properties, measurements) {
        this.internalSendTelemetryEvent(eventName, properties, measurements, false);
    }
    /**
     * Sends a raw (unsanitized) telemetry event with the given properties and measurements.
     * NOTE: This will not be logged to the output channel due to API limitations.
     * @param eventName The name of the event
     * @param properties The set of properties to add to the event in the form of a string key value pair
     * @param measurements The set of measurements to add to the event in the form of a string key  number value pair
     */
    sendRawTelemetryEvent(eventName, properties, measurements) {
        const modifiedProperties = { ...properties };
        for (const propertyKey of Object.keys(modifiedProperties ?? {})) {
            const propertyValue = modifiedProperties[propertyKey];
            if (typeof propertyKey === "string" && propertyValue !== undefined) {
                // Trusted values are not sanitized, which is what we want for raw telemetry
                modifiedProperties[propertyKey] = new this.vscodeAPI.TelemetryTrustedValue(typeof propertyValue === "string" ? propertyValue : propertyValue.value);
            }
        }
        this.sendTelemetryEvent(eventName, modifiedProperties, measurements);
    }
    /**
     * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry event without checking telemetry setting
     * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures, defaults to true
     */
    sendDangerousTelemetryEvent(eventName, properties, measurements) {
        // Since telemetry is probably off when sending dangerously, we must start the sender
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryEvent(eventName, properties, measurements, true);
    }
    /**
     * Internal function which logs telemetry error events and takes extra options.
     * @param eventName The name of the event
     * @param properties The properties of the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to sanitize to the properties and measures
     * @param dangerous Whether or not to ignore telemetry level
     */
    internalSendTelemetryErrorEvent(eventName, properties, measurements, dangerous) {
        if (dangerous) {
            this.telemetrySender.sendEventData(eventName, { properties, measurements });
        }
        else {
            this.telemetryLogger.logError(eventName, { properties, measurements });
        }
    }
    /**
     * Given an event name, some properties, and measurements sends an error event
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     */
    sendTelemetryErrorEvent(eventName, properties, measurements) {
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, false);
    }
    /**
     * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry error event without checking telemetry setting
     * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
     * @param eventName The name of the event
     * @param properties The properties to send with the event
     * @param measurements The measurements (numeric values) to send with the event
     * @param sanitize Whether or not to run the properties and measures through sanitiziation, defaults to true
     */
    sendDangerousTelemetryErrorEvent(eventName, properties, measurements) {
        // Since telemetry is probably off when sending dangerously, we must start the sender
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, true);
    }
    /**
     * Disposes of the telemetry reporter
     */
    async dispose() {
        await this.telemetrySender.dispose();
        this.telemetryLogger.dispose();
        return Promise.all(this.disposables.map(d => d.dispose()));
    }
}
//# sourceMappingURL=baseTelemetryReporter.js.map

/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTelemetrySender: () => (/* binding */ BaseTelemetrySender)
/* harmony export */ });
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var InstantiationStatus;
(function (InstantiationStatus) {
    InstantiationStatus[InstantiationStatus["NOT_INSTANTIATED"] = 0] = "NOT_INSTANTIATED";
    InstantiationStatus[InstantiationStatus["INSTANTIATING"] = 1] = "INSTANTIATING";
    InstantiationStatus[InstantiationStatus["INSTANTIATED"] = 2] = "INSTANTIATED";
})(InstantiationStatus || (InstantiationStatus = {}));
class BaseTelemetrySender {
    constructor(key, clientFactory) {
        // Whether or not the client has been instantiated
        this._instantiationStatus = InstantiationStatus.NOT_INSTANTIATED;
        // Queues used to store events until the sender is ready
        this._eventQueue = [];
        this._exceptionQueue = [];
        this._clientFactory = clientFactory;
        this._key = key;
    }
    /**
     * Sends the event to the passed in telemetry client
     * The sender does no telemetry level checks as those are done by the reporter.
     * @param eventName The name of the event to log
     * @param data The data contanied in the event
     */
    sendEventData(eventName, data) {
        if (!this._telemetryClient) {
            if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
                this._eventQueue.push({ eventName, data });
            }
            return;
        }
        this._telemetryClient.logEvent(eventName, data);
    }
    /**
     * Sends an exception to the passed in telemetry client
     * The sender does no telemetry level checks as those are done by the reporter.
     * @param exception The exception to collect
     * @param data Data associated with the exception
     */
    sendErrorData(exception, data) {
        if (!this._telemetryClient) {
            if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
                this._exceptionQueue.push({ exception, data });
            }
            return;
        }
        const errorData = { stack: exception.stack, message: exception.message, name: exception.name };
        if (data) {
            const errorProperties = data.properties || data;
            data.properties = { ...errorProperties, ...errorData };
        }
        else {
            data = { properties: errorData };
        }
        this._telemetryClient.logEvent("unhandlederror", data);
    }
    /**
     * Flushes the buffered telemetry data
     */
    async flush() {
        return this._telemetryClient?.flush();
    }
    async dispose() {
        if (this._telemetryClient) {
            await this._telemetryClient.dispose();
            this._telemetryClient = undefined;
        }
        return;
    }
    /**
     * Flushes the queued events that existed before the client was instantiated
     */
    _flushQueues() {
        this._eventQueue.forEach(({ eventName, data }) => this.sendEventData(eventName, data));
        this._eventQueue = [];
        this._exceptionQueue.forEach(({ exception, data }) => this.sendErrorData(exception, data));
        this._exceptionQueue = [];
    }
    /**
     * Instantiates the telemetry client to make the sender "active"
     */
    instantiateSender() {
        if (this._instantiationStatus !== InstantiationStatus.NOT_INSTANTIATED) {
            return;
        }
        this._instantiationStatus = InstantiationStatus.INSTANTIATING;
        // Call the client factory to get the client and then let it know it's instatntiated
        this._clientFactory(this._key).then(client => {
            this._telemetryClient = client;
            this._instantiationStatus = InstantiationStatus.INSTANTIATED;
            this._flushQueues();
        }).catch(err => {
            console.error(err);
            // If it failed to instntiate, then we don't want to try again.
            // So we mark it as instantiated. See #94
            this._instantiationStatus = InstantiationStatus.INSTANTIATED;
        });
    }
}
//# sourceMappingURL=baseTelemetrySender.js.map

/***/ }),
/* 119 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* reexport safe */ _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_11__.AbortError),
/* harmony export */   Blob: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_16__.Blob),
/* harmony export */   FetchError: () => (/* reexport safe */ _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_10__.FetchError),
/* harmony export */   File: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_16__.File),
/* harmony export */   FormData: () => (/* reexport safe */ formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_13__.FormData),
/* harmony export */   Headers: () => (/* reexport safe */ _headers_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   Request: () => (/* reexport safe */ _request_js__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   Response: () => (/* reexport safe */ _response_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   blobFrom: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_16__.blobFrom),
/* harmony export */   blobFromSync: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_16__.blobFromSync),
/* harmony export */   "default": () => (/* binding */ fetch),
/* harmony export */   fileFrom: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_16__.fileFrom),
/* harmony export */   fileFromSync: () => (/* reexport safe */ fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_16__.fileFromSync),
/* harmony export */   isRedirect: () => (/* reexport safe */ _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_12__.isRedirect)
/* harmony export */ });
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);
/* harmony import */ var node_zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(122);
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(123);
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(124);
/* harmony import */ var data_uri_to_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(125);
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(126);
/* harmony import */ var _response_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(139);
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(140);
/* harmony import */ var _request_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(142);
/* harmony import */ var _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(136);
/* harmony import */ var _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(147);
/* harmony import */ var _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(141);
/* harmony import */ var formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(134);
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(138);
/* harmony import */ var _utils_referrer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(145);
/* harmony import */ var fetch_blob_from_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(148);
/**
 * Index.js
 *
 * a request API compatible with window.fetch
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */
























const supportedSchemas = new Set(['data:', 'http:', 'https:']);

/**
 * Fetch function
 *
 * @param   {string | URL | import('./request').default} url - Absolute url or Request instance
 * @param   {*} [options_] - Fetch options
 * @return  {Promise<import('./response').default>}
 */
async function fetch(url, options_) {
	return new Promise((resolve, reject) => {
		// Build request object
		const request = new _request_js__WEBPACK_IMPORTED_MODULE_9__["default"](url, options_);
		const {parsedURL, options} = (0,_request_js__WEBPACK_IMPORTED_MODULE_9__.getNodeRequestOptions)(request);
		if (!supportedSchemas.has(parsedURL.protocol)) {
			throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, '')}" is not supported.`);
		}

		if (parsedURL.protocol === 'data:') {
			const data = (0,data_uri_to_buffer__WEBPACK_IMPORTED_MODULE_5__["default"])(request.url);
			const response = new _response_js__WEBPACK_IMPORTED_MODULE_7__["default"](data, {headers: {'Content-Type': data.typeFull}});
			resolve(response);
			return;
		}

		// Wrap http.request into fetch
		const send = (parsedURL.protocol === 'https:' ? node_https__WEBPACK_IMPORTED_MODULE_1__ : node_http__WEBPACK_IMPORTED_MODULE_0__).request;
		const {signal} = request;
		let response = null;

		const abort = () => {
			const error = new _errors_abort_error_js__WEBPACK_IMPORTED_MODULE_11__.AbortError('The operation was aborted.');
			reject(error);
			if (request.body && request.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
				request.body.destroy(error);
			}

			if (!response || !response.body) {
				return;
			}

			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = () => {
			abort();
			finalize();
		};

		// Send request
		const request_ = send(parsedURL.toString(), options);

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		const finalize = () => {
			request_.abort();
			if (signal) {
				signal.removeEventListener('abort', abortAndFinalize);
			}
		};

		request_.on('error', error => {
			reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_10__.FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));
			finalize();
		});

		fixResponseChunkedTransferBadEnding(request_, error => {
			if (response && response.body) {
				response.body.destroy(error);
			}
		});

		/* c8 ignore next 18 */
		if (process.version < 'v14') {
			// Before Node.js 14, pipeline() does not fully support async iterators and does not always
			// properly handle when the socket close/end events are out of order.
			request_.on('socket', s => {
				let endedWithEventsCount;
				s.prependListener('end', () => {
					endedWithEventsCount = s._eventsCount;
				});
				s.prependListener('close', hadError => {
					// if end happened before close but the socket didn't emit an error, do it now
					if (response && endedWithEventsCount < s._eventsCount && !hadError) {
						const error = new Error('Premature close');
						error.code = 'ERR_STREAM_PREMATURE_CLOSE';
						response.body.emit('error', error);
					}
				});
			});
		}

		request_.on('response', response_ => {
			request_.setTimeout(0);
			const headers = (0,_headers_js__WEBPACK_IMPORTED_MODULE_8__.fromRawHeaders)(response_.rawHeaders);

			// HTTP fetch step 5
			if ((0,_utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_12__.isRedirect)(response_.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL(location, request.url);
				} catch {
					// error here can only be invalid URL in Location: header
					// do not throw when options.redirect == manual
					// let the user extract the errorneous redirect URL
					if (request.redirect !== 'manual') {
						reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_10__.FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
						finalize();
						return;
					}
				}

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_10__.FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// Nothing to do
						break;
					case 'follow': {
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_10__.FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOptions = {
							headers: new _headers_js__WEBPACK_IMPORTED_MODULE_8__["default"](request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: (0,_body_js__WEBPACK_IMPORTED_MODULE_6__.clone)(request),
							signal: request.signal,
							size: request.size,
							referrer: request.referrer,
							referrerPolicy: request.referrerPolicy
						};

						// when forwarding sensitive headers like "Authorization",
						// "WWW-Authenticate", and "Cookie" to untrusted targets,
						// headers will be ignored when following a redirect to a domain
						// that is not a subdomain match or exact match of the initial domain.
						// For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
						// will forward the sensitive headers, but a redirect to "bar.com" will not.
						// headers will also be ignored when following a redirect to a domain using
						// a different protocol. For example, a redirect from "https://foo.com" to "http://foo.com"
						// will not forward the sensitive headers
						if (!(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_14__.isDomainOrSubdomain)(request.url, locationURL) || !(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_14__.isSameProtocol)(request.url, locationURL)) {
							for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
								requestOptions.headers.delete(name);
							}
						}

						// HTTP-redirect fetch step 9
						if (response_.statusCode !== 303 && request.body && options_.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {
							reject(new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_10__.FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {
							requestOptions.method = 'GET';
							requestOptions.body = undefined;
							requestOptions.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 14
						const responseReferrerPolicy = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_15__.parseReferrerPolicyFromHeader)(headers);
						if (responseReferrerPolicy) {
							requestOptions.referrerPolicy = responseReferrerPolicy;
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new _request_js__WEBPACK_IMPORTED_MODULE_9__["default"](locationURL, requestOptions)));
						finalize();
						return;
					}

					default:
						return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
				}
			}

			// Prepare response
			if (signal) {
				response_.once('end', () => {
					signal.removeEventListener('abort', abortAndFinalize);
				});
			}

			let body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(response_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(), error => {
				if (error) {
					reject(error);
				}
			});
			// see https://github.com/nodejs/node/pull/29376
			/* c8 ignore next 3 */
			if (process.version < 'v12.10') {
				response_.on('aborted', abortAndFinalize);
			}

			const responseOptions = {
				url: request.url,
				status: response_.statusCode,
				statusText: response_.statusMessage,
				headers,
				size: request.size,
				counter: request.counter,
				highWaterMark: request.highWaterMark
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
				response = new _response_js__WEBPACK_IMPORTED_MODULE_7__["default"](body, responseOptions);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH,
				finishFlush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH
			};

			// For gzip
			if (codings === 'gzip' || codings === 'x-gzip') {
				body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createGunzip(zlibOptions), error => {
					if (error) {
						reject(error);
					}
				});
				response = new _response_js__WEBPACK_IMPORTED_MODULE_7__["default"](body, responseOptions);
				resolve(response);
				return;
			}

			// For deflate
			if (codings === 'deflate' || codings === 'x-deflate') {
				// Handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(response_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough(), error => {
					if (error) {
						reject(error);
					}
				});
				raw.once('data', chunk => {
					// See http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflate(), error => {
							if (error) {
								reject(error);
							}
						});
					} else {
						body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflateRaw(), error => {
							if (error) {
								reject(error);
							}
						});
					}

					response = new _response_js__WEBPACK_IMPORTED_MODULE_7__["default"](body, responseOptions);
					resolve(response);
				});
				raw.once('end', () => {
					// Some old IIS servers return zero-length OK deflate responses, so
					// 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903
					if (!response) {
						response = new _response_js__WEBPACK_IMPORTED_MODULE_7__["default"](body, responseOptions);
						resolve(response);
					}
				});
				return;
			}

			// For br
			if (codings === 'br') {
				body = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(body, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createBrotliDecompress(), error => {
					if (error) {
						reject(error);
					}
				});
				response = new _response_js__WEBPACK_IMPORTED_MODULE_7__["default"](body, responseOptions);
				resolve(response);
				return;
			}

			// Otherwise, use response as-is
			response = new _response_js__WEBPACK_IMPORTED_MODULE_7__["default"](body, responseOptions);
			resolve(response);
		});

		// eslint-disable-next-line promise/prefer-await-to-then
		(0,_body_js__WEBPACK_IMPORTED_MODULE_6__.writeToStream)(request_, request).catch(reject);
	});
}

function fixResponseChunkedTransferBadEnding(request, errorCallback) {
	const LAST_CHUNK = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from('0\r\n\r\n');

	let isChunkedTransfer = false;
	let properLastChunkReceived = false;
	let previousChunk;

	request.on('response', response => {
		const {headers} = response;
		isChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];
	});

	request.on('socket', socket => {
		const onSocketClose = () => {
			if (isChunkedTransfer && !properLastChunkReceived) {
				const error = new Error('Premature close');
				error.code = 'ERR_STREAM_PREMATURE_CLOSE';
				errorCallback(error);
			}
		};

		const onData = buf => {
			properLastChunkReceived = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;

			// Sometimes final 0-length chunk and end of message code are in separate packets
			if (!properLastChunkReceived && previousChunk) {
				properLastChunkReceived = (
					node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&
					node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0
				);
			}

			previousChunk = buf;
		};

		socket.prependListener('close', onSocketClose);
		socket.on('data', onData);

		request.on('close', () => {
			socket.removeListener('close', onSocketClose);
			socket.removeListener('data', onData);
		});
	});
}


/***/ }),
/* 120 */
/***/ ((module) => {

"use strict";
module.exports = require("node:http");

/***/ }),
/* 121 */
/***/ ((module) => {

"use strict";
module.exports = require("node:https");

/***/ }),
/* 122 */
/***/ ((module) => {

"use strict";
module.exports = require("node:zlib");

/***/ }),
/* 123 */
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),
/* 124 */
/***/ ((module) => {

"use strict";
module.exports = require("node:buffer");

/***/ }),
/* 125 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dataUriToBuffer: () => (/* binding */ dataUriToBuffer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @returns {Buffer} Buffer instance from Data URI
 * @api public
 */
function dataUriToBuffer(uri) {
    if (!/^data:/i.test(uri)) {
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    }
    // strip newlines
    uri = uri.replace(/\r?\n/g, '');
    // split the URI up into the "metadata" and the "data" portions
    const firstComma = uri.indexOf(',');
    if (firstComma === -1 || firstComma <= 4) {
        throw new TypeError('malformed data: URI');
    }
    // remove the "data:" scheme and parse the metadata
    const meta = uri.substring(5, firstComma).split(';');
    let charset = '';
    let base64 = false;
    const type = meta[0] || 'text/plain';
    let typeFull = type;
    for (let i = 1; i < meta.length; i++) {
        if (meta[i] === 'base64') {
            base64 = true;
        }
        else {
            typeFull += `;${meta[i]}`;
            if (meta[i].indexOf('charset=') === 0) {
                charset = meta[i].substring(8);
            }
        }
    }
    // defaults to US-ASCII only if type is not provided
    if (!meta[0] && !charset.length) {
        typeFull += ';charset=US-ASCII';
        charset = 'US-ASCII';
    }
    // get the encoded data portion and decode URI-encoded chars
    const encoding = base64 ? 'base64' : 'ascii';
    const data = unescape(uri.substring(firstComma + 1));
    const buffer = Buffer.from(data, encoding);
    // set `.type` and `.typeFull` properties to MIME type
    buffer.type = type;
    buffer.typeFull = typeFull;
    // set the `.charset` property
    buffer.charset = charset;
    return buffer;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dataUriToBuffer);
//# sourceMappingURL=index.js.map

/***/ }),
/* 126 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   "default": () => (/* binding */ Body),
/* harmony export */   extractContentType: () => (/* binding */ extractContentType),
/* harmony export */   getTotalBytes: () => (/* binding */ getTotalBytes),
/* harmony export */   writeToStream: () => (/* binding */ writeToStream)
/* harmony export */ });
/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(123);
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(127);
/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(124);
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(128);
/* harmony import */ var formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(134);
/* harmony import */ var _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(136);
/* harmony import */ var _errors_base_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(137);
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(138);

/**
 * Body.js
 *
 * Body interface provides common methods for Request and Response
 */












const pipeline = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.promisify)(node_stream__WEBPACK_IMPORTED_MODULE_0__.pipeline);
const INTERNALS = Symbol('Body internals');

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Body {
	constructor(body, {
		size = 0
	} = {}) {
		let boundary = null;

		if (body === null) {
			// Body is undefined or null
			body = null;
		} else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_7__.isURLSearchParameters)(body)) {
			// Body is a URLSearchParams
			body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.toString());
		} else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_7__.isBlob)(body)) {
			// Body is blob
		} else if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
			// Body is Buffer
		} else if (node_util__WEBPACK_IMPORTED_MODULE_1__.types.isAnyArrayBuffer(body)) {
			// Body is ArrayBuffer
			body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body);
		} else if (ArrayBuffer.isView(body)) {
			// Body is ArrayBufferView
			body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
		} else if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
			// Body is stream
		} else if (body instanceof formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData) {
			// Body is FormData
			body = (0,formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.formDataToBlob)(body);
			boundary = body.type.split('=')[1];
		} else {
			// None of the above
			// coerce to string then buffer
			body = node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(String(body));
		}

		let stream = body;

		if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
			stream = node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable.from(body);
		} else if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_7__.isBlob)(body)) {
			stream = node_stream__WEBPACK_IMPORTED_MODULE_0__.Readable.from(body.stream());
		}

		this[INTERNALS] = {
			body,
			stream,
			boundary,
			disturbed: false,
			error: null
		};
		this.size = size;

		if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
			body.on('error', error_ => {
				const error = error_ instanceof _errors_base_js__WEBPACK_IMPORTED_MODULE_6__.FetchBaseError ?
					error_ :
					new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_5__.FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);
				this[INTERNALS].error = error;
			});
		}
	}

	get body() {
		return this[INTERNALS].stream;
	}

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	}

	/**
	 * Decode response as ArrayBuffer
	 *
	 * @return  Promise
	 */
	async arrayBuffer() {
		const {buffer, byteOffset, byteLength} = await consumeBody(this);
		return buffer.slice(byteOffset, byteOffset + byteLength);
	}

	async formData() {
		const ct = this.headers.get('content-type');

		if (ct.startsWith('application/x-www-form-urlencoded')) {
			const formData = new formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData();
			const parameters = new URLSearchParams(await this.text());

			for (const [name, value] of parameters) {
				formData.append(name, value);
			}

			return formData;
		}

		const {toFormData} = await __webpack_require__.e(/* import() */ 1).then(__webpack_require__.bind(__webpack_require__, 198));
		return toFormData(this.body, ct);
	}

	/**
	 * Return raw response as Blob
	 *
	 * @return Promise
	 */
	async blob() {
		const ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';
		const buf = await this.arrayBuffer();

		return new fetch_blob__WEBPACK_IMPORTED_MODULE_3__["default"]([buf], {
			type: ct
		});
	}

	/**
	 * Decode response as json
	 *
	 * @return  Promise
	 */
	async json() {
		const text = await this.text();
		return JSON.parse(text);
	}

	/**
	 * Decode response as text
	 *
	 * @return  Promise
	 */
	async text() {
		const buffer = await consumeBody(this);
		return new TextDecoder().decode(buffer);
	}

	/**
	 * Decode response as buffer (non-spec api)
	 *
	 * @return  Promise
	 */
	buffer() {
		return consumeBody(this);
	}
}

Body.prototype.buffer = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(Body.prototype.buffer, 'Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'', 'node-fetch#buffer');

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: {enumerable: true},
	bodyUsed: {enumerable: true},
	arrayBuffer: {enumerable: true},
	blob: {enumerable: true},
	json: {enumerable: true},
	text: {enumerable: true},
	data: {get: (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(() => {},
		'data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead',
		'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}
});

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return Promise
 */
async function consumeBody(data) {
	if (data[INTERNALS].disturbed) {
		throw new TypeError(`body used already for: ${data.url}`);
	}

	data[INTERNALS].disturbed = true;

	if (data[INTERNALS].error) {
		throw data[INTERNALS].error;
	}

	const {body} = data;

	// Body is null
	if (body === null) {
		return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);
	}

	/* c8 ignore next 3 */
	if (!(body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__)) {
		return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);
	}

	// Body is stream
	// get ready to actually consume the body
	const accum = [];
	let accumBytes = 0;

	try {
		for await (const chunk of body) {
			if (data.size > 0 && accumBytes + chunk.length > data.size) {
				const error = new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_5__.FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');
				body.destroy(error);
				throw error;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		}
	} catch (error) {
		const error_ = error instanceof _errors_base_js__WEBPACK_IMPORTED_MODULE_6__.FetchBaseError ? error : new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_5__.FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);
		throw error_;
	}

	if (body.readableEnded === true || body._readableState.ended === true) {
		try {
			if (accum.every(c => typeof c === 'string')) {
				return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(accum.join(''));
			}

			return node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.concat(accum, accumBytes);
		} catch (error) {
			throw new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_5__.FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);
		}
	} else {
		throw new _errors_fetch_error_js__WEBPACK_IMPORTED_MODULE_5__.FetchError(`Premature close of server response while trying to fetch ${data.url}`);
	}
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed   instance       Response or Request instance
 * @param   String  highWaterMark  highWaterMark for both PassThrough body streams
 * @return  Mixed
 */
const clone = (instance, highWaterMark) => {
	let p1;
	let p2;
	let {body} = instance[INTERNALS];

	// Don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// Check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if ((body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) && (typeof body.getBoundary !== 'function')) {
		// Tee instance body
		p1 = new node_stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough({highWaterMark});
		p2 = new node_stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough({highWaterMark});
		body.pipe(p1);
		body.pipe(p2);
		// Set instance body to teed body and return the other teed body
		instance[INTERNALS].stream = p1;
		body = p2;
	}

	return body;
};

const getNonSpecFormDataBoundary = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(
	body => body.getBoundary(),
	'form-data doesn\'t follow the spec and requires special treatment. Use alternative package',
	'https://github.com/node-fetch/node-fetch/issues/1167'
);

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param {any} body Any options.body input
 * @returns {string | null}
 */
const extractContentType = (body, request) => {
	// Body is null or undefined
	if (body === null) {
		return null;
	}

	// Body is string
	if (typeof body === 'string') {
		return 'text/plain;charset=UTF-8';
	}

	// Body is a URLSearchParams
	if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_7__.isURLSearchParameters)(body)) {
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	}

	// Body is blob
	if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_7__.isBlob)(body)) {
		return body.type || null;
	}

	// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)
	if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body) || node_util__WEBPACK_IMPORTED_MODULE_1__.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
		return null;
	}

	if (body instanceof formdata_polyfill_esm_min_js__WEBPACK_IMPORTED_MODULE_4__.FormData) {
		return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
	}

	// Detect form data input from form-data module
	if (body && typeof body.getBoundary === 'function') {
		return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
	}

	// Body is stream - can't really do much about this
	if (body instanceof node_stream__WEBPACK_IMPORTED_MODULE_0__) {
		return null;
	}

	// Body constructor defaults other things to string
	return 'text/plain;charset=UTF-8';
};

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param {any} obj.body Body object from the Body instance.
 * @returns {number | null}
 */
const getTotalBytes = request => {
	const {body} = request[INTERNALS];

	// Body is null or undefined
	if (body === null) {
		return 0;
	}

	// Body is Blob
	if ((0,_utils_is_js__WEBPACK_IMPORTED_MODULE_7__.isBlob)(body)) {
		return body.size;
	}

	// Body is Buffer
	if (node_buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(body)) {
		return body.length;
	}

	// Detect form data input from form-data module
	if (body && typeof body.getLengthSync === 'function') {
		return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
	}

	// Body is stream
	return null;
};

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param {Stream.Writable} dest The stream to write to.
 * @param obj.body Body object from the Body instance.
 * @returns {Promise<void>}
 */
const writeToStream = async (dest, {body}) => {
	if (body === null) {
		// Body is null
		dest.end();
	} else {
		// Body is stream
		await pipeline(body, dest);
	}
};


/***/ }),
/* 127 */
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),
/* 128 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blob: () => (/* binding */ Blob),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _streams_cjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)
// Node has recently added whatwg stream into core



// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536

/** @param {(Blob | Uint8Array)[]} parts */
async function * toIterator (parts, clone = true) {
  for (const part of parts) {
    if ('stream' in part) {
      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))
    } else if (ArrayBuffer.isView(part)) {
      if (clone) {
        let position = part.byteOffset
        const end = part.byteOffset + part.byteLength
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE)
          const chunk = part.buffer.slice(position, position + size)
          position += chunk.byteLength
          yield new Uint8Array(chunk)
        }
      } else {
        yield part
      }
    /* c8 ignore next 10 */
    } else {
      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)
      let position = 0, b = (/** @type {Blob} */ (part))
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))
        const buffer = await chunk.arrayBuffer()
        position += buffer.byteLength
        yield new Uint8Array(buffer)
      }
    }
  }
}

const _Blob = class Blob {
  /** @type {Array.<(Blob|Uint8Array)>} */
  #parts = []
  #type = ''
  #size = 0
  #endings = 'transparent'

  /**
   * The Blob() constructor returns a new Blob object. The content
   * of the blob consists of the concatenation of the values given
   * in the parameter array.
   *
   * @param {*} blobParts
   * @param {{ type?: string, endings?: string }} [options]
   */
  constructor (blobParts = [], options = {}) {
    if (typeof blobParts !== 'object' || blobParts === null) {
      throw new TypeError('Failed to construct \'Blob\': The provided value cannot be converted to a sequence.')
    }

    if (typeof blobParts[Symbol.iterator] !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': The object must have a callable @@iterator property.')
    }

    if (typeof options !== 'object' && typeof options !== 'function') {
      throw new TypeError('Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.')
    }

    if (options === null) options = {}

    const encoder = new TextEncoder()
    for (const element of blobParts) {
      let part
      if (ArrayBuffer.isView(element)) {
        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))
      } else if (element instanceof ArrayBuffer) {
        part = new Uint8Array(element.slice(0))
      } else if (element instanceof Blob) {
        part = element
      } else {
        part = encoder.encode(`${element}`)
      }

      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size
      this.#parts.push(part)
    }

    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`
    const type = options.type === undefined ? '' : String(options.type)
    this.#type = /^[\x20-\x7E]*$/.test(type) ? type : ''
  }

  /**
   * The Blob interface's size property returns the
   * size of the Blob in bytes.
   */
  get size () {
    return this.#size
  }

  /**
   * The type property of a Blob object returns the MIME type of the file.
   */
  get type () {
    return this.#type
  }

  /**
   * The text() method in the Blob interface returns a Promise
   * that resolves with a string containing the contents of
   * the blob, interpreted as UTF-8.
   *
   * @return {Promise<string>}
   */
  async text () {
    // More optimized than using this.arrayBuffer()
    // that requires twice as much ram
    const decoder = new TextDecoder()
    let str = ''
    for await (const part of toIterator(this.#parts, false)) {
      str += decoder.decode(part, { stream: true })
    }
    // Remaining
    str += decoder.decode()
    return str
  }

  /**
   * The arrayBuffer() method in the Blob interface returns a
   * Promise that resolves with the contents of the blob as
   * binary data contained in an ArrayBuffer.
   *
   * @return {Promise<ArrayBuffer>}
   */
  async arrayBuffer () {
    // Easier way... Just a unnecessary overhead
    // const view = new Uint8Array(this.size);
    // await this.stream().getReader({mode: 'byob'}).read(view);
    // return view.buffer;

    const data = new Uint8Array(this.size)
    let offset = 0
    for await (const chunk of toIterator(this.#parts, false)) {
      data.set(chunk, offset)
      offset += chunk.length
    }

    return data.buffer
  }

  stream () {
    const it = toIterator(this.#parts, true)

    return new globalThis.ReadableStream({
      // @ts-ignore
      type: 'bytes',
      async pull (ctrl) {
        const chunk = await it.next()
        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)
      },

      async cancel () {
        await it.return()
      }
    })
  }

  /**
   * The Blob interface's slice() method creates and returns a
   * new Blob object which contains data from a subset of the
   * blob on which it's called.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @param {string} [type]
   */
  slice (start = 0, end = this.size, type = '') {
    const { size } = this

    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)
    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)

    const span = Math.max(relativeEnd - relativeStart, 0)
    const parts = this.#parts
    const blobParts = []
    let added = 0

    for (const part of parts) {
      // don't add the overflow to new blobParts
      if (added >= span) {
        break
      }

      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size
      if (relativeStart && size <= relativeStart) {
        // Skip the beginning and change the relative
        // start & end position as we skip the unwanted parts
        relativeStart -= size
        relativeEnd -= size
      } else {
        let chunk
        if (ArrayBuffer.isView(part)) {
          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))
          added += chunk.byteLength
        } else {
          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))
          added += chunk.size
        }
        relativeEnd -= size
        blobParts.push(chunk)
        relativeStart = 0 // All next sequential parts should start at 0
      }
    }

    const blob = new Blob([], { type: String(type).toLowerCase() })
    blob.#size = span
    blob.#parts = blobParts

    return blob
  }

  get [Symbol.toStringTag] () {
    return 'Blob'
  }

  static [Symbol.hasInstance] (object) {
    return (
      object &&
      typeof object === 'object' &&
      typeof object.constructor === 'function' &&
      (
        typeof object.stream === 'function' ||
        typeof object.arrayBuffer === 'function'
      ) &&
      /^(Blob|File)$/.test(object[Symbol.toStringTag])
    )
  }
}

Object.defineProperties(_Blob.prototype, {
  size: { enumerable: true },
  type: { enumerable: true },
  slice: { enumerable: true }
})

/** @type {typeof globalThis.Blob} */
const Blob = _Blob
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Blob);


/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* c8 ignore start */
// 64 KiB (same size chrome slice theirs blob into Uint8array's)
const POOL_SIZE = 65536

if (!globalThis.ReadableStream) {
  // `node:stream/web` got introduced in v16.5.0 as experimental
  // and it's preferred over the polyfilled version. So we also
  // suppress the warning that gets emitted by NodeJS for using it.
  try {
    const process = __webpack_require__(130)
    const { emitWarning } = process
    try {
      process.emitWarning = () => {}
      Object.assign(globalThis, __webpack_require__(131))
      process.emitWarning = emitWarning
    } catch (error) {
      process.emitWarning = emitWarning
      throw error
    }
  } catch (error) {
    // fallback to polyfill implementation
    Object.assign(globalThis, __webpack_require__(132))
  }
}

try {
  // Don't use node: prefix for this, require+node: is not supported until node v14.14
  // Only `import()` can use prefix in 12.20 and later
  const { Blob } = __webpack_require__(133)
  if (Blob && !Blob.prototype.stream) {
    Blob.prototype.stream = function name (params) {
      let position = 0
      const blob = this

      return new ReadableStream({
        type: 'bytes',
        async pull (ctrl) {
          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))
          const buffer = await chunk.arrayBuffer()
          position += buffer.byteLength
          ctrl.enqueue(new Uint8Array(buffer))

          if (position === blob.size) {
            ctrl.close()
          }
        }
      })
    }
  }
} catch (error) {}
/* c8 ignore end */


/***/ }),
/* 130 */
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),
/* 131 */
/***/ ((module) => {

"use strict";
module.exports = require("node:stream/web");

/***/ }),
/* 132 */
/***/ (function(__unused_webpack_module, exports) {

/**
 * web-streams-polyfill v3.2.1
 */
(function (global, factory) {
     true ? factory(exports) :
    0;
}(this, (function (exports) { 'use strict';

    /// <reference lib="es2015.symbol" />
    const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?
        Symbol :
        description => `Symbol(${description})`;

    /// <reference lib="dom" />
    function noop() {
        return undefined;
    }
    function getGlobals() {
        if (typeof self !== 'undefined') {
            return self;
        }
        else if (typeof window !== 'undefined') {
            return window;
        }
        else if (typeof global !== 'undefined') {
            return global;
        }
        return undefined;
    }
    const globals = getGlobals();

    function typeIsObject(x) {
        return (typeof x === 'object' && x !== null) || typeof x === 'function';
    }
    const rethrowAssertionErrorRejection = noop;

    const originalPromise = Promise;
    const originalPromiseThen = Promise.prototype.then;
    const originalPromiseResolve = Promise.resolve.bind(originalPromise);
    const originalPromiseReject = Promise.reject.bind(originalPromise);
    function newPromise(executor) {
        return new originalPromise(executor);
    }
    function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
    }
    function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise, onFulfilled, onRejected) {
        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
        // approximation.
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
    }
    function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
    }
    function uponRejection(promise, onRejected) {
        uponPromise(promise, undefined, onRejected);
    }
    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
    }
    const queueMicrotask = (() => {
        const globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask === 'function') {
            return globalQueueMicrotask;
        }
        const resolvedPromise = promiseResolvedWith(undefined);
        return (fn) => PerformPromiseThen(resolvedPromise, fn);
    })();
    function reflectCall(F, V, args) {
        if (typeof F !== 'function') {
            throw new TypeError('Argument is not a function');
        }
        return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
        try {
            return promiseResolvedWith(reflectCall(F, V, args));
        }
        catch (value) {
            return promiseRejectedWith(value);
        }
    }

    // Original from Chromium
    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
    const QUEUE_MAX_ARRAY_SIZE = 16384;
    /**
     * Simple queue structure.
     *
     * Avoids scalability issues with using a packed array directly by using
     * multiple arrays in a linked list and keeping the array size bounded.
     */
    class SimpleQueue {
        constructor() {
            this._cursor = 0;
            this._size = 0;
            // _front and _back are always defined.
            this._front = {
                _elements: [],
                _next: undefined
            };
            this._back = this._front;
            // The cursor is used to avoid calling Array.shift().
            // It contains the index of the front element of the array inside the
            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
            this._cursor = 0;
            // When there is only one node, size === elements.length - cursor.
            this._size = 0;
        }
        get length() {
            return this._size;
        }
        // For exception safety, this method is structured in order:
        // 1. Read state
        // 2. Calculate required state mutations
        // 3. Perform state mutations
        push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
                newBack = {
                    _elements: [],
                    _next: undefined
                };
            }
            // push() is the mutation most likely to throw an exception, so it
            // goes first.
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
                this._back = newBack;
                oldBack._next = newBack;
            }
            ++this._size;
        }
        // Like push(), shift() follows the read -> calculate -> mutate pattern for
        // exception safety.
        shift() { // must not be called on an empty queue
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
                newFront = oldFront._next;
                newCursor = 0;
            }
            // No mutations before this point.
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
                this._front = newFront;
            }
            // Permit shifted element to be garbage collected.
            elements[oldCursor] = undefined;
            return element;
        }
        // The tricky thing about forEach() is that it can be called
        // re-entrantly. The queue may be mutated inside the callback. It is easy to
        // see that push() within the callback has no negative effects since the end
        // of the queue is checked for on every iteration. If shift() is called
        // repeatedly within the callback then the next iteration may return an
        // element that has been removed. In this case the callback will be called
        // with undefined values until we either "catch up" with elements that still
        // exist or reach the back of the queue.
        forEach(callback) {
            let i = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i !== elements.length || node._next !== undefined) {
                if (i === elements.length) {
                    node = node._next;
                    elements = node._elements;
                    i = 0;
                    if (elements.length === 0) {
                        break;
                    }
                }
                callback(elements[i]);
                ++i;
            }
        }
        // Return the element that would be returned if shift() was called now,
        // without modifying the queue.
        peek() { // must not be called on an empty queue
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
        }
    }

    function ReadableStreamReaderGenericInitialize(reader, stream) {
        reader._ownerReadableStream = stream;
        stream._reader = reader;
        if (stream._state === 'readable') {
            defaultReaderClosedPromiseInitialize(reader);
        }
        else if (stream._state === 'closed') {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
        }
        else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
        }
    }
    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
    // check.
    function ReadableStreamReaderGenericCancel(reader, reason) {
        const stream = reader._ownerReadableStream;
        return ReadableStreamCancel(stream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
        if (reader._ownerReadableStream._state === 'readable') {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
        }
        reader._ownerReadableStream._reader = undefined;
        reader._ownerReadableStream = undefined;
    }
    // Helper functions for the readers.
    function readerLockException(name) {
        return new TypeError('Cannot ' + name + ' a stream using a released reader');
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise((resolve, reject) => {
            reader._closedPromise_resolve = resolve;
            reader._closedPromise_reject = reject;
        });
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader);
        defaultReaderClosedPromiseResolve(reader);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
        if (reader._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(reader._closedPromise);
        reader._closedPromise_reject(reason);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }
    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
    }
    function defaultReaderClosedPromiseResolve(reader) {
        if (reader._closedPromise_resolve === undefined) {
            return;
        }
        reader._closedPromise_resolve(undefined);
        reader._closedPromise_resolve = undefined;
        reader._closedPromise_reject = undefined;
    }

    const AbortSteps = SymbolPolyfill('[[AbortSteps]]');
    const ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
    const CancelSteps = SymbolPolyfill('[[CancelSteps]]');
    const PullSteps = SymbolPolyfill('[[PullSteps]]');

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
    const NumberIsFinite = Number.isFinite || function (x) {
        return typeof x === 'number' && isFinite(x);
    };

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
    const MathTrunc = Math.trunc || function (v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
    };

    // https://heycam.github.io/webidl/#idl-dictionaries
    function isDictionary(x) {
        return typeof x === 'object' || typeof x === 'function';
    }
    function assertDictionary(obj, context) {
        if (obj !== undefined && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-callback-functions
    function assertFunction(x, context) {
        if (typeof x !== 'function') {
            throw new TypeError(`${context} is not a function.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-object
    function isObject(x) {
        return (typeof x === 'object' && x !== null) || typeof x === 'function';
    }
    function assertObject(x, context) {
        if (!isObject(x)) {
            throw new TypeError(`${context} is not an object.`);
        }
    }
    function assertRequiredArgument(x, position, context) {
        if (x === undefined) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
        }
    }
    function assertRequiredField(x, field, context) {
        if (x === undefined) {
            throw new TypeError(`${field} is required in '${context}'.`);
        }
    }
    // https://heycam.github.io/webidl/#idl-unrestricted-double
    function convertUnrestrictedDouble(value) {
        return Number(value);
    }
    function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
    }
    function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
    }
    // https://heycam.github.io/webidl/#idl-unsigned-long-long
    function convertUnsignedLongLongWithEnforceRange(value, context) {
        const lowerBound = 0;
        const upperBound = Number.MAX_SAFE_INTEGER;
        let x = Number(value);
        x = censorNegativeZero(x);
        if (!NumberIsFinite(x)) {
            throw new TypeError(`${context} is not a finite number`);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
        }
        if (!NumberIsFinite(x) || x === 0) {
            return 0;
        }
        // TODO Use BigInt if supported?
        // let xBigInt = BigInt(integerPart(x));
        // xBigInt = BigInt.asUintN(64, xBigInt);
        // return Number(xBigInt);
        return x;
    }

    function assertReadableStream(x, context) {
        if (!IsReadableStream(x)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
        }
    }

    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamDefaultReader(stream) {
        return new ReadableStreamDefaultReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadRequest(stream, readRequest) {
        stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readRequest = reader._readRequests.shift();
        if (done) {
            readRequest._closeSteps();
        }
        else {
            readRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadRequests(stream) {
        return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
        const reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamDefaultReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A default reader vended by a {@link ReadableStream}.
     *
     * @public
     */
    class ReadableStreamDefaultReader {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
            assertReadableStream(stream, 'First parameter');
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed,
         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = undefined) {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('cancel'));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read() {
            if (!IsReadableStreamDefaultReader(this)) {
                return promiseRejectedWith(defaultReaderBrandCheckException('read'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('read from'));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readRequest = {
                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),
                _closeSteps: () => resolvePromise({ value: undefined, done: true }),
                _errorSteps: e => rejectPromise(e)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
                throw defaultReaderBrandCheckException('releaseLock');
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            if (this._readRequests.length > 0) {
                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
            }
            ReadableStreamReaderGenericRelease(this);
        }
    }
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStreamDefaultReader',
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamDefaultReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
            return false;
        }
        return x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === 'closed') {
            readRequest._closeSteps();
        }
        else if (stream._state === 'errored') {
            readRequest._errorSteps(stream._storedError);
        }
        else {
            stream._readableStreamController[PullSteps](readRequest);
        }
    }
    // Helper functions for the ReadableStreamDefaultReader.
    function defaultReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
    }

    /// <reference lib="es2018.asynciterable" />
    /* eslint-disable @typescript-eslint/no-empty-function */
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);

    /// <reference lib="es2018.asynciterable" />
    class ReadableStreamAsyncIteratorImpl {
        constructor(reader, preventCancel) {
            this._ongoingPromise = undefined;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
        }
        next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ?
                transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :
                nextSteps();
            return this._ongoingPromise;
        }
        return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ?
                transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :
                returnSteps();
        }
        _nextSteps() {
            if (this._isFinished) {
                return Promise.resolve({ value: undefined, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('iterate'));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readRequest = {
                _chunkSteps: chunk => {
                    this._ongoingPromise = undefined;
                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
                    // FIXME Is this a bug in the specification, or in the test?
                    queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
                },
                _closeSteps: () => {
                    this._ongoingPromise = undefined;
                    this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    resolvePromise({ value: undefined, done: true });
                },
                _errorSteps: reason => {
                    this._ongoingPromise = undefined;
                    this._isFinished = true;
                    ReadableStreamReaderGenericRelease(reader);
                    rejectPromise(reason);
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
        }
        _returnSteps(value) {
            if (this._isFinished) {
                return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('finish iterating'));
            }
            if (!this._preventCancel) {
                const result = ReadableStreamReaderGenericCancel(reader, value);
                ReadableStreamReaderGenericRelease(reader);
                return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
        }
    }
    const ReadableStreamAsyncIteratorPrototype = {
        next() {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
            }
            return this._asyncIteratorImpl.next();
        },
        return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
            }
            return this._asyncIteratorImpl.return(value);
        }
    };
    if (AsyncIteratorPrototype !== undefined) {
        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    }
    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        iterator._asyncIteratorImpl = impl;
        return iterator;
    }
    function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
            return false;
        }
        try {
            // noinspection SuspiciousTypeOfGuard
            return x._asyncIteratorImpl instanceof
                ReadableStreamAsyncIteratorImpl;
        }
        catch (_a) {
            return false;
        }
    }
    // Helper functions for the ReadableStream.
    function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
    }

    /// <reference lib="es2015.core" />
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
    const NumberIsNaN = Number.isNaN || function (x) {
        // eslint-disable-next-line no-self-compare
        return x !== x;
    };

    function CreateArrayFromList(elements) {
        // We use arrays to represent lists, so this is basically a no-op.
        // Do a slice though just in case we happen to depend on the unique-ness.
        return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    // Not implemented correctly
    function TransferArrayBuffer(O) {
        return O;
    }
    // Not implemented correctly
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function IsDetachedBuffer(O) {
        return false;
    }
    function ArrayBufferSlice(buffer, begin, end) {
        // ArrayBuffer.prototype.slice is not available on IE10
        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
        if (buffer.slice) {
            return buffer.slice(begin, end);
        }
        const length = end - begin;
        const slice = new ArrayBuffer(length);
        CopyDataBlockBytes(slice, 0, buffer, begin, length);
        return slice;
    }

    function IsNonNegativeNumber(v) {
        if (typeof v !== 'number') {
            return false;
        }
        if (NumberIsNaN(v)) {
            return false;
        }
        if (v < 0) {
            return false;
        }
        return true;
    }
    function CloneAsUint8Array(O) {
        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
    }

    function DequeueValue(container) {
        const pair = container._queue.shift();
        container._queueTotalSize -= pair.size;
        if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
        }
        return pair.value;
    }
    function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
        }
        container._queue.push({ value, size });
        container._queueTotalSize += size;
    }
    function PeekQueueValue(container) {
        const pair = container._queue.peek();
        return pair.value;
    }
    function ResetQueue(container) {
        container._queue = new SimpleQueue();
        container._queueTotalSize = 0;
    }

    /**
     * A pull-into request in a {@link ReadableByteStreamController}.
     *
     * @public
     */
    class ReadableStreamBYOBRequest {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
         */
        get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('view');
            }
            return this._view;
        }
        respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('respond');
            }
            assertRequiredArgument(bytesWritten, 1, 'respond');
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError('This BYOB request has been invalidated');
            }
            if (IsDetachedBuffer(this._view.buffer)) ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
        }
        respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
                throw byobRequestBrandCheckException('respondWithNewView');
            }
            assertRequiredArgument(view, 1, 'respondWithNewView');
            if (!ArrayBuffer.isView(view)) {
                throw new TypeError('You can only respond with array buffer views');
            }
            if (this._associatedReadableByteStreamController === undefined) {
                throw new TypeError('This BYOB request has been invalidated');
            }
            if (IsDetachedBuffer(view.buffer)) ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
        }
    }
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: true },
        respondWithNewView: { enumerable: true },
        view: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStreamBYOBRequest',
            configurable: true
        });
    }
    /**
     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
     *
     * @public
     */
    class ReadableByteStreamController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the current BYOB pull request, or `null` if there isn't one.
         */
        get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('byobRequest');
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('desiredSize');
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('close');
            }
            if (this._closeRequested) {
                throw new TypeError('The stream has already been closed; do not close it again!');
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== 'readable') {
                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
        }
        enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('enqueue');
            }
            assertRequiredArgument(chunk, 1, 'enqueue');
            if (!ArrayBuffer.isView(chunk)) {
                throw new TypeError('chunk must be an array buffer view');
            }
            if (chunk.byteLength === 0) {
                throw new TypeError('chunk must have non-zero byteLength');
            }
            if (chunk.buffer.byteLength === 0) {
                throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
                throw new TypeError('stream is closed or draining');
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== 'readable') {
                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e = undefined) {
            if (!IsReadableByteStreamController(this)) {
                throw byteStreamControllerBrandCheckException('error');
            }
            ReadableByteStreamControllerError(this, e);
        }
        /** @internal */
        [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
                const entry = this._queue.shift();
                this._queueTotalSize -= entry.byteLength;
                ReadableByteStreamControllerHandleQueueDrain(this);
                const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                readRequest._chunkSteps(view);
                return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== undefined) {
                let buffer;
                try {
                    buffer = new ArrayBuffer(autoAllocateChunkSize);
                }
                catch (bufferE) {
                    readRequest._errorSteps(bufferE);
                    return;
                }
                const pullIntoDescriptor = {
                    buffer,
                    bufferByteLength: autoAllocateChunkSize,
                    byteOffset: 0,
                    byteLength: autoAllocateChunkSize,
                    bytesFilled: 0,
                    elementSize: 1,
                    viewConstructor: Uint8Array,
                    readerType: 'default'
                };
                this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
        }
    }
    Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        byobRequest: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableByteStreamController',
            configurable: true
        });
    }
    // Abstract operations for the ReadableByteStreamController.
    function IsReadableByteStreamController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
            return false;
        }
        return x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
            return false;
        }
        return x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        // TODO: Test controller argument
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
        }, e => {
            ReadableByteStreamControllerError(controller, e);
        });
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        controller._pendingPullIntos = new SimpleQueue();
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
        let done = false;
        if (stream._state === 'closed') {
            done = true;
        }
        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        if (pullIntoDescriptor.readerType === 'default') {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
        }
        else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
        }
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        const bytesFilled = pullIntoDescriptor.bytesFilled;
        const elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength });
        controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        const elementSize = pullIntoDescriptor.elementSize;
        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
        let totalBytesToCopyRemaining = maxBytesToCopy;
        let ready = false;
        if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
        }
        const queue = controller._queue;
        while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
                queue.shift();
            }
            else {
                headOfQueue.byteOffset += bytesToCopy;
                headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
        if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
        }
        else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        if (controller._byobRequest === null) {
            return;
        }
        controller._byobRequest._associatedReadableByteStreamController = undefined;
        controller._byobRequest._view = null;
        controller._byobRequest = null;
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
                return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        const stream = controller._controlledReadableByteStream;
        let elementSize = 1;
        if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
        }
        const ctor = view.constructor;
        // try {
        const buffer = TransferArrayBuffer(view.buffer);
        // } catch (e) {
        //   readIntoRequest._errorSteps(e);
        //   return;
        // }
        const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: 'byob'
        };
        if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            // No ReadableByteStreamControllerCallPullIfNeeded() call since:
            // - No change happens on desiredSize
            // - The source has already been notified of that there's at least 1 pending read(view)
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
        }
        if (stream._state === 'closed') {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
        }
        if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                ReadableByteStreamControllerHandleQueueDrain(controller);
                readIntoRequest._chunkSteps(filledView);
                return;
            }
            if (controller._closeRequested) {
                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
                ReadableByteStreamControllerError(controller, e);
                readIntoRequest._errorSteps(e);
                return;
            }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        const stream = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
        }
    }
    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
        }
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
        if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
        }
        pullIntoDescriptor.bytesFilled -= remainderSize;
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            ReadableByteStreamControllerRespondInClosedState(controller);
        }
        else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        const descriptor = controller._pendingPullIntos.shift();
        return descriptor;
    }
    function ReadableByteStreamControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== 'readable') {
            return false;
        }
        if (controller._closeRequested) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
        }
        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
    }
    // A client of ReadableByteStreamController may use these functions directly to bypass state check.
    function ReadableByteStreamControllerClose(controller) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== 'readable') {
            return;
        }
        if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
        }
        if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
                ReadableByteStreamControllerError(controller, e);
                throw e;
            }
        }
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
        const stream = controller._controlledReadableByteStream;
        if (controller._closeRequested || stream._state !== 'readable') {
            return;
        }
        const buffer = chunk.buffer;
        const byteOffset = chunk.byteOffset;
        const byteLength = chunk.byteLength;
        const transferredBuffer = TransferArrayBuffer(buffer);
        if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            }
            else {
                if (controller._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerShiftPendingPullInto(controller);
                }
                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
        }
        else if (ReadableStreamHasBYOBReader(stream)) {
            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        }
        ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
        const stream = controller._controlledReadableByteStream;
        if (stream._state !== 'readable') {
            return;
        }
        ReadableByteStreamControllerClearPendingPullIntos(controller);
        ResetQueue(controller);
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableByteStream._state;
        if (state === 'errored') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            if (bytesWritten !== 0) {
                throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
            }
        }
        else {
            if (bytesWritten === 0) {
                throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
                throw new RangeError('bytesWritten out of range');
            }
        }
        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const state = controller._controlledReadableByteStream._state;
        if (state === 'closed') {
            if (view.byteLength !== 0) {
                throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
            }
        }
        else {
            if (view.byteLength === 0) {
                throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
            }
        }
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError('The region specified by view does not match byobRequest');
        }
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError('The buffer of view has different capacity than byobRequest');
        }
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError('The region specified by view is larger than byobRequest');
        }
        const viewByteLength = view.byteLength;
        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._byobRequest = null;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._closeRequested = false;
        controller._started = false;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        controller._autoAllocateChunkSize = autoAllocateChunkSize;
        controller._pendingPullIntos = new SimpleQueue();
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, r => {
            ReadableByteStreamControllerError(controller, r);
        });
    }
    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
        const controller = Object.create(ReadableByteStreamController.prototype);
        let startAlgorithm = () => undefined;
        let pullAlgorithm = () => promiseResolvedWith(undefined);
        let cancelAlgorithm = () => promiseResolvedWith(undefined);
        if (underlyingByteSource.start !== undefined) {
            startAlgorithm = () => underlyingByteSource.start(controller);
        }
        if (underlyingByteSource.pull !== undefined) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
        }
        if (underlyingByteSource.cancel !== undefined) {
            cancelAlgorithm = reason => underlyingByteSource.cancel(reason);
        }
        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0) {
            throw new TypeError('autoAllocateChunkSize must be greater than 0');
        }
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
    }
    function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller;
        request._view = view;
    }
    // Helper functions for the ReadableStreamBYOBRequest.
    function byobRequestBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
    }
    // Helper functions for the ReadableByteStreamController.
    function byteStreamControllerBrandCheckException(name) {
        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
    }

    // Abstract operations for the ReadableStream.
    function AcquireReadableStreamBYOBReader(stream) {
        return new ReadableStreamBYOBReader(stream);
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
        stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
        const reader = stream._reader;
        const readIntoRequest = reader._readIntoRequests.shift();
        if (done) {
            readIntoRequest._closeSteps(chunk);
        }
        else {
            readIntoRequest._chunkSteps(chunk);
        }
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
        return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
        const reader = stream._reader;
        if (reader === undefined) {
            return false;
        }
        if (!IsReadableStreamBYOBReader(reader)) {
            return false;
        }
        return true;
    }
    /**
     * A BYOB reader vended by a {@link ReadableStream}.
     *
     * @public
     */
    class ReadableStreamBYOBReader {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
            assertReadableStream(stream, 'First parameter');
            if (IsReadableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
                throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +
                    'source');
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the reader's lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
         */
        cancel(reason = undefined) {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
            }
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('cancel'));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
        }
        /**
         * Attempts to reads bytes into view, and returns a promise resolved with the result.
         *
         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
         */
        read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
                return promiseRejectedWith(byobReaderBrandCheckException('read'));
            }
            if (!ArrayBuffer.isView(view)) {
                return promiseRejectedWith(new TypeError('view must be an array buffer view'));
            }
            if (view.byteLength === 0) {
                return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
            }
            if (view.buffer.byteLength === 0) {
                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer)) ;
            if (this._ownerReadableStream === undefined) {
                return promiseRejectedWith(readerLockException('read from'));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve, reject) => {
                resolvePromise = resolve;
                rejectPromise = reject;
            });
            const readIntoRequest = {
                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),
                _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),
                _errorSteps: e => rejectPromise(e)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
        }
        /**
         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
         * from now on; otherwise, the reader will appear closed.
         *
         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
         * do so will throw a `TypeError` and leave the reader locked to the stream.
         */
        releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
                throw byobReaderBrandCheckException('releaseLock');
            }
            if (this._ownerReadableStream === undefined) {
                return;
            }
            if (this._readIntoRequests.length > 0) {
                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
            }
            ReadableStreamReaderGenericRelease(this);
        }
    }
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: true },
        read: { enumerable: true },
        releaseLock: { enumerable: true },
        closed: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStreamBYOBReader',
            configurable: true
        });
    }
    // Abstract operations for the readers.
    function IsReadableStreamBYOBReader(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
            return false;
        }
        return x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        const stream = reader._ownerReadableStream;
        stream._disturbed = true;
        if (stream._state === 'errored') {
            readIntoRequest._errorSteps(stream._storedError);
        }
        else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
        }
    }
    // Helper functions for the ReadableStreamBYOBReader.
    function byobReaderBrandCheckException(name) {
        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
    }

    function ExtractHighWaterMark(strategy, defaultHWM) {
        const { highWaterMark } = strategy;
        if (highWaterMark === undefined) {
            return defaultHWM;
        }
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError('Invalid highWaterMark');
        }
        return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
        const { size } = strategy;
        if (!size) {
            return () => 1;
        }
        return size;
    }

    function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        const size = init === null || init === void 0 ? void 0 : init.size;
        return {
            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)
        };
    }
    function convertQueuingStrategySize(fn, context) {
        assertFunction(fn, context);
        return chunk => convertUnrestrictedDouble(fn(chunk));
    }

    function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        const abort = original === null || original === void 0 ? void 0 : original.abort;
        const close = original === null || original === void 0 ? void 0 : original.close;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        const write = original === null || original === void 0 ? void 0 : original.write;
        return {
            abort: abort === undefined ?
                undefined :
                convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === undefined ?
                undefined :
                convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start === undefined ?
                undefined :
                convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
            write: write === undefined ?
                undefined :
                convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
        };
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
        assertFunction(fn, context);
        return () => promiseCall(fn, original, []);
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }

    function assertWritableStream(x, context) {
        if (!IsWritableStream(x)) {
            throw new TypeError(`${context} is not a WritableStream.`);
        }
    }

    function isAbortSignal(value) {
        if (typeof value !== 'object' || value === null) {
            return false;
        }
        try {
            return typeof value.aborted === 'boolean';
        }
        catch (_a) {
            // AbortSignal.prototype.aborted throws if its brand check fails
            return false;
        }
    }
    const supportsAbortController = typeof AbortController === 'function';
    /**
     * Construct a new AbortController, if supported by the platform.
     *
     * @internal
     */
    function createAbortController() {
        if (supportsAbortController) {
            return new AbortController();
        }
        return undefined;
    }

    /**
     * A writable stream represents a destination for data, into which you can write.
     *
     * @public
     */
    class WritableStream {
        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === undefined) {
                rawUnderlyingSink = null;
            }
            else {
                assertObject(rawUnderlyingSink, 'First parameter');
            }
            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== undefined) {
                throw new RangeError('Invalid type is specified');
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
        }
        /**
         * Returns whether or not the writable stream is locked to a writer.
         */
        get locked() {
            if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2('locked');
            }
            return IsWritableStreamLocked(this);
        }
        /**
         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
         * mechanism of the underlying sink.
         *
         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
         * the stream) if the stream is currently locked.
         */
        abort(reason = undefined) {
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2('abort'));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
            }
            return WritableStreamAbort(this, reason);
        }
        /**
         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
         *
         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
         */
        close() {
            if (!IsWritableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$2('close'));
            }
            if (IsWritableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
            }
            return WritableStreamClose(this);
        }
        /**
         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
         * is locked, no other writer can be acquired until this one is released.
         *
         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
         */
        getWriter() {
            if (!IsWritableStream(this)) {
                throw streamBrandCheckException$2('getWriter');
            }
            return AcquireWritableStreamDefaultWriter(this);
        }
    }
    Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        getWriter: { enumerable: true },
        locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: 'WritableStream',
            configurable: true
        });
    }
    // Abstract operations for the WritableStream.
    function AcquireWritableStreamDefaultWriter(stream) {
        return new WritableStreamDefaultWriter(stream);
    }
    // Throws if and only if startAlgorithm throws.
    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream);
        const controller = Object.create(WritableStreamDefaultController.prototype);
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    function InitializeWritableStream(stream) {
        stream._state = 'writable';
        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
        // 'erroring' or 'errored'. May be set to an undefined value.
        stream._storedError = undefined;
        stream._writer = undefined;
        // Initialize to undefined first because the constructor of the controller checks this
        // variable to validate the caller.
        stream._writableStreamController = undefined;
        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
        // producer without waiting for the queued writes to finish.
        stream._writeRequests = new SimpleQueue();
        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
        stream._inFlightWriteRequest = undefined;
        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
        // has been detached.
        stream._closeRequest = undefined;
        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
        stream._inFlightCloseRequest = undefined;
        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
        stream._pendingAbortRequest = undefined;
        // The backpressure signal set by the controller.
        stream._backpressure = false;
    }
    function IsWritableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
            return false;
        }
        return x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
        if (stream._writer === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamAbort(stream, reason) {
        var _a;
        if (stream._state === 'closed' || stream._state === 'errored') {
            return promiseResolvedWith(undefined);
        }
        stream._writableStreamController._abortReason = reason;
        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
        // but it doesn't know that signaling abort runs author code that might have changed the state.
        // Widen the type again by casting to WritableStreamState.
        const state = stream._state;
        if (state === 'closed' || state === 'errored') {
            return promiseResolvedWith(undefined);
        }
        if (stream._pendingAbortRequest !== undefined) {
            return stream._pendingAbortRequest._promise;
        }
        let wasAlreadyErroring = false;
        if (state === 'erroring') {
            wasAlreadyErroring = true;
            // reason will not be used, so don't keep a reference to it.
            reason = undefined;
        }
        const promise = newPromise((resolve, reject) => {
            stream._pendingAbortRequest = {
                _promise: undefined,
                _resolve: resolve,
                _reject: reject,
                _reason: reason,
                _wasAlreadyErroring: wasAlreadyErroring
            };
        });
        stream._pendingAbortRequest._promise = promise;
        if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
        }
        return promise;
    }
    function WritableStreamClose(stream) {
        const state = stream._state;
        if (state === 'closed' || state === 'errored') {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
        }
        const promise = newPromise((resolve, reject) => {
            const closeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._closeRequest = closeRequest;
        });
        const writer = stream._writer;
        if (writer !== undefined && stream._backpressure && state === 'writable') {
            defaultWriterReadyPromiseResolve(writer);
        }
        WritableStreamDefaultControllerClose(stream._writableStreamController);
        return promise;
    }
    // WritableStream API exposed for controllers.
    function WritableStreamAddWriteRequest(stream) {
        const promise = newPromise((resolve, reject) => {
            const writeRequest = {
                _resolve: resolve,
                _reject: reject
            };
            stream._writeRequests.push(writeRequest);
        });
        return promise;
    }
    function WritableStreamDealWithRejection(stream, error) {
        const state = stream._state;
        if (state === 'writable') {
            WritableStreamStartErroring(stream, error);
            return;
        }
        WritableStreamFinishErroring(stream);
    }
    function WritableStreamStartErroring(stream, reason) {
        const controller = stream._writableStreamController;
        stream._state = 'erroring';
        stream._storedError = reason;
        const writer = stream._writer;
        if (writer !== undefined) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
        }
        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
        }
    }
    function WritableStreamFinishErroring(stream) {
        stream._state = 'errored';
        stream._writableStreamController[ErrorSteps]();
        const storedError = stream._storedError;
        stream._writeRequests.forEach(writeRequest => {
            writeRequest._reject(storedError);
        });
        stream._writeRequests = new SimpleQueue();
        if (stream._pendingAbortRequest === undefined) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        const abortRequest = stream._pendingAbortRequest;
        stream._pendingAbortRequest = undefined;
        if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
        }
        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        });
    }
    function WritableStreamFinishInFlightWrite(stream) {
        stream._inFlightWriteRequest._resolve(undefined);
        stream._inFlightWriteRequest = undefined;
    }
    function WritableStreamFinishInFlightWriteWithError(stream, error) {
        stream._inFlightWriteRequest._reject(error);
        stream._inFlightWriteRequest = undefined;
        WritableStreamDealWithRejection(stream, error);
    }
    function WritableStreamFinishInFlightClose(stream) {
        stream._inFlightCloseRequest._resolve(undefined);
        stream._inFlightCloseRequest = undefined;
        const state = stream._state;
        if (state === 'erroring') {
            // The error was too late to do anything, so it is ignored.
            stream._storedError = undefined;
            if (stream._pendingAbortRequest !== undefined) {
                stream._pendingAbortRequest._resolve();
                stream._pendingAbortRequest = undefined;
            }
        }
        stream._state = 'closed';
        const writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseResolve(writer);
        }
    }
    function WritableStreamFinishInFlightCloseWithError(stream, error) {
        stream._inFlightCloseRequest._reject(error);
        stream._inFlightCloseRequest = undefined;
        // Never execute sink abort() after sink close().
        if (stream._pendingAbortRequest !== undefined) {
            stream._pendingAbortRequest._reject(error);
            stream._pendingAbortRequest = undefined;
        }
        WritableStreamDealWithRejection(stream, error);
    }
    // TODO(ricea): Fix alphabetical order.
    function WritableStreamCloseQueuedOrInFlight(stream) {
        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamHasOperationMarkedInFlight(stream) {
        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
            return false;
        }
        return true;
    }
    function WritableStreamMarkCloseRequestInFlight(stream) {
        stream._inFlightCloseRequest = stream._closeRequest;
        stream._closeRequest = undefined;
    }
    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
        stream._inFlightWriteRequest = stream._writeRequests.shift();
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
        if (stream._closeRequest !== undefined) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = undefined;
        }
        const writer = stream._writer;
        if (writer !== undefined) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
        }
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
        const writer = stream._writer;
        if (writer !== undefined && backpressure !== stream._backpressure) {
            if (backpressure) {
                defaultWriterReadyPromiseReset(writer);
            }
            else {
                defaultWriterReadyPromiseResolve(writer);
            }
        }
        stream._backpressure = backpressure;
    }
    /**
     * A default writer vended by a {@link WritableStream}.
     *
     * @public
     */
    class WritableStreamDefaultWriter {
        constructor(stream) {
            assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
            assertWritableStream(stream, 'First parameter');
            if (IsWritableStreamLocked(stream)) {
                throw new TypeError('This stream has already been locked for exclusive writing by another writer');
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === 'writable') {
                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                    defaultWriterReadyPromiseInitialize(this);
                }
                else {
                    defaultWriterReadyPromiseInitializeAsResolved(this);
                }
                defaultWriterClosedPromiseInitialize(this);
            }
            else if (state === 'erroring') {
                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
                defaultWriterClosedPromiseInitialize(this);
            }
            else if (state === 'closed') {
                defaultWriterReadyPromiseInitializeAsResolved(this);
                defaultWriterClosedPromiseInitializeAsResolved(this);
            }
            else {
                const storedError = stream._storedError;
                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
        }
        /**
         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
         * the writer’s lock is released before the stream finishes closing.
         */
        get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
            }
            return this._closedPromise;
        }
        /**
         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.
         * A producer can use this information to determine the right amount of data to write.
         *
         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
         * the writer’s lock is released.
         */
        get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException('desiredSize');
            }
            if (this._ownerWritableStream === undefined) {
                throw defaultWriterLockException('desiredSize');
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
        }
        /**
         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions
         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
         *
         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become
         * rejected.
         */
        get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
            }
            return this._readyPromise;
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
         */
        abort(reason = undefined) {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('abort'));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
        }
        /**
         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
         */
        close() {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('close'));
            }
            const stream = this._ownerWritableStream;
            if (stream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('close'));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
            }
            return WritableStreamDefaultWriterClose(this);
        }
        /**
         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.
         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
         * now on; otherwise, the writer will appear closed.
         *
         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
         * other producers from writing in an interleaved manner.
         */
        releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
                throw defaultWriterBrandCheckException('releaseLock');
            }
            const stream = this._ownerWritableStream;
            if (stream === undefined) {
                return;
            }
            WritableStreamDefaultWriterRelease(this);
        }
        write(chunk = undefined) {
            if (!IsWritableStreamDefaultWriter(this)) {
                return promiseRejectedWith(defaultWriterBrandCheckException('write'));
            }
            if (this._ownerWritableStream === undefined) {
                return promiseRejectedWith(defaultWriterLockException('write to'));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
        }
    }
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: true },
        close: { enumerable: true },
        releaseLock: { enumerable: true },
        write: { enumerable: true },
        closed: { enumerable: true },
        desiredSize: { enumerable: true },
        ready: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: 'WritableStreamDefaultWriter',
            configurable: true
        });
    }
    // Abstract operations for the WritableStreamDefaultWriter.
    function IsWritableStreamDefaultWriter(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
            return false;
        }
        return x instanceof WritableStreamDefaultWriter;
    }
    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
    function WritableStreamDefaultWriterAbort(writer, reason) {
        const stream = writer._ownerWritableStream;
        return WritableStreamAbort(stream, reason);
    }
    function WritableStreamDefaultWriterClose(writer) {
        const stream = writer._ownerWritableStream;
        return WritableStreamClose(stream);
    }
    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
            return promiseResolvedWith(undefined);
        }
        if (state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        return WritableStreamDefaultWriterClose(writer);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        if (writer._closedPromiseState === 'pending') {
            defaultWriterClosedPromiseReject(writer, error);
        }
        else {
            defaultWriterClosedPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        if (writer._readyPromiseState === 'pending') {
            defaultWriterReadyPromiseReject(writer, error);
        }
        else {
            defaultWriterReadyPromiseResetToRejected(writer, error);
        }
    }
    function WritableStreamDefaultWriterGetDesiredSize(writer) {
        const stream = writer._ownerWritableStream;
        const state = stream._state;
        if (state === 'errored' || state === 'erroring') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
    }
    function WritableStreamDefaultWriterRelease(writer) {
        const stream = writer._ownerWritableStream;
        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
        // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
        // rejected until afterwards. This means that simply testing state will not work.
        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
        stream._writer = undefined;
        writer._ownerWritableStream = undefined;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
        const stream = writer._ownerWritableStream;
        const controller = stream._writableStreamController;
        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException('write to'));
        }
        const state = stream._state;
        if (state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
            return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
        }
        if (state === 'erroring') {
            return promiseRejectedWith(stream._storedError);
        }
        const promise = WritableStreamAddWriteRequest(stream);
        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
        return promise;
    }
    const closeSentinel = {};
    /**
     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
     *
     * @public
     */
    class WritableStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
         *
         * @deprecated
         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
         */
        get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('abortReason');
            }
            return this._abortReason;
        }
        /**
         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
         */
        get signal() {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('signal');
            }
            if (this._abortController === undefined) {
                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
                throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
            }
            return this._abortController.signal;
        }
        /**
         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
         *
         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
         * normal lifecycle of interactions with the underlying sink.
         */
        error(e = undefined) {
            if (!IsWritableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$2('error');
            }
            const state = this._controlledWritableStream._state;
            if (state !== 'writable') {
                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
                // just treat it as a no-op.
                return;
            }
            WritableStreamDefaultControllerError(this, e);
        }
        /** @internal */
        [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [ErrorSteps]() {
            ResetQueue(this);
        }
    }
    Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: true },
        signal: { enumerable: true },
        error: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: 'WritableStreamDefaultController',
            configurable: true
        });
    }
    // Abstract operations implementing interface required by the WritableStream.
    function IsWritableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
            return false;
        }
        return x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream;
        stream._writableStreamController = controller;
        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._abortReason = undefined;
        controller._abortController = createAbortController();
        controller._started = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._writeAlgorithm = writeAlgorithm;
        controller._closeAlgorithm = closeAlgorithm;
        controller._abortAlgorithm = abortAlgorithm;
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
        const startResult = startAlgorithm();
        const startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, r => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
        });
    }
    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(WritableStreamDefaultController.prototype);
        let startAlgorithm = () => undefined;
        let writeAlgorithm = () => promiseResolvedWith(undefined);
        let closeAlgorithm = () => promiseResolvedWith(undefined);
        let abortAlgorithm = () => promiseResolvedWith(undefined);
        if (underlyingSink.start !== undefined) {
            startAlgorithm = () => underlyingSink.start(controller);
        }
        if (underlyingSink.write !== undefined) {
            writeAlgorithm = chunk => underlyingSink.write(chunk, controller);
        }
        if (underlyingSink.close !== undefined) {
            closeAlgorithm = () => underlyingSink.close();
        }
        if (underlyingSink.abort !== undefined) {
            abortAlgorithm = reason => underlyingSink.abort(reason);
        }
        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = undefined;
        controller._closeAlgorithm = undefined;
        controller._abortAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0);
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
            return controller._strategySizeAlgorithm(chunk);
        }
        catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
        }
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
        }
        catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
        }
        const stream = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    // Abstract operations for the WritableStreamDefaultController.
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        const stream = controller._controlledWritableStream;
        if (!controller._started) {
            return;
        }
        if (stream._inFlightWriteRequest !== undefined) {
            return;
        }
        const state = stream._state;
        if (state === 'erroring') {
            WritableStreamFinishErroring(stream);
            return;
        }
        if (controller._queue.length === 0) {
            return;
        }
        const value = PeekQueueValue(controller);
        if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
        }
        else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
        }
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        if (controller._controlledWritableStream._state === 'writable') {
            WritableStreamDefaultControllerError(controller, error);
        }
    }
    function WritableStreamDefaultControllerProcessClose(controller) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream);
        DequeueValue(controller);
        const sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller);
        uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
        }, reason => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
        });
    }
    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        const stream = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream);
        const sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
                WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, reason => {
            if (stream._state === 'writable') {
                WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
        });
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
    }
    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
    function WritableStreamDefaultControllerError(controller, error) {
        const stream = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller);
        WritableStreamStartErroring(stream, error);
    }
    // Helper functions for the WritableStream.
    function streamBrandCheckException$2(name) {
        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
    }
    // Helper functions for the WritableStreamDefaultController.
    function defaultControllerBrandCheckException$2(name) {
        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
    }
    // Helper functions for the WritableStreamDefaultWriter.
    function defaultWriterBrandCheckException(name) {
        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
    }
    function defaultWriterLockException(name) {
        return new TypeError('Cannot ' + name + ' a stream using a released writer');
    }
    function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise((resolve, reject) => {
            writer._closedPromise_resolve = resolve;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = 'pending';
        });
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer);
        defaultWriterClosedPromiseResolve(writer);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
        if (writer._closedPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._closedPromise);
        writer._closedPromise_reject(reason);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = 'rejected';
    }
    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterClosedPromiseResolve(writer) {
        if (writer._closedPromise_resolve === undefined) {
            return;
        }
        writer._closedPromise_resolve(undefined);
        writer._closedPromise_resolve = undefined;
        writer._closedPromise_reject = undefined;
        writer._closedPromiseState = 'resolved';
    }
    function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise((resolve, reject) => {
            writer._readyPromise_resolve = resolve;
            writer._readyPromise_reject = reject;
        });
        writer._readyPromiseState = 'pending';
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer);
        defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
        if (writer._readyPromise_reject === undefined) {
            return;
        }
        setPromiseIsHandledToTrue(writer._readyPromise);
        writer._readyPromise_reject(reason);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = 'rejected';
    }
    function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
    }
    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterReadyPromiseResolve(writer) {
        if (writer._readyPromise_resolve === undefined) {
            return;
        }
        writer._readyPromise_resolve(undefined);
        writer._readyPromise_resolve = undefined;
        writer._readyPromise_reject = undefined;
        writer._readyPromiseState = 'fulfilled';
    }

    /// <reference lib="dom" />
    const NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;

    /// <reference types="node" />
    function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
            return false;
        }
        try {
            new ctor();
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    function createDOMExceptionPolyfill() {
        // eslint-disable-next-line no-shadow
        const ctor = function DOMException(message, name) {
            this.message = message || '';
            this.name = name || 'Error';
            if (Error.captureStackTrace) {
                Error.captureStackTrace(this, this.constructor);
            }
        };
        ctor.prototype = Object.create(Error.prototype);
        Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });
        return ctor;
    }
    // eslint-disable-next-line no-redeclare
    const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();

    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        const reader = AcquireReadableStreamDefaultReader(source);
        const writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = true;
        let shuttingDown = false;
        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
        let currentWrite = promiseResolvedWith(undefined);
        return newPromise((resolve, reject) => {
            let abortAlgorithm;
            if (signal !== undefined) {
                abortAlgorithm = () => {
                    const error = new DOMException$1('Aborted', 'AbortError');
                    const actions = [];
                    if (!preventAbort) {
                        actions.push(() => {
                            if (dest._state === 'writable') {
                                return WritableStreamAbort(dest, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    if (!preventCancel) {
                        actions.push(() => {
                            if (source._state === 'readable') {
                                return ReadableStreamCancel(source, error);
                            }
                            return promiseResolvedWith(undefined);
                        });
                    }
                    shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);
                };
                if (signal.aborted) {
                    abortAlgorithm();
                    return;
                }
                signal.addEventListener('abort', abortAlgorithm);
            }
            // Using reader and writer, read all chunks from this and write them to dest
            // - Backpressure must be enforced
            // - Shutdown must stop all activity
            function pipeLoop() {
                return newPromise((resolveLoop, rejectLoop) => {
                    function next(done) {
                        if (done) {
                            resolveLoop();
                        }
                        else {
                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid
                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
                            PerformPromiseThen(pipeStep(), next, rejectLoop);
                        }
                    }
                    next(false);
                });
            }
            function pipeStep() {
                if (shuttingDown) {
                    return promiseResolvedWith(true);
                }
                return PerformPromiseThen(writer._readyPromise, () => {
                    return newPromise((resolveRead, rejectRead) => {
                        ReadableStreamDefaultReaderRead(reader, {
                            _chunkSteps: chunk => {
                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                                resolveRead(false);
                            },
                            _closeSteps: () => resolveRead(true),
                            _errorSteps: rejectRead
                        });
                    });
                });
            }
            // Errors must be propagated forward
            isOrBecomesErrored(source, reader._closedPromise, storedError => {
                if (!preventAbort) {
                    shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
                }
                else {
                    shutdown(true, storedError);
                }
            });
            // Errors must be propagated backward
            isOrBecomesErrored(dest, writer._closedPromise, storedError => {
                if (!preventCancel) {
                    shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
                }
                else {
                    shutdown(true, storedError);
                }
            });
            // Closing must be propagated forward
            isOrBecomesClosed(source, reader._closedPromise, () => {
                if (!preventClose) {
                    shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
                }
                else {
                    shutdown();
                }
            });
            // Closing must be propagated backward
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
                const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');
                if (!preventCancel) {
                    shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
                }
                else {
                    shutdown(true, destClosed);
                }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
                // for that too.
                const oldCurrentWrite = currentWrite;
                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
            }
            function isOrBecomesErrored(stream, promise, action) {
                if (stream._state === 'errored') {
                    action(stream._storedError);
                }
                else {
                    uponRejection(promise, action);
                }
            }
            function isOrBecomesClosed(stream, promise, action) {
                if (stream._state === 'closed') {
                    action();
                }
                else {
                    uponFulfillment(promise, action);
                }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), doTheRest);
                }
                else {
                    doTheRest();
                }
                function doTheRest() {
                    uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));
                }
            }
            function shutdown(isError, error) {
                if (shuttingDown) {
                    return;
                }
                shuttingDown = true;
                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
                    uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
                }
                else {
                    finalize(isError, error);
                }
            }
            function finalize(isError, error) {
                WritableStreamDefaultWriterRelease(writer);
                ReadableStreamReaderGenericRelease(reader);
                if (signal !== undefined) {
                    signal.removeEventListener('abort', abortAlgorithm);
                }
                if (isError) {
                    reject(error);
                }
                else {
                    resolve(undefined);
                }
            }
        });
    }

    /**
     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
     *
     * @public
     */
    class ReadableStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
         */
        get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('desiredSize');
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
        }
        /**
         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
         * the stream, but once those are read, the stream will become closed.
         */
        close() {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('close');
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError('The stream is not in a state that permits close');
            }
            ReadableStreamDefaultControllerClose(this);
        }
        enqueue(chunk = undefined) {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('enqueue');
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
                throw new TypeError('The stream is not in a state that permits enqueue');
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
         */
        error(e = undefined) {
            if (!IsReadableStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException$1('error');
            }
            ReadableStreamDefaultControllerError(this, e);
        }
        /** @internal */
        [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
        }
        /** @internal */
        [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
                const chunk = DequeueValue(this);
                if (this._closeRequested && this._queue.length === 0) {
                    ReadableStreamDefaultControllerClearAlgorithms(this);
                    ReadableStreamClose(stream);
                }
                else {
                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
                }
                readRequest._chunkSteps(chunk);
            }
            else {
                ReadableStreamAddReadRequest(stream, readRequest);
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
        }
    }
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: true },
        enqueue: { enumerable: true },
        error: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStreamDefaultController',
            configurable: true
        });
    }
    // Abstract operations for the ReadableStreamDefaultController.
    function IsReadableStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
            return false;
        }
        return x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (!shouldPull) {
            return;
        }
        if (controller._pulling) {
            controller._pullAgain = true;
            return;
        }
        controller._pulling = true;
        const pullPromise = controller._pullAlgorithm();
        uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
                controller._pullAgain = false;
                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
        }, e => {
            ReadableStreamDefaultControllerError(controller, e);
        });
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
        const stream = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
        }
        if (!controller._started) {
            return false;
        }
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
        }
        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        if (desiredSize > 0) {
            return true;
        }
        return false;
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = undefined;
        controller._cancelAlgorithm = undefined;
        controller._strategySizeAlgorithm = undefined;
    }
    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
    function ReadableStreamDefaultControllerClose(controller) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        const stream = controller._controlledReadableStream;
        controller._closeRequested = true;
        if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
        }
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
        }
        const stream = controller._controlledReadableStream;
        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
        }
        else {
            let chunkSize;
            try {
                chunkSize = controller._strategySizeAlgorithm(chunk);
            }
            catch (chunkSizeE) {
                ReadableStreamDefaultControllerError(controller, chunkSizeE);
                throw chunkSizeE;
            }
            try {
                EnqueueValueWithSize(controller, chunk, chunkSize);
            }
            catch (enqueueE) {
                ReadableStreamDefaultControllerError(controller, enqueueE);
                throw enqueueE;
            }
        }
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
        const stream = controller._controlledReadableStream;
        if (stream._state !== 'readable') {
            return;
        }
        ResetQueue(controller);
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamError(stream, e);
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        const state = controller._controlledReadableStream._state;
        if (state === 'errored') {
            return null;
        }
        if (state === 'closed') {
            return 0;
        }
        return controller._strategyHWM - controller._queueTotalSize;
    }
    // This is used in the implementation of TransformStream.
    function ReadableStreamDefaultControllerHasBackpressure(controller) {
        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
        }
        return true;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        const state = controller._controlledReadableStream._state;
        if (!controller._closeRequested && state === 'readable') {
            return true;
        }
        return false;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream;
        controller._queue = undefined;
        controller._queueTotalSize = undefined;
        ResetQueue(controller);
        controller._started = false;
        controller._closeRequested = false;
        controller._pullAgain = false;
        controller._pulling = false;
        controller._strategySizeAlgorithm = sizeAlgorithm;
        controller._strategyHWM = highWaterMark;
        controller._pullAlgorithm = pullAlgorithm;
        controller._cancelAlgorithm = cancelAlgorithm;
        stream._readableStreamController = controller;
        const startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, r => {
            ReadableStreamDefaultControllerError(controller, r);
        });
    }
    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        let startAlgorithm = () => undefined;
        let pullAlgorithm = () => promiseResolvedWith(undefined);
        let cancelAlgorithm = () => promiseResolvedWith(undefined);
        if (underlyingSource.start !== undefined) {
            startAlgorithm = () => underlyingSource.start(controller);
        }
        if (underlyingSource.pull !== undefined) {
            pullAlgorithm = () => underlyingSource.pull(controller);
        }
        if (underlyingSource.cancel !== undefined) {
            cancelAlgorithm = reason => underlyingSource.cancel(reason);
        }
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    }
    // Helper functions for the ReadableStreamDefaultController.
    function defaultControllerBrandCheckException$1(name) {
        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
    }

    function ReadableStreamTee(stream, cloneForBranch2) {
        if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
        }
        return ReadableStreamDefaultTee(stream);
    }
    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
        const reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgain = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise(resolve => {
            resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
            if (reading) {
                readAgain = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const readRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(() => {
                        readAgain = false;
                        const chunk1 = chunk;
                        const chunk2 = chunk;
                        // There is no way to access the cloning code right now in the reference implementation.
                        // If we add one then we'll need an implementation for serializable objects.
                        // if (!canceled2 && cloneForBranch2) {
                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
                        // }
                        if (!canceled1) {
                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgain) {
                            pullAlgorithm();
                        }
                    });
                },
                _closeSteps: () => {
                    reading = false;
                    if (!canceled1) {
                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            // do nothing
        }
        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
        uponRejection(reader._closedPromise, (r) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
                resolveCancelPromise(undefined);
            }
        });
        return [branch1, branch2];
    }
    function ReadableByteStreamTee(stream) {
        let reader = AcquireReadableStreamDefaultReader(stream);
        let reading = false;
        let readAgainForBranch1 = false;
        let readAgainForBranch2 = false;
        let canceled1 = false;
        let canceled2 = false;
        let reason1;
        let reason2;
        let branch1;
        let branch2;
        let resolveCancelPromise;
        const cancelPromise = newPromise(resolve => {
            resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, r => {
                if (thisReader !== reader) {
                    return;
                }
                ReadableByteStreamControllerError(branch1._readableStreamController, r);
                ReadableByteStreamControllerError(branch2._readableStreamController, r);
                if (!canceled1 || !canceled2) {
                    resolveCancelPromise(undefined);
                }
            });
        }
        function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamDefaultReader(stream);
                forwardReaderError(reader);
            }
            const readRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(() => {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        const chunk1 = chunk;
                        let chunk2 = chunk;
                        if (!canceled1 && !canceled2) {
                            try {
                                chunk2 = CloneAsUint8Array(chunk);
                            }
                            catch (cloneE) {
                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                        }
                        if (!canceled1) {
                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                        }
                        if (!canceled2) {
                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        }
                        else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: () => {
                    reading = false;
                    if (!canceled1) {
                        ReadableByteStreamControllerClose(branch1._readableStreamController);
                    }
                    if (!canceled2) {
                        ReadableByteStreamControllerClose(branch2._readableStreamController);
                    }
                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                    }
                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                    }
                    if (!canceled1 || !canceled2) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
                ReadableStreamReaderGenericRelease(reader);
                reader = AcquireReadableStreamBYOBReader(stream);
                forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
                _chunkSteps: chunk => {
                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
                    // successful synchronously-available reads get ahead of asynchronously-available errors.
                    queueMicrotask(() => {
                        readAgainForBranch1 = false;
                        readAgainForBranch2 = false;
                        const byobCanceled = forBranch2 ? canceled2 : canceled1;
                        const otherCanceled = forBranch2 ? canceled1 : canceled2;
                        if (!otherCanceled) {
                            let clonedChunk;
                            try {
                                clonedChunk = CloneAsUint8Array(chunk);
                            }
                            catch (cloneE) {
                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                                return;
                            }
                            if (!byobCanceled) {
                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                            }
                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                        }
                        else if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        reading = false;
                        if (readAgainForBranch1) {
                            pull1Algorithm();
                        }
                        else if (readAgainForBranch2) {
                            pull2Algorithm();
                        }
                    });
                },
                _closeSteps: chunk => {
                    reading = false;
                    const byobCanceled = forBranch2 ? canceled2 : canceled1;
                    const otherCanceled = forBranch2 ? canceled1 : canceled2;
                    if (!byobCanceled) {
                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                    }
                    if (!otherCanceled) {
                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                    }
                    if (chunk !== undefined) {
                        if (!byobCanceled) {
                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                        }
                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                        }
                    }
                    if (!byobCanceled || !otherCanceled) {
                        resolveCancelPromise(undefined);
                    }
                },
                _errorSteps: () => {
                    reading = false;
                }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
            if (reading) {
                readAgainForBranch1 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            }
            else {
                pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(undefined);
        }
        function pull2Algorithm() {
            if (reading) {
                readAgainForBranch2 = true;
                return promiseResolvedWith(undefined);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
                pullWithDefaultReader();
            }
            else {
                pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(undefined);
        }
        function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
                const compositeReason = CreateArrayFromList([reason1, reason2]);
                const cancelResult = ReadableStreamCancel(stream, compositeReason);
                resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
        }
        function startAlgorithm() {
            return;
        }
        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
        forwardReaderError(reader);
        return [branch1, branch2];
    }

    function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        const original = source;
        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
        const pull = original === null || original === void 0 ? void 0 : original.pull;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const type = original === null || original === void 0 ? void 0 : original.type;
        return {
            autoAllocateChunkSize: autoAllocateChunkSize === undefined ?
                undefined :
                convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === undefined ?
                undefined :
                convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === undefined ?
                undefined :
                convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start === undefined ?
                undefined :
                convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)
        };
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
        assertFunction(fn, context);
        return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertReadableStreamType(type, context) {
        type = `${type}`;
        if (type !== 'bytes') {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
        }
        return type;
    }

    function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        const mode = options === null || options === void 0 ? void 0 : options.mode;
        return {
            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
        };
    }
    function convertReadableStreamReaderMode(mode, context) {
        mode = `${mode}`;
        if (mode !== 'byob') {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
        }
        return mode;
    }

    function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
    }

    function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
        const signal = options === null || options === void 0 ? void 0 : options.signal;
        if (signal !== undefined) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
        }
        return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
        };
    }
    function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
        }
    }

    function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
        assertRequiredField(readable, 'readable', 'ReadableWritablePair');
        assertReadableStream(readable, `${context} has member 'readable' that`);
        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
        assertRequiredField(writable, 'writable', 'ReadableWritablePair');
        assertWritableStream(writable, `${context} has member 'writable' that`);
        return { readable, writable };
    }

    /**
     * A readable stream represents a source of data, from which you can read.
     *
     * @public
     */
    class ReadableStream {
        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === undefined) {
                rawUnderlyingSource = null;
            }
            else {
                assertObject(rawUnderlyingSource, 'First parameter');
            }
            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
            InitializeReadableStream(this);
            if (underlyingSource.type === 'bytes') {
                if (strategy.size !== undefined) {
                    throw new RangeError('The strategy for a byte stream cannot have a size function');
                }
                const highWaterMark = ExtractHighWaterMark(strategy, 0);
                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            }
            else {
                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
                const highWaterMark = ExtractHighWaterMark(strategy, 1);
                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
        }
        /**
         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
         */
        get locked() {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('locked');
            }
            return IsReadableStreamLocked(this);
        }
        /**
         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
         *
         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
         * method, which might or might not use it.
         */
        cancel(reason = undefined) {
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1('cancel'));
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
            }
            return ReadableStreamCancel(this, reason);
        }
        getReader(rawOptions = undefined) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('getReader');
            }
            const options = convertReaderOptions(rawOptions, 'First parameter');
            if (options.mode === undefined) {
                return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
        }
        pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('pipeThrough');
            }
            assertRequiredArgument(rawTransform, 1, 'pipeThrough');
            const transform = convertReadableWritablePair(rawTransform, 'First parameter');
            const options = convertPipeOptions(rawOptions, 'Second parameter');
            if (IsReadableStreamLocked(this)) {
                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
            }
            if (IsWritableStreamLocked(transform.writable)) {
                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
        }
        pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
                return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
            }
            if (destination === undefined) {
                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options;
            try {
                options = convertPipeOptions(rawOptions, 'Second parameter');
            }
            catch (e) {
                return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
            }
            if (IsWritableStreamLocked(destination)) {
                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
            }
            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        }
        /**
         * Tees this readable stream, returning a two-element array containing the two resulting branches as
         * new {@link ReadableStream} instances.
         *
         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
         * propagated to the stream's underlying source.
         *
         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
         * this could allow interference between the two branches.
         */
        tee() {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('tee');
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
        }
        values(rawOptions = undefined) {
            if (!IsReadableStream(this)) {
                throw streamBrandCheckException$1('values');
            }
            const options = convertIteratorOptions(rawOptions, 'First parameter');
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
        }
    }
    Object.defineProperties(ReadableStream.prototype, {
        cancel: { enumerable: true },
        getReader: { enumerable: true },
        pipeThrough: { enumerable: true },
        pipeTo: { enumerable: true },
        tee: { enumerable: true },
        values: { enumerable: true },
        locked: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
            value: 'ReadableStream',
            configurable: true
        });
    }
    if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream.prototype.values,
            writable: true,
            configurable: true
        });
    }
    // Abstract operations for the ReadableStream.
    // Throws if and only if startAlgorithm throws.
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableStreamDefaultController.prototype);
        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        return stream;
    }
    // Throws if and only if startAlgorithm throws.
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        const stream = Object.create(ReadableStream.prototype);
        InitializeReadableStream(stream);
        const controller = Object.create(ReadableByteStreamController.prototype);
        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
        return stream;
    }
    function InitializeReadableStream(stream) {
        stream._state = 'readable';
        stream._reader = undefined;
        stream._storedError = undefined;
        stream._disturbed = false;
    }
    function IsReadableStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
            return false;
        }
        return x instanceof ReadableStream;
    }
    function IsReadableStreamLocked(stream) {
        if (stream._reader === undefined) {
            return false;
        }
        return true;
    }
    // ReadableStream API exposed for controllers.
    function ReadableStreamCancel(stream, reason) {
        stream._disturbed = true;
        if (stream._state === 'closed') {
            return promiseResolvedWith(undefined);
        }
        if (stream._state === 'errored') {
            return promiseRejectedWith(stream._storedError);
        }
        ReadableStreamClose(stream);
        const reader = stream._reader;
        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach(readIntoRequest => {
                readIntoRequest._closeSteps(undefined);
            });
            reader._readIntoRequests = new SimpleQueue();
        }
        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop);
    }
    function ReadableStreamClose(stream) {
        stream._state = 'closed';
        const reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseResolve(reader);
        if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(readRequest => {
                readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
        }
    }
    function ReadableStreamError(stream, e) {
        stream._state = 'errored';
        stream._storedError = e;
        const reader = stream._reader;
        if (reader === undefined) {
            return;
        }
        defaultReaderClosedPromiseReject(reader, e);
        if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach(readRequest => {
                readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
        }
        else {
            reader._readIntoRequests.forEach(readIntoRequest => {
                readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
        }
    }
    // Helper functions for the ReadableStream.
    function streamBrandCheckException$1(name) {
        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
    }

    function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
        assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
        return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
    }

    // The size function must not have a prototype property nor be a constructor
    const byteLengthSizeFunction = (chunk) => {
        return chunk.byteLength;
    };
    try {
        Object.defineProperty(byteLengthSizeFunction, 'name', {
            value: 'size',
            configurable: true
        });
    }
    catch (_a) {
        // This property is non-configurable in older browsers, so ignore if this throws.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
    }
    /**
     * A queuing strategy that counts the number of bytes in each chunk.
     *
     * @public
     */
    class ByteLengthQueuingStrategy {
        constructor(options) {
            assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
            options = convertQueuingStrategyInit(options, 'First parameter');
            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException('highWaterMark');
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by returning the value of its `byteLength` property.
         */
        get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
                throw byteLengthBrandCheckException('size');
            }
            return byteLengthSizeFunction;
        }
    }
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: 'ByteLengthQueuingStrategy',
            configurable: true
        });
    }
    // Helper functions for the ByteLengthQueuingStrategy.
    function byteLengthBrandCheckException(name) {
        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
    }
    function IsByteLengthQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
            return false;
        }
        return x instanceof ByteLengthQueuingStrategy;
    }

    // The size function must not have a prototype property nor be a constructor
    const countSizeFunction = () => {
        return 1;
    };
    try {
        Object.defineProperty(countSizeFunction, 'name', {
            value: 'size',
            configurable: true
        });
    }
    catch (_a) {
        // This property is non-configurable in older browsers, so ignore if this throws.
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
    }
    /**
     * A queuing strategy that counts the number of chunks.
     *
     * @public
     */
    class CountQueuingStrategy {
        constructor(options) {
            assertRequiredArgument(options, 1, 'CountQueuingStrategy');
            options = convertQueuingStrategyInit(options, 'First parameter');
            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
        }
        /**
         * Returns the high water mark provided to the constructor.
         */
        get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException('highWaterMark');
            }
            return this._countQueuingStrategyHighWaterMark;
        }
        /**
         * Measures the size of `chunk` by always returning 1.
         * This ensures that the total queue size is a count of the number of chunks in the queue.
         */
        get size() {
            if (!IsCountQueuingStrategy(this)) {
                throw countBrandCheckException('size');
            }
            return countSizeFunction;
        }
    }
    Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: true },
        size: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: 'CountQueuingStrategy',
            configurable: true
        });
    }
    // Helper functions for the CountQueuingStrategy.
    function countBrandCheckException(name) {
        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
    }
    function IsCountQueuingStrategy(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
            return false;
        }
        return x instanceof CountQueuingStrategy;
    }

    function convertTransformer(original, context) {
        assertDictionary(original, context);
        const flush = original === null || original === void 0 ? void 0 : original.flush;
        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
        const start = original === null || original === void 0 ? void 0 : original.start;
        const transform = original === null || original === void 0 ? void 0 : original.transform;
        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
        return {
            flush: flush === undefined ?
                undefined :
                convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start === undefined ?
                undefined :
                convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
            transform: transform === undefined ?
                undefined :
                convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
        };
    }
    function convertTransformerFlushCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertTransformerStartCallback(fn, original, context) {
        assertFunction(fn, context);
        return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertTransformerTransformCallback(fn, original, context) {
        assertFunction(fn, context);
        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }

    // Class TransformStream
    /**
     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
     * In a manner specific to the transform stream in question, writes to the writable side result in new data being
     * made available for reading from the readable side.
     *
     * @public
     */
    class TransformStream {
        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === undefined) {
                rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
            const transformer = convertTransformer(rawTransformer, 'First parameter');
            if (transformer.readableType !== undefined) {
                throw new RangeError('Invalid readableType specified');
            }
            if (transformer.writableType !== undefined) {
                throw new RangeError('Invalid writableType specified');
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise(resolve => {
                startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== undefined) {
                startPromise_resolve(transformer.start(this._transformStreamController));
            }
            else {
                startPromise_resolve(undefined);
            }
        }
        /**
         * The readable side of the transform stream.
         */
        get readable() {
            if (!IsTransformStream(this)) {
                throw streamBrandCheckException('readable');
            }
            return this._readable;
        }
        /**
         * The writable side of the transform stream.
         */
        get writable() {
            if (!IsTransformStream(this)) {
                throw streamBrandCheckException('writable');
            }
            return this._writable;
        }
    }
    Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: true },
        writable: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: 'TransformStream',
            configurable: true
        });
    }
    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
            return startPromise;
        }
        function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
        }
        function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
        }
        function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
        }
        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
        }
        function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(undefined);
        }
        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
        stream._backpressure = undefined;
        stream._backpressureChangePromise = undefined;
        stream._backpressureChangePromise_resolve = undefined;
        TransformStreamSetBackpressure(stream, true);
        stream._transformStreamController = undefined;
    }
    function IsTransformStream(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
            return false;
        }
        return x instanceof TransformStream;
    }
    // This is a no-op if both sides are already errored.
    function TransformStreamError(stream, e) {
        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
        if (stream._backpressure) {
            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
            // _backpressure is set.
            TransformStreamSetBackpressure(stream, false);
        }
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
        // Passes also when called during construction.
        if (stream._backpressureChangePromise !== undefined) {
            stream._backpressureChangePromise_resolve();
        }
        stream._backpressureChangePromise = newPromise(resolve => {
            stream._backpressureChangePromise_resolve = resolve;
        });
        stream._backpressure = backpressure;
    }
    // Class TransformStreamDefaultController
    /**
     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
     *
     * @public
     */
    class TransformStreamDefaultController {
        constructor() {
            throw new TypeError('Illegal constructor');
        }
        /**
         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.
         */
        get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('desiredSize');
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
        }
        enqueue(chunk = undefined) {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('enqueue');
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
        }
        /**
         * Errors both the readable side and the writable side of the controlled transform stream, making all future
         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
         */
        error(reason = undefined) {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('error');
            }
            TransformStreamDefaultControllerError(this, reason);
        }
        /**
         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
         * transformer only needs to consume a portion of the chunks written to the writable side.
         */
        terminate() {
            if (!IsTransformStreamDefaultController(this)) {
                throw defaultControllerBrandCheckException('terminate');
            }
            TransformStreamDefaultControllerTerminate(this);
        }
    }
    Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: true },
        error: { enumerable: true },
        terminate: { enumerable: true },
        desiredSize: { enumerable: true }
    });
    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: 'TransformStreamDefaultController',
            configurable: true
        });
    }
    // Transform Stream Default Controller Abstract Operations
    function IsTransformStreamDefaultController(x) {
        if (!typeIsObject(x)) {
            return false;
        }
        if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
            return false;
        }
        return x instanceof TransformStreamDefaultController;
    }
    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream;
        stream._transformStreamController = controller;
        controller._transformAlgorithm = transformAlgorithm;
        controller._flushAlgorithm = flushAlgorithm;
    }
    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
        const controller = Object.create(TransformStreamDefaultController.prototype);
        let transformAlgorithm = (chunk) => {
            try {
                TransformStreamDefaultControllerEnqueue(controller, chunk);
                return promiseResolvedWith(undefined);
            }
            catch (transformResultE) {
                return promiseRejectedWith(transformResultE);
            }
        };
        let flushAlgorithm = () => promiseResolvedWith(undefined);
        if (transformer.transform !== undefined) {
            transformAlgorithm = chunk => transformer.transform(chunk, controller);
        }
        if (transformer.flush !== undefined) {
            flushAlgorithm = () => transformer.flush(controller);
        }
        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = undefined;
        controller._flushAlgorithm = undefined;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError('Readable side is not in a state that permits enqueue');
        }
        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
        // accept TransformStreamDefaultControllerEnqueue() calls.
        try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        }
        catch (e) {
            // This happens when readableStrategy.size() throws.
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
        }
        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
        }
    }
    function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        const transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, undefined, r => {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
        });
    }
    function TransformStreamDefaultControllerTerminate(controller) {
        const stream = controller._controlledTransformStream;
        const readableController = stream._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        const error = new TypeError('TransformStream terminated');
        TransformStreamErrorWritableAndUnblockWrite(stream, error);
    }
    // TransformStreamDefaultSink Algorithms
    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
        const controller = stream._transformStreamController;
        if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
                const writable = stream._writable;
                const state = writable._state;
                if (state === 'erroring') {
                    throw writable._storedError;
                }
                return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    }
    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
        // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already
        // errored.
        TransformStreamError(stream, reason);
        return promiseResolvedWith(undefined);
    }
    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
        const readable = stream._readable;
        const controller = stream._transformStreamController;
        const flushPromise = controller._flushAlgorithm();
        TransformStreamDefaultControllerClearAlgorithms(controller);
        // Return a promise that is fulfilled with undefined on success.
        return transformPromiseWith(flushPromise, () => {
            if (readable._state === 'errored') {
                throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, r => {
            TransformStreamError(stream, r);
            throw readable._storedError;
        });
    }
    // TransformStreamDefaultSource Algorithms
    function TransformStreamDefaultSourcePullAlgorithm(stream) {
        // Invariant. Enforced by the promises returned by start() and pull().
        TransformStreamSetBackpressure(stream, false);
        // Prevent the next pull() call until there is backpressure.
        return stream._backpressureChangePromise;
    }
    // Helper functions for the TransformStreamDefaultController.
    function defaultControllerBrandCheckException(name) {
        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
    }
    // Helper functions for the TransformStream.
    function streamBrandCheckException(name) {
        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
    }

    exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
    exports.CountQueuingStrategy = CountQueuingStrategy;
    exports.ReadableByteStreamController = ReadableByteStreamController;
    exports.ReadableStream = ReadableStream;
    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
    exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
    exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
    exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
    exports.TransformStream = TransformStream;
    exports.TransformStreamDefaultController = TransformStreamDefaultController;
    exports.WritableStream = WritableStream;
    exports.WritableStreamDefaultController = WritableStreamDefaultController;
    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ponyfill.es2018.js.map


/***/ }),
/* 133 */
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),
/* 134 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: () => (/* binding */ File),
/* harmony export */   FormData: () => (/* binding */ FormData),
/* harmony export */   formDataToBlob: () => (/* binding */ formDataToBlob)
/* harmony export */ });
/* harmony import */ var fetch_blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(128);
/* harmony import */ var fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(135);
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */




var {toStringTag:t,iterator:i,hasInstance:h}=Symbol,
r=Math.random,
m='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),
f=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__["default"]([b],c,b):b]:[a,b+'']),
e=(c,f)=>(f?c:c.replace(/\r?\n|\r/g,'\r\n')).replace(/\n/g,'%0A').replace(/\r/g,'%0D').replace(/"/g,'%22'),
x=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}

const File = fetch_blob_file_js__WEBPACK_IMPORTED_MODULE_1__["default"]

/** @type {typeof globalThis.FormData} */
const FormData = class FormData {
#d=[];
constructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}
get [t]() {return 'FormData'}
[i](){return this.entries()}
static [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}
append(...a){x('append',arguments,2);this.#d.push(f(...a))}
delete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}
get(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}
getAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}
has(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}
forEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}
set(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}
*entries(){yield*this.#d}
*keys(){for(var[a]of this)yield a}
*values(){for(var[,a]of this)yield a}}

/** @param {FormData} F */
function formDataToBlob (F,B=fetch_blob__WEBPACK_IMPORTED_MODULE_0__["default"]){
var b=`${r()}${r()}`.replace(/\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\r\nContent-Disposition: form-data; name="`
F.forEach((v,n)=>typeof v=='string'
?c.push(p+e(n)+`"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, '\r\n')}\r\n`)
:c.push(p+e(n)+`"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type||"application/octet-stream"}\r\n\r\n`, v, '\r\n'))
c.push(`--${b}--`)
return new B(c,{type:"multipart/form-data; boundary="+b})}


/***/ }),
/* 135 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   File: () => (/* binding */ File),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(128);


const _File = class File extends _index_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  #lastModified = 0
  #name = ''

  /**
   * @param {*[]} fileBits
   * @param {string} fileName
   * @param {{lastModified?: number, type?: string}} options
   */// @ts-ignore
  constructor (fileBits, fileName, options = {}) {
    if (arguments.length < 2) {
      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)
    }
    super(fileBits, options)

    if (options === null) options = {}

    // Simulate WebIDL type casting for NaN value in lastModified option.
    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)
    if (!Number.isNaN(lastModified)) {
      this.#lastModified = lastModified
    }

    this.#name = String(fileName)
  }

  get name () {
    return this.#name
  }

  get lastModified () {
    return this.#lastModified
  }

  get [Symbol.toStringTag] () {
    return 'File'
  }

  static [Symbol.hasInstance] (object) {
    return !!object && object instanceof _index_js__WEBPACK_IMPORTED_MODULE_0__["default"] &&
      /^(File)$/.test(object[Symbol.toStringTag])
  }
}

/** @type {typeof globalThis.File} */// @ts-ignore
const File = _File
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (File);


/***/ }),
/* 136 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchError: () => (/* binding */ FetchError)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(137);



/**
 * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError
*/

/**
 * FetchError interface for operational errors
 */
class FetchError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.FetchBaseError {
	/**
	 * @param  {string} message -      Error message for human
	 * @param  {string} [type] -        Error type for machine
	 * @param  {SystemError} [systemError] - For Node.js system error
	 */
	constructor(message, type, systemError) {
		super(message, type);
		// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code
		if (systemError) {
			// eslint-disable-next-line no-multi-assign
			this.code = this.errno = systemError.code;
			this.erroredSysCall = systemError.syscall;
		}
	}
}


/***/ }),
/* 137 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchBaseError: () => (/* binding */ FetchBaseError)
/* harmony export */ });
class FetchBaseError extends Error {
	constructor(message, type) {
		super(message);
		// Hide custom error implementation details from end-users
		Error.captureStackTrace(this, this.constructor);

		this.type = type;
	}

	get name() {
		return this.constructor.name;
	}

	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
}


/***/ }),
/* 138 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAbortSignal: () => (/* binding */ isAbortSignal),
/* harmony export */   isBlob: () => (/* binding */ isBlob),
/* harmony export */   isDomainOrSubdomain: () => (/* binding */ isDomainOrSubdomain),
/* harmony export */   isSameProtocol: () => (/* binding */ isSameProtocol),
/* harmony export */   isURLSearchParameters: () => (/* binding */ isURLSearchParameters)
/* harmony export */ });
/**
 * Is.js
 *
 * Object type checks.
 */

const NAME = Symbol.toStringTag;

/**
 * Check if `obj` is a URLSearchParams object
 * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isURLSearchParameters = object => {
	return (
		typeof object === 'object' &&
		typeof object.append === 'function' &&
		typeof object.delete === 'function' &&
		typeof object.get === 'function' &&
		typeof object.getAll === 'function' &&
		typeof object.has === 'function' &&
		typeof object.set === 'function' &&
		typeof object.sort === 'function' &&
		object[NAME] === 'URLSearchParams'
	);
};

/**
 * Check if `object` is a W3C `Blob` object (which `File` inherits from)
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isBlob = object => {
	return (
		object &&
		typeof object === 'object' &&
		typeof object.arrayBuffer === 'function' &&
		typeof object.type === 'string' &&
		typeof object.stream === 'function' &&
		typeof object.constructor === 'function' &&
		/^(Blob|File)$/.test(object[NAME])
	);
};

/**
 * Check if `obj` is an instance of AbortSignal.
 * @param {*} object - Object to check for
 * @return {boolean}
 */
const isAbortSignal = object => {
	return (
		typeof object === 'object' && (
			object[NAME] === 'AbortSignal' ||
			object[NAME] === 'EventTarget'
		)
	);
};

/**
 * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of
 * the parent domain.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isDomainOrSubdomain = (destination, original) => {
	const orig = new URL(original).hostname;
	const dest = new URL(destination).hostname;

	return orig === dest || orig.endsWith(`.${dest}`);
};

/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isSameProtocol = (destination, original) => {
	const orig = new URL(original).protocol;
	const dest = new URL(destination).protocol;

	return orig === dest;
};


/***/ }),
/* 139 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Response)
/* harmony export */ });
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(140);
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(126);
/* harmony import */ var _utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(141);
/**
 * Response.js
 *
 * Response class provides content decoding
 */





const INTERNALS = Symbol('Response internals');

/**
 * Response class
 *
 * Ref: https://fetch.spec.whatwg.org/#response-class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response extends _body_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
	constructor(body = null, options = {}) {
		super(body, options);

		// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition
		const status = options.status != null ? options.status : 200;

		const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_0__["default"](options.headers);

		if (body !== null && !headers.has('Content-Type')) {
			const contentType = (0,_body_js__WEBPACK_IMPORTED_MODULE_1__.extractContentType)(body, this);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS] = {
			type: 'default',
			url: options.url,
			status,
			statusText: options.statusText || '',
			headers,
			counter: options.counter,
			highWaterMark: options.highWaterMark
		};
	}

	get type() {
		return this[INTERNALS].type;
	}

	get url() {
		return this[INTERNALS].url || '';
	}

	get status() {
		return this[INTERNALS].status;
	}

	/**
	 * Convenience property representing if the request ended normally
	 */
	get ok() {
		return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
	}

	get redirected() {
		return this[INTERNALS].counter > 0;
	}

	get statusText() {
		return this[INTERNALS].statusText;
	}

	get headers() {
		return this[INTERNALS].headers;
	}

	get highWaterMark() {
		return this[INTERNALS].highWaterMark;
	}

	/**
	 * Clone this response
	 *
	 * @return  Response
	 */
	clone() {
		return new Response((0,_body_js__WEBPACK_IMPORTED_MODULE_1__.clone)(this, this.highWaterMark), {
			type: this.type,
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected,
			size: this.size,
			highWaterMark: this.highWaterMark
		});
	}

	/**
	 * @param {string} url    The URL that the new response is to originate from.
	 * @param {number} status An optional status code for the response (e.g., 302.)
	 * @returns {Response}    A Response object.
	 */
	static redirect(url, status = 302) {
		if (!(0,_utils_is_redirect_js__WEBPACK_IMPORTED_MODULE_2__.isRedirect)(status)) {
			throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
		}

		return new Response(null, {
			headers: {
				location: new URL(url).toString()
			},
			status
		});
	}

	static error() {
		const response = new Response(null, {status: 0, statusText: ''});
		response[INTERNALS].type = 'error';
		return response;
	}

	static json(data = undefined, init = {}) {
		const body = JSON.stringify(data);

		if (body === undefined) {
			throw new TypeError('data is not JSON serializable');
		}

		const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_0__["default"](init && init.headers);

		if (!headers.has('content-type')) {
			headers.set('content-type', 'application/json');
		}

		return new Response(body, {
			...init,
			headers
		});
	}

	get [Symbol.toStringTag]() {
		return 'Response';
	}
}

Object.defineProperties(Response.prototype, {
	type: {enumerable: true},
	url: {enumerable: true},
	status: {enumerable: true},
	ok: {enumerable: true},
	redirected: {enumerable: true},
	statusText: {enumerable: true},
	headers: {enumerable: true},
	clone: {enumerable: true}
});


/***/ }),
/* 140 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Headers),
/* harmony export */   fromRawHeaders: () => (/* binding */ fromRawHeaders)
/* harmony export */ });
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(127);
/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(120);
/**
 * Headers.js
 *
 * Headers class offers convenient helpers
 */




/* c8 ignore next 9 */
const validateHeaderName = typeof node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderName === 'function' ?
	node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderName :
	name => {
		if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
			const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
			Object.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});
			throw error;
		}
	};

/* c8 ignore next 9 */
const validateHeaderValue = typeof node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderValue === 'function' ?
	node_http__WEBPACK_IMPORTED_MODULE_1__.validateHeaderValue :
	(name, value) => {
		if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
			const error = new TypeError(`Invalid character in header content ["${name}"]`);
			Object.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});
			throw error;
		}
	};

/**
 * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
 */

/**
 * This Fetch API interface allows you to perform various actions on HTTP request and response headers.
 * These actions include retrieving, setting, adding to, and removing.
 * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
 * You can add to this using methods like append() (see Examples.)
 * In all methods of this interface, header names are matched by case-insensitive byte sequence.
 *
 */
class Headers extends URLSearchParams {
	/**
	 * Headers class
	 *
	 * @constructor
	 * @param {HeadersInit} [init] - Response headers
	 */
	constructor(init) {
		// Validate and normalize init object in [name, value(s)][]
		/** @type {string[][]} */
		let result = [];
		if (init instanceof Headers) {
			const raw = init.raw();
			for (const [name, values] of Object.entries(raw)) {
				result.push(...values.map(value => [name, value]));
			}
		} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq
			// No op
		} else if (typeof init === 'object' && !node_util__WEBPACK_IMPORTED_MODULE_0__.types.isBoxedPrimitive(init)) {
			const method = init[Symbol.iterator];
			// eslint-disable-next-line no-eq-null, eqeqeq
			if (method == null) {
				// Record<ByteString, ByteString>
				result.push(...Object.entries(init));
			} else {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// Sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				result = [...init]
					.map(pair => {
						if (
							typeof pair !== 'object' || node_util__WEBPACK_IMPORTED_MODULE_0__.types.isBoxedPrimitive(pair)
						) {
							throw new TypeError('Each header pair must be an iterable object');
						}

						return [...pair];
					}).map(pair => {
						if (pair.length !== 2) {
							throw new TypeError('Each header pair must be a name/value tuple');
						}

						return [...pair];
					});
			}
		} else {
			throw new TypeError('Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');
		}

		// Validate and lowercase
		result =
			result.length > 0 ?
				result.map(([name, value]) => {
					validateHeaderName(name);
					validateHeaderValue(name, String(value));
					return [String(name).toLowerCase(), String(value)];
				}) :
				undefined;

		super(result);

		// Returning a Proxy that will lowercase key names, validate parameters and sort keys
		// eslint-disable-next-line no-constructor-return
		return new Proxy(this, {
			get(target, p, receiver) {
				switch (p) {
					case 'append':
					case 'set':
						return (name, value) => {
							validateHeaderName(name);
							validateHeaderValue(name, String(value));
							return URLSearchParams.prototype[p].call(
								target,
								String(name).toLowerCase(),
								String(value)
							);
						};

					case 'delete':
					case 'has':
					case 'getAll':
						return name => {
							validateHeaderName(name);
							return URLSearchParams.prototype[p].call(
								target,
								String(name).toLowerCase()
							);
						};

					case 'keys':
						return () => {
							target.sort();
							return new Set(URLSearchParams.prototype.keys.call(target)).keys();
						};

					default:
						return Reflect.get(target, p, receiver);
				}
			}
		});
		/* c8 ignore next */
	}

	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}

	toString() {
		return Object.prototype.toString.call(this);
	}

	get(name) {
		const values = this.getAll(name);
		if (values.length === 0) {
			return null;
		}

		let value = values.join(', ');
		if (/^content-encoding$/i.test(name)) {
			value = value.toLowerCase();
		}

		return value;
	}

	forEach(callback, thisArg = undefined) {
		for (const name of this.keys()) {
			Reflect.apply(callback, thisArg, [this.get(name), name, this]);
		}
	}

	* values() {
		for (const name of this.keys()) {
			yield this.get(name);
		}
	}

	/**
	 * @type {() => IterableIterator<[string, string]>}
	 */
	* entries() {
		for (const name of this.keys()) {
			yield [name, this.get(name)];
		}
	}

	[Symbol.iterator]() {
		return this.entries();
	}

	/**
	 * Node-fetch non-spec method
	 * returning all headers and their values as array
	 * @returns {Record<string, string[]>}
	 */
	raw() {
		return [...this.keys()].reduce((result, key) => {
			result[key] = this.getAll(key);
			return result;
		}, {});
	}

	/**
	 * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
	 */
	[Symbol.for('nodejs.util.inspect.custom')]() {
		return [...this.keys()].reduce((result, key) => {
			const values = this.getAll(key);
			// Http.request() only supports string as Host header.
			// This hack makes specifying custom Host header possible.
			if (key === 'host') {
				result[key] = values[0];
			} else {
				result[key] = values.length > 1 ? values : values[0];
			}

			return result;
		}, {});
	}
}

/**
 * Re-shaping object for Web IDL tests
 * Only need to do it for overridden methods
 */
Object.defineProperties(
	Headers.prototype,
	['get', 'entries', 'forEach', 'values'].reduce((result, property) => {
		result[property] = {enumerable: true};
		return result;
	}, {})
);

/**
 * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
 * not conform to HTTP grammar productions.
 * @param {import('http').IncomingMessage['rawHeaders']} headers
 */
function fromRawHeaders(headers = []) {
	return new Headers(
		headers
			// Split into pairs
			.reduce((result, value, index, array) => {
				if (index % 2 === 0) {
					result.push(array.slice(index, index + 2));
				}

				return result;
			}, [])
			.filter(([name, value]) => {
				try {
					validateHeaderName(name);
					validateHeaderValue(name, String(value));
					return true;
				} catch {
					return false;
				}
			})

	);
}


/***/ }),
/* 141 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isRedirect: () => (/* binding */ isRedirect)
/* harmony export */ });
const redirectStatus = new Set([301, 302, 303, 307, 308]);

/**
 * Redirect code matching
 *
 * @param {number} code - Status code
 * @return {boolean}
 */
const isRedirect = code => {
	return redirectStatus.has(code);
};


/***/ }),
/* 142 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Request),
/* harmony export */   getNodeRequestOptions: () => (/* binding */ getNodeRequestOptions)
/* harmony export */ });
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(127);
/* harmony import */ var _headers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(140);
/* harmony import */ var _body_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(126);
/* harmony import */ var _utils_is_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(138);
/* harmony import */ var _utils_get_search_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(144);
/* harmony import */ var _utils_referrer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(145);
/**
 * Request.js
 *
 * Request class contains server only options
 *
 * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
 */









const INTERNALS = Symbol('Request internals');

/**
 * Check if `obj` is an instance of Request.
 *
 * @param  {*} object
 * @return {boolean}
 */
const isRequest = object => {
	return (
		typeof object === 'object' &&
		typeof object[INTERNALS] === 'object'
	);
};

const doBadDataWarn = (0,node_util__WEBPACK_IMPORTED_MODULE_1__.deprecate)(() => {},
	'.data is not a valid RequestInit property, use .body instead',
	'https://github.com/node-fetch/node-fetch/issues/1000 (request)');

/**
 * Request class
 *
 * Ref: https://fetch.spec.whatwg.org/#request-class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request extends _body_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
	constructor(input, init = {}) {
		let parsedURL;

		// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)
		if (isRequest(input)) {
			parsedURL = new URL(input.url);
		} else {
			parsedURL = new URL(input);
			input = {};
		}

		if (parsedURL.username !== '' || parsedURL.password !== '') {
			throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
		}

		let method = init.method || input.method || 'GET';
		if (/^(delete|get|head|options|post|put)$/i.test(method)) {
			method = method.toUpperCase();
		}

		if (!isRequest(init) && 'data' in init) {
			doBadDataWarn();
		}

		// eslint-disable-next-line no-eq-null, eqeqeq
		if ((init.body != null || (isRequest(input) && input.body !== null)) &&
			(method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		const inputBody = init.body ?
			init.body :
			(isRequest(input) && input.body !== null ?
				(0,_body_js__WEBPACK_IMPORTED_MODULE_3__.clone)(input) :
				null);

		super(inputBody, {
			size: init.size || input.size || 0
		});

		const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_2__["default"](init.headers || input.headers || {});

		if (inputBody !== null && !headers.has('Content-Type')) {
			const contentType = (0,_body_js__WEBPACK_IMPORTED_MODULE_3__.extractContentType)(inputBody, this);
			if (contentType) {
				headers.set('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ?
			input.signal :
			null;
		if ('signal' in init) {
			signal = init.signal;
		}

		// eslint-disable-next-line no-eq-null, eqeqeq
		if (signal != null && !(0,_utils_is_js__WEBPACK_IMPORTED_MODULE_4__.isAbortSignal)(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');
		}

		// §5.4, Request constructor steps, step 15.1
		// eslint-disable-next-line no-eq-null, eqeqeq
		let referrer = init.referrer == null ? input.referrer : init.referrer;
		if (referrer === '') {
			// §5.4, Request constructor steps, step 15.2
			referrer = 'no-referrer';
		} else if (referrer) {
			// §5.4, Request constructor steps, step 15.3.1, 15.3.2
			const parsedReferrer = new URL(referrer);
			// §5.4, Request constructor steps, step 15.3.3, 15.3.4
			referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;
		} else {
			referrer = undefined;
		}

		this[INTERNALS] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal,
			referrer
		};

		// Node-fetch-only options
		this.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;
		this.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
		this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
		this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;

		// §5.4, Request constructor steps, step 16.
		// Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy
		this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';
	}

	/** @returns {string} */
	get method() {
		return this[INTERNALS].method;
	}

	/** @returns {string} */
	get url() {
		return (0,node_url__WEBPACK_IMPORTED_MODULE_0__.format)(this[INTERNALS].parsedURL);
	}

	/** @returns {Headers} */
	get headers() {
		return this[INTERNALS].headers;
	}

	get redirect() {
		return this[INTERNALS].redirect;
	}

	/** @returns {AbortSignal} */
	get signal() {
		return this[INTERNALS].signal;
	}

	// https://fetch.spec.whatwg.org/#dom-request-referrer
	get referrer() {
		if (this[INTERNALS].referrer === 'no-referrer') {
			return '';
		}

		if (this[INTERNALS].referrer === 'client') {
			return 'about:client';
		}

		if (this[INTERNALS].referrer) {
			return this[INTERNALS].referrer.toString();
		}

		return undefined;
	}

	get referrerPolicy() {
		return this[INTERNALS].referrerPolicy;
	}

	set referrerPolicy(referrerPolicy) {
		this[INTERNALS].referrerPolicy = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_6__.validateReferrerPolicy)(referrerPolicy);
	}

	/**
	 * Clone this request
	 *
	 * @return  Request
	 */
	clone() {
		return new Request(this);
	}

	get [Symbol.toStringTag]() {
		return 'Request';
	}
}

Object.defineProperties(Request.prototype, {
	method: {enumerable: true},
	url: {enumerable: true},
	headers: {enumerable: true},
	redirect: {enumerable: true},
	clone: {enumerable: true},
	signal: {enumerable: true},
	referrer: {enumerable: true},
	referrerPolicy: {enumerable: true}
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param {Request} request - A Request instance
 * @return The options object to be passed to http.request
 */
const getNodeRequestOptions = request => {
	const {parsedURL} = request[INTERNALS];
	const headers = new _headers_js__WEBPACK_IMPORTED_MODULE_2__["default"](request[INTERNALS].headers);

	// Fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body === null && /^(post|put)$/i.test(request.method)) {
		contentLengthValue = '0';
	}

	if (request.body !== null) {
		const totalBytes = (0,_body_js__WEBPACK_IMPORTED_MODULE_3__.getTotalBytes)(request);
		// Set Content-Length if totalBytes is a number (that is not NaN)
		if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {
			contentLengthValue = String(totalBytes);
		}
	}

	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// 4.1. Main fetch, step 2.6
	// > If request's referrer policy is the empty string, then set request's referrer policy to the
	// > default referrer policy.
	if (request.referrerPolicy === '') {
		request.referrerPolicy = _utils_referrer_js__WEBPACK_IMPORTED_MODULE_6__.DEFAULT_REFERRER_POLICY;
	}

	// 4.1. Main fetch, step 2.7
	// > If request's referrer is not "no-referrer", set request's referrer to the result of invoking
	// > determine request's referrer.
	if (request.referrer && request.referrer !== 'no-referrer') {
		request[INTERNALS].referrer = (0,_utils_referrer_js__WEBPACK_IMPORTED_MODULE_6__.determineRequestsReferrer)(request);
	} else {
		request[INTERNALS].referrer = 'no-referrer';
	}

	// 4.5. HTTP-network-or-cache fetch, step 6.9
	// > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized
	// >  and isomorphic encoded, to httpRequest's header list.
	if (request[INTERNALS].referrer instanceof URL) {
		headers.set('Referer', request.referrer);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip, deflate, br');
	}

	let {agent} = request;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	const search = (0,_utils_get_search_js__WEBPACK_IMPORTED_MODULE_5__.getSearch)(parsedURL);

	// Pass the full URL directly to request(), but overwrite the following
	// options:
	const options = {
		// Overwrite search to retain trailing ? (issue #776)
		path: parsedURL.pathname + search,
		// The following options are not expressed in the URL
		method: request.method,
		headers: headers[Symbol.for('nodejs.util.inspect.custom')](),
		insecureHTTPParser: request.insecureHTTPParser,
		agent
	};

	return {
		/** @type {URL} */
		parsedURL,
		options
	};
};


/***/ }),
/* 143 */
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),
/* 144 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSearch: () => (/* binding */ getSearch)
/* harmony export */ });
const getSearch = parsedURL => {
	if (parsedURL.search) {
		return parsedURL.search;
	}

	const lastOffset = parsedURL.href.length - 1;
	const hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');
	return parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';
};


/***/ }),
/* 145 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_REFERRER_POLICY: () => (/* binding */ DEFAULT_REFERRER_POLICY),
/* harmony export */   ReferrerPolicy: () => (/* binding */ ReferrerPolicy),
/* harmony export */   determineRequestsReferrer: () => (/* binding */ determineRequestsReferrer),
/* harmony export */   isOriginPotentiallyTrustworthy: () => (/* binding */ isOriginPotentiallyTrustworthy),
/* harmony export */   isUrlPotentiallyTrustworthy: () => (/* binding */ isUrlPotentiallyTrustworthy),
/* harmony export */   parseReferrerPolicyFromHeader: () => (/* binding */ parseReferrerPolicyFromHeader),
/* harmony export */   stripURLForUseAsAReferrer: () => (/* binding */ stripURLForUseAsAReferrer),
/* harmony export */   validateReferrerPolicy: () => (/* binding */ validateReferrerPolicy)
/* harmony export */ });
/* harmony import */ var node_net__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(146);


/**
 * @external URL
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
 */

/**
 * @module utils/referrer
 * @private
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}
 * @param {string} URL
 * @param {boolean} [originOnly=false]
 */
function stripURLForUseAsAReferrer(url, originOnly = false) {
	// 1. If url is null, return no referrer.
	if (url == null) { // eslint-disable-line no-eq-null, eqeqeq
		return 'no-referrer';
	}

	url = new URL(url);

	// 2. If url's scheme is a local scheme, then return no referrer.
	if (/^(about|blob|data):$/.test(url.protocol)) {
		return 'no-referrer';
	}

	// 3. Set url's username to the empty string.
	url.username = '';

	// 4. Set url's password to null.
	// Note: `null` appears to be a mistake as this actually results in the password being `"null"`.
	url.password = '';

	// 5. Set url's fragment to null.
	// Note: `null` appears to be a mistake as this actually results in the fragment being `"#null"`.
	url.hash = '';

	// 6. If the origin-only flag is true, then:
	if (originOnly) {
		// 6.1. Set url's path to null.
		// Note: `null` appears to be a mistake as this actually results in the path being `"/null"`.
		url.pathname = '';

		// 6.2. Set url's query to null.
		// Note: `null` appears to be a mistake as this actually results in the query being `"?null"`.
		url.search = '';
	}

	// 7. Return url.
	return url;
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}
 */
const ReferrerPolicy = new Set([
	'',
	'no-referrer',
	'no-referrer-when-downgrade',
	'same-origin',
	'origin',
	'strict-origin',
	'origin-when-cross-origin',
	'strict-origin-when-cross-origin',
	'unsafe-url'
]);

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}
 */
const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}
 * @param {string} referrerPolicy
 * @returns {string} referrerPolicy
 */
function validateReferrerPolicy(referrerPolicy) {
	if (!ReferrerPolicy.has(referrerPolicy)) {
		throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
	}

	return referrerPolicy;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isOriginPotentiallyTrustworthy(url) {
	// 1. If origin is an opaque origin, return "Not Trustworthy".
	// Not applicable

	// 2. Assert: origin is a tuple origin.
	// Not for implementations

	// 3. If origin's scheme is either "https" or "wss", return "Potentially Trustworthy".
	if (/^(http|ws)s:$/.test(url.protocol)) {
		return true;
	}

	// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return "Potentially Trustworthy".
	const hostIp = url.host.replace(/(^\[)|(]$)/g, '');
	const hostIPVersion = (0,node_net__WEBPACK_IMPORTED_MODULE_0__.isIP)(hostIp);

	if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
		return true;
	}

	if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
		return true;
	}

	// 5. If origin's host component is "localhost" or falls within ".localhost", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return "Potentially Trustworthy".
	// We are returning FALSE here because we cannot ensure conformance to
	// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
	if (url.host === 'localhost' || url.host.endsWith('.localhost')) {
		return false;
	}

	// 6. If origin's scheme component is file, return "Potentially Trustworthy".
	if (url.protocol === 'file:') {
		return true;
	}

	// 7. If origin's scheme component is one which the user agent considers to be authenticated, return "Potentially Trustworthy".
	// Not supported

	// 8. If origin has been configured as a trustworthy origin, return "Potentially Trustworthy".
	// Not supported

	// 9. Return "Not Trustworthy".
	return false;
}

/**
 * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}
 * @param {external:URL} url
 * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
 */
function isUrlPotentiallyTrustworthy(url) {
	// 1. If url is "about:blank" or "about:srcdoc", return "Potentially Trustworthy".
	if (/^about:(blank|srcdoc)$/.test(url)) {
		return true;
	}

	// 2. If url's scheme is "data", return "Potentially Trustworthy".
	if (url.protocol === 'data:') {
		return true;
	}

	// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were
	// created. Therefore, blobs created in a trustworthy origin will themselves be potentially
	// trustworthy.
	if (/^(blob|filesystem):$/.test(url.protocol)) {
		return true;
	}

	// 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.
	return isOriginPotentiallyTrustworthy(url);
}

/**
 * Modifies the referrerURL to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerURLCallback
 * @param {external:URL} referrerURL
 * @returns {external:URL} modified referrerURL
 */

/**
 * Modifies the referrerOrigin to enforce any extra security policy considerations.
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7
 * @callback module:utils/referrer~referrerOriginCallback
 * @param {external:URL} referrerOrigin
 * @returns {external:URL} modified referrerOrigin
 */

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}
 * @param {Request} request
 * @param {object} o
 * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
 * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
 * @returns {external:URL} Request's referrer
 */
function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {
	// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for
	// these cases:
	// > Note: If request's referrer is "no-referrer", Fetch will not call into this algorithm.
	// > Note: If request's referrer policy is the empty string, Fetch will not call into this
	// > algorithm.
	if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {
		return null;
	}

	// 1. Let policy be request's associated referrer policy.
	const policy = request.referrerPolicy;

	// 2. Let environment be request's client.
	// not applicable to node.js

	// 3. Switch on request's referrer:
	if (request.referrer === 'about:client') {
		return 'no-referrer';
	}

	// "a URL": Let referrerSource be request's referrer.
	const referrerSource = request.referrer;

	// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.
	let referrerURL = stripURLForUseAsAReferrer(referrerSource);

	// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the
	//    origin-only flag set to true.
	let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);

	// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set
	//    referrerURL to referrerOrigin.
	if (referrerURL.toString().length > 4096) {
		referrerURL = referrerOrigin;
	}

	// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary
	//    policy considerations in the interests of minimizing data leakage. For example, the user
	//    agent could strip the URL down to an origin, modify its host, replace it with an empty
	//    string, etc.
	if (referrerURLCallback) {
		referrerURL = referrerURLCallback(referrerURL);
	}

	if (referrerOriginCallback) {
		referrerOrigin = referrerOriginCallback(referrerOrigin);
	}

	// 8.Execute the statements corresponding to the value of policy:
	const currentURL = new URL(request.url);

	switch (policy) {
		case 'no-referrer':
			return 'no-referrer';

		case 'origin':
			return referrerOrigin;

		case 'unsafe-url':
			return referrerURL;

		case 'strict-origin':
			// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 2. Return referrerOrigin.
			return referrerOrigin.toString();

		case 'strict-origin-when-cross-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 3. Return referrerOrigin.
			return referrerOrigin;

		case 'same-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// 2. Return no referrer.
			return 'no-referrer';

		case 'origin-when-cross-origin':
			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
			//    return referrerURL.
			if (referrerURL.origin === currentURL.origin) {
				return referrerURL;
			}

			// Return referrerOrigin.
			return referrerOrigin;

		case 'no-referrer-when-downgrade':
			// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
			//    potentially trustworthy URL, then return no referrer.
			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
				return 'no-referrer';
			}

			// 2. Return referrerURL.
			return referrerURL;

		default:
			throw new TypeError(`Invalid referrerPolicy: ${policy}`);
	}
}

/**
 * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}
 * @param {Headers} headers Response headers
 * @returns {string} policy
 */
function parseReferrerPolicyFromHeader(headers) {
	// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`
	//    and response’s header list.
	const policyTokens = (headers.get('referrer-policy') || '').split(/[,\s]+/);

	// 2. Let policy be the empty string.
	let policy = '';

	// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty
	//    string, then set policy to token.
	// Note: This algorithm loops over multiple policy values to allow deployment of new policy
	// values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.
	for (const token of policyTokens) {
		if (token && ReferrerPolicy.has(token)) {
			policy = token;
		}
	}

	// 4. Return policy.
	return policy;
}


/***/ }),
/* 146 */
/***/ ((module) => {

"use strict";
module.exports = require("node:net");

/***/ }),
/* 147 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortError: () => (/* binding */ AbortError)
/* harmony export */ });
/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(137);


/**
 * AbortError interface for cancelled requests
 */
class AbortError extends _base_js__WEBPACK_IMPORTED_MODULE_0__.FetchBaseError {
	constructor(message, type = 'aborted') {
		super(message, type);
	}
}


/***/ }),
/* 148 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blob: () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   File: () => (/* reexport safe */ _file_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   blobFrom: () => (/* binding */ blobFrom),
/* harmony export */   blobFromSync: () => (/* binding */ blobFromSync),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fileFrom: () => (/* binding */ fileFrom),
/* harmony export */   fileFromSync: () => (/* binding */ fileFromSync)
/* harmony export */ });
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(149);
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(150);
/* harmony import */ var node_domexception__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(151);
/* harmony import */ var _file_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(135);
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(128);







const { stat } = node_fs__WEBPACK_IMPORTED_MODULE_0__.promises

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const blobFromSync = (path, type) => fromBlob((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type)

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<Blob>}
 */
const blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 * @returns {Promise<File>}
 */
const fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))

/**
 * @param {string} path filepath on the disk
 * @param {string} [type] mimetype to use
 */
const fileFromSync = (path, type) => fromFile((0,node_fs__WEBPACK_IMPORTED_MODULE_0__.statSync)(path), path, type)

// @ts-ignore
const fromBlob = (stat, path, type = '') => new _index_js__WEBPACK_IMPORTED_MODULE_4__["default"]([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], { type })

// @ts-ignore
const fromFile = (stat, path, type = '') => new _file_js__WEBPACK_IMPORTED_MODULE_3__["default"]([new BlobDataItem({
  path,
  size: stat.size,
  lastModified: stat.mtimeMs,
  start: 0
})], (0,node_path__WEBPACK_IMPORTED_MODULE_1__.basename)(path), { type, lastModified: stat.mtimeMs })

/**
 * This is a blob backed up by a file on the disk
 * with minium requirement. Its wrapped around a Blob as a blobPart
 * so you have no direct access to this.
 *
 * @private
 */
class BlobDataItem {
  #path
  #start

  constructor (options) {
    this.#path = options.path
    this.#start = options.start
    this.size = options.size
    this.lastModified = options.lastModified
  }

  /**
   * Slicing arguments is first validated and formatted
   * to not be out of range by Blob.prototype.slice
   */
  slice (start, end) {
    return new BlobDataItem({
      path: this.#path,
      lastModified: this.lastModified,
      size: end - start,
      start: this.#start + start
    })
  }

  async * stream () {
    const { mtimeMs } = await stat(this.#path)
    if (mtimeMs > this.lastModified) {
      throw new node_domexception__WEBPACK_IMPORTED_MODULE_2__('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')
    }
    yield * (0,node_fs__WEBPACK_IMPORTED_MODULE_0__.createReadStream)(this.#path, {
      start: this.#start,
      end: this.#start + this.size - 1
    })
  }

  get [Symbol.toStringTag] () {
    return 'Blob'
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blobFromSync);



/***/ }),
/* 149 */
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),
/* 150 */
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),
/* 151 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */

if (!globalThis.DOMException) {
  try {
    const { MessageChannel } = __webpack_require__(152),
    port = new MessageChannel().port1,
    ab = new ArrayBuffer()
    port.postMessage(ab, [ab, ab])
  } catch (err) {
    err.constructor.name === 'DOMException' && (
      globalThis.DOMException = err.constructor
    )
  }
}

module.exports = globalThis.DOMException


/***/ }),
/* 152 */
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DagTreeView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const tmp = __webpack_require__(154);
const fs = __webpack_require__(3);
const DagTreeDataProvider_1 = __webpack_require__(156);
const DagView_1 = __webpack_require__(158);
const DailyDagRunView_1 = __webpack_require__(193);
const DagRunView_1 = __webpack_require__(180);
const ui = __webpack_require__(2);
const MessageHub = __webpack_require__(159);
const Session_1 = __webpack_require__(5);
const DagLogView_1 = __webpack_require__(178);
const Telemetry_1 = __webpack_require__(9);
class DagTreeView {
    constructor() {
        this.FilterString = '';
        this.ShowOnlyActive = true;
        this.ShowOnlyFavorite = false;
        this.FavoriteDags = [];
        ui.logToOutput('DagTreeView.constructor Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.constructor.called');
        this.treeDataProvider = new DagTreeDataProvider_1.DagTreeDataProvider();
        this.view = vscode.window.createTreeView('dagTreeView', { treeDataProvider: this.treeDataProvider, showCollapseAll: true });
        this.loadState();
        Session_1.Session.Current.Context.subscriptions.push(this.view);
        Session_1.Session.Current.Context.subscriptions.push({ dispose: () => this.dispose() });
        DagTreeView.Current = this;
        this.setFilterMessage();
        this.refresh();
    }
    dispose() {
        ui.logToOutput('DagTreeView.dispose Started');
        if (this.dagStatusInterval) {
            clearInterval(this.dagStatusInterval);
        }
    }
    async refresh() {
        ui.logToOutput('DagTreeView.refresh Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.refresh.called');
        if (!Session_1.Session.Current.Api) {
            this.treeDataProvider.dagList = [];
            this.treeDataProvider.refresh();
            return;
        }
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Window,
            title: "Airflow: Loading...",
        }, async (progress) => {
            progress.report({ increment: 0 });
            await this.loadDags();
        });
        await this.getImportErrors();
    }
    viewDagView(node) {
        ui.logToOutput('DagTreeView.viewDagView Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewDagView.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        DagView_1.DagView.render(node.DagId);
    }
    async addToFavDAG(node) {
        ui.logToOutput('DagTreeView.addToFavDAG Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.addToFavDAG.called');
        node.IsFav = true;
        if (!this.FavoriteDags.includes(node.DagId)) {
            this.FavoriteDags.push(node.DagId);
        }
        this.treeDataProvider.refresh();
    }
    async deleteFromFavDAG(node) {
        ui.logToOutput('DagTreeView.deleteFromFavDAG Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.deleteFromFavDAG.called');
        node.IsFav = false;
        this.FavoriteDags = this.FavoriteDags.filter(d => d !== node.DagId);
        this.treeDataProvider.refresh();
    }
    createAndOpenTempFile(content, prefix, extension) {
        const tmpFile = tmp.fileSync({ mode: 0o644, prefix, postfix: extension });
        fs.appendFileSync(tmpFile.name, content);
        ui.openFile(tmpFile.name);
    }
    startDagStatusInterval() {
        if (!this.dagStatusInterval) {
            this.dagStatusInterval = setInterval(() => {
                void this.refreshRunningDagState(this).catch((err) => ui.logToOutput('refreshRunningDagState Error', err));
            }, 10 * 1000);
        }
    }
    handleTriggerSuccess(node, responseTrigger) {
        node.LatestDagRunId = responseTrigger['dag_run_id'];
        node.LatestDagState = responseTrigger['state'];
        node.refreshUI();
        this.treeDataProvider.refresh();
        this.startDagStatusInterval();
        MessageHub.DagTriggered(this, node.DagId, node.LatestDagRunId);
    }
    async triggerDag(node) {
        ui.logToOutput('DagTreeView.triggerDag Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.triggerDag.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (node.IsPaused) {
            ui.showWarningMessage('Dag is PAUSED !!!');
            return;
        }
        if (node.isDagRunning()) {
            ui.showWarningMessage('Dag is ALREADY RUNNING !!!');
            return;
        }
        const result = await Session_1.Session.Current.Api.triggerDag(node.DagId);
        if (result.isSuccessful) {
            this.handleTriggerSuccess(node, result.result);
        }
    }
    async refreshRunningDagState(dagTreeView) {
        ui.logToOutput('DagTreeView.refreshRunningDagState Started');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        let noDagIsRunning = true;
        for (const node of dagTreeView.treeDataProvider.visibleDagList) {
            if (node.isDagRunning()) {
                noDagIsRunning = false;
                const result = await Session_1.Session.Current.Api.getDagRun(node.DagId, node.LatestDagRunId);
                if (result.isSuccessful) {
                    node.LatestDagState = result.result['state'];
                    node.refreshUI();
                }
                else {
                    node.LatestDagRunId = '';
                    node.LatestDagState = '';
                }
            }
            dagTreeView.treeDataProvider.refresh();
        }
        if (noDagIsRunning && dagTreeView.dagStatusInterval) {
            clearInterval(dagTreeView.dagStatusInterval);
            dagTreeView.dagStatusInterval = undefined;
            //ui.showInfoMessage('All Dag Run(s) Completed');
            ui.logToOutput('All Dag Run(s) Completed');
        }
    }
    async triggerDagWConfig(node) {
        ui.logToOutput('DagTreeView.triggerDagWConfig Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.triggerDagWConfig.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        let triggerDagConfig = await vscode.window.showInputBox({ placeHolder: 'Enter Configuration JSON (Optional, must be a dict object) or Press Enter' });
        if (!triggerDagConfig) {
            triggerDagConfig = "{}";
        }
        if (triggerDagConfig !== undefined) {
            const result = await Session_1.Session.Current.Api.triggerDag(node.DagId, triggerDagConfig);
            if (result.isSuccessful) {
                this.handleTriggerSuccess(node, result.result);
            }
        }
    }
    async checkAllDagsRunState() {
        ui.logToOutput('DagTreeView.checkAllDagsRunState Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.checkAllDagsRunState.called');
        if (!this.treeDataProvider) {
            return;
        }
        for (const node of this.treeDataProvider.visibleDagList) {
            if (!node.IsPaused) {
                this.checkDagRunState(node);
            }
        }
    }
    async notifyDagStateWithDagId(dagId, dagRunId, dagState) {
        ui.logToOutput('DagTreeView.notifyDagStateWithDagId Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.notifyDagStateWithDagId.called');
        if (!this.treeDataProvider) {
            return;
        }
        for (const node of this.treeDataProvider.visibleDagList) {
            if (node.DagId === dagId) {
                //this.checkDagRunState(node);
                node.LatestDagRunId = dagRunId;
                node.LatestDagState = dagState;
                node.refreshUI();
                this.treeDataProvider.refresh();
                if (node.isDagRunning()) {
                    this.startDagStatusInterval();
                }
            }
        }
    }
    async checkDagRunState(node) {
        ui.logToOutput('DagTreeView.checkDagRunState Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.checkDagRunState.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (!node) {
            return;
        }
        if (node.IsPaused) {
            ui.showWarningMessage(node.DagId + 'Dag is PAUSED');
            return;
        }
        const result = await Session_1.Session.Current.Api.getLastDagRun(node.DagId);
        if (result.isSuccessful) {
            node.LatestDagRunId = result.result.dag_run_id;
            node.LatestDagState = result.result.state;
            node.refreshUI();
            this.treeDataProvider.refresh();
            if (node.isDagRunning()) {
                this.startDagStatusInterval();
            }
        }
    }
    async pauseDAG(node) {
        ui.logToOutput('DagTreeView.pauseDAG Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.pauseDAG.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (node.IsPaused) {
            ui.showWarningMessage(node.DagId + 'Dag is already PAUSED');
            return;
        }
        const result = await Session_1.Session.Current.Api.pauseDag(node.DagId, true);
        if (result.isSuccessful) {
            node.IsPaused = true;
            node.refreshUI();
            this.treeDataProvider.refresh();
            MessageHub.DagPaused(this, node.DagId);
        }
    }
    async notifyDagPaused(dagId) {
        ui.logToOutput('DagTreeView.notifyDagPaused Started');
        this.refresh();
    }
    async notifyDagUnPaused(dagId) {
        ui.logToOutput('DagTreeView.notifyDagUnPaused Started');
        this.refresh();
    }
    async unPauseDAG(node) {
        ui.logToOutput('DagTreeView.unPauseDAG Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.unPauseDAG.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (!node.IsPaused) {
            ui.showInfoMessage(node.DagId + 'Dag is already UNPAUSED');
            return;
        }
        const result = await Session_1.Session.Current.Api.pauseDag(node.DagId, false);
        if (result.isSuccessful) {
            node.IsPaused = false;
            node.refreshUI();
            this.treeDataProvider.refresh();
            MessageHub.DagUnPaused(this, node.DagId);
        }
    }
    async cancelDagRun(node) {
        ui.logToOutput('DagTreeView.cancelDagRun Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.cancelDagRun.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (!node.isDagRunning()) {
            ui.showWarningMessage('No running DAG to cancel');
            return;
        }
        if (!node.LatestDagRunId) {
            ui.showWarningMessage('No DAG run ID found');
            return;
        }
        const result = await Session_1.Session.Current.Api.cancelDagRun(node.DagId, node.LatestDagRunId);
        if (result.isSuccessful) {
            node.LatestDagState = 'failed';
            node.refreshUI();
            this.treeDataProvider.refresh();
            //ui.showInfoMessage(`DAG Run ${node.LatestDagRunId} cancelled`);
            MessageHub.DagRunCancelled(this, node.DagId, node.LatestDagRunId);
        }
    }
    async lastDAGRunLog(node) {
        ui.logToOutput('DagTreeView.lastDAGRunLog Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.lastDAGRunLog.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        // const result = await Session.Current.Api.getLastDagRunLogText(node.DagId);
        // if (result.isSuccessful) {
        // 	this.createAndOpenTempFile(result.result, node.DagId, '.log');
        // }
        DagLogView_1.DagLogView.render(node.DagId, node.LatestDagRunId);
    }
    async dagSourceCode(node) {
        ui.logToOutput('DagTreeView.dagSourceCode Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.dagSourceCode.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getSourceCode(node.DagId, node.FileToken);
        if (result.isSuccessful) {
            this.createAndOpenTempFile(result.result, node.DagId, '.py');
        }
        else {
            ui.logToOutput(result.result);
            ui.showErrorMessage(result.result);
        }
    }
    async showDagInfo(node) {
        ui.logToOutput('DagTreeView.showDagInfo Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.showDagInfo.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getDagInfo(node.DagId);
        if (result.isSuccessful) {
            this.createAndOpenTempFile(JSON.stringify(result.result, null, 2), node.DagId + '_info', '.json');
        }
        else {
            ui.logToOutput(result.result);
            ui.showErrorMessage('Failed to fetch DAG info');
        }
    }
    async filter() {
        ui.logToOutput('DagTreeView.filter Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.filter.called');
        const filterStringTemp = await vscode.window.showInputBox({ value: this.FilterString, placeHolder: 'Enter your filters seperated by comma' });
        if (filterStringTemp === undefined) {
            return;
        }
        this.FilterString = filterStringTemp;
        this.treeDataProvider.refresh();
        this.setFilterMessage();
        this.saveState();
    }
    async showOnlyActive() {
        ui.logToOutput('DagTreeView.showOnlyActive Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.showOnlyActive.called');
        this.ShowOnlyActive = !this.ShowOnlyActive;
        this.treeDataProvider.refresh();
        this.setFilterMessage();
        this.saveState();
    }
    async showOnlyFavorite() {
        ui.logToOutput('DagTreeView.showOnlyFavorite Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.showOnlyFavorite.called');
        this.ShowOnlyFavorite = !this.ShowOnlyFavorite;
        this.treeDataProvider.refresh();
        this.setFilterMessage();
        this.saveState();
    }
    async addServer() {
        ui.logToOutput('DagTreeView.addServer Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.addServer.called');
        const apiUrlTemp = await vscode.window.showInputBox({ value: 'http://localhost:8080/api/v2', placeHolder: 'API Full URL (Exp:http://localhost:8080/api/v2)' });
        if (!apiUrlTemp) {
            return;
        }
        const userNameTemp = await vscode.window.showInputBox({ placeHolder: 'User Name' });
        if (!userNameTemp) {
            return;
        }
        const passwordTemp = await vscode.window.showInputBox({ placeHolder: 'Password' });
        if (!passwordTemp) {
            return;
        }
        const newServer = { apiUrl: apiUrlTemp, apiUserName: userNameTemp, apiPassword: passwordTemp };
        let result = await Session_1.Session.Current.TestServer(newServer);
        if (!result) {
            ui.showErrorMessage("Failed to connect to server.");
            return;
        }
        Session_1.Session.Current.AddServer(newServer);
        Session_1.Session.Current.SetServer(newServer);
        this.refresh();
    }
    async removeServer() {
        ui.logToOutput('DagTreeView.removeServer Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.removeServer.called');
        if (Session_1.Session.Current.ServerList.length === 0) {
            return;
        }
        const items = Session_1.Session.Current.ServerList.map(s => `${s.apiUrl} - ${s.apiUserName}`);
        const selected = await vscode.window.showQuickPick(items, { canPickMany: false, placeHolder: 'Select To Remove' });
        if (!selected) {
            return;
        }
        const selectedItems = selected.split(' - ');
        if (selectedItems[0]) {
            Session_1.Session.Current.RemoveServer(selectedItems[0], selectedItems[1]);
            ui.showInfoMessage("Server removed.");
        }
    }
    async connectServer() {
        ui.logToOutput('DagTreeView.connectServer Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.connectServer.called');
        if (Session_1.Session.Current.ServerList.length === 0) {
            this.addServer();
            return;
        }
        const items = [];
        for (const s of Session_1.Session.Current.ServerList) {
            items.push(s.apiUrl + " - " + s.apiUserName);
        }
        const selected = await vscode.window.showQuickPick(items, { canPickMany: false, placeHolder: 'Select To Connect' });
        if (!selected) {
            return;
        }
        const selectedItems = selected.split(' - ');
        if (selectedItems[0]) {
            const server = Session_1.Session.Current.GetServer(selectedItems[0], selectedItems[1]);
            if (server) {
                let result = await Session_1.Session.Current.TestServer(server);
                if (result) {
                    Session_1.Session.Current.SetServer(server);
                    this.refresh();
                }
                else {
                    ui.showErrorMessage("Failed to connect to server.");
                }
            }
        }
    }
    async clearServers() {
        ui.logToOutput('DagTreeView.clearServers Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.clearServers.called');
        Session_1.Session.Current.ClearServers();
        this.treeDataProvider.dagList = undefined;
        this.treeDataProvider.refresh();
        ui.showInfoMessage("Server List Cleared");
    }
    async loadDags() {
        ui.logToOutput('DagTreeView.loadDags Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.loadDags.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        this.treeDataProvider.dagList = undefined;
        const result = await Session_1.Session.Current.Api.getDagList();
        if (result.isSuccessful) {
            this.treeDataProvider.dagList = result.result;
            this.treeDataProvider.loadDagTreeItemsFromApiResponse();
        }
        this.treeDataProvider.refresh();
        this.setViewTitle();
    }
    async loadLatestRunStatusForAllDags() {
        ui.logToOutput('DagTreeView.loadLatestRunStatusForAllDags Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.loadLatestRunStatusForAllDags.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        // Fetch latest run status for each visible DAG (limit to avoid too many API calls)
        const visibleDags = this.treeDataProvider.visibleDagList.slice(0, 50); // Limit to first 50 DAGs
        for (const dagItem of visibleDags) {
            if (!dagItem.IsPaused) {
                try {
                    const runResult = await Session_1.Session.Current.Api.getLastDagRun(dagItem.DagId);
                    if (runResult.isSuccessful && runResult.result) {
                        dagItem.LatestDagRunId = runResult.result.dag_run_id;
                        dagItem.LatestDagState = runResult.result.state;
                        dagItem.refreshUI();
                    }
                }
                catch (error) {
                    // Silently continue if a DAG's last run can't be fetched
                    ui.logToOutput(`Failed to fetch last run for ${dagItem.DagId}`, error);
                }
            }
        }
        this.treeDataProvider.refresh();
    }
    async setViewTitle() {
        if (Session_1.Session.Current.Server) {
            this.view.title = Session_1.Session.Current.Server.apiUrl + " - " + Session_1.Session.Current.Server.apiUserName;
        }
        else {
            this.view.title = "Airflow";
        }
    }
    async getImportErrors() {
        ui.logToOutput('DagTreeView.getImportErrors Started');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getImportErrors();
        if (result.isSuccessful) {
            const importErrors = result.result;
            if (importErrors.total_entries > 0) {
                ui.showOutputMessage(result.result, "Import Dag Errors! Check Output Panel");
            }
        }
    }
    saveState() {
        ui.logToOutput('DagTreeView.saveState Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.saveState.called');
        try {
            Session_1.Session.Current.Context.globalState.update('FilterString', this.FilterString);
            Session_1.Session.Current.Context.globalState.update('ShowOnlyActive', this.ShowOnlyActive);
            Session_1.Session.Current.Context.globalState.update('ShowOnlyFavorite', this.ShowOnlyFavorite);
            Session_1.Session.Current.Context.globalState.update('FavoriteDags', this.FavoriteDags);
        }
        catch (error) {
            ui.logToOutput("dagTreeView.saveState Error !!!", error);
        }
    }
    setFilterMessage() {
        if (Session_1.Session.Current.Server) {
            this.view.message = this.getBoolenSign(this.ShowOnlyFavorite) + 'Fav, ' + this.getBoolenSign(this.ShowOnlyActive) + 'Active, Filter : ' + this.FilterString;
        }
    }
    getBoolenSign(variable) {
        return variable ? "✓" : "𐄂";
    }
    loadState() {
        ui.logToOutput('DagTreeView.loadState Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.loadState.called');
        try {
            const filterStringTemp = Session_1.Session.Current.Context.globalState.get('FilterString') || '';
            if (filterStringTemp) {
                this.FilterString = filterStringTemp;
                this.setFilterMessage();
            }
            const ShowOnlyActiveTemp = Session_1.Session.Current.Context.globalState.get('ShowOnlyActive');
            if (ShowOnlyActiveTemp !== undefined) {
                this.ShowOnlyActive = ShowOnlyActiveTemp;
            }
            const ShowOnlyFavoriteTemp = Session_1.Session.Current.Context.globalState.get('ShowOnlyFavorite');
            if (ShowOnlyFavoriteTemp !== undefined) {
                this.ShowOnlyFavorite = ShowOnlyFavoriteTemp;
            }
            const FavoriteDagsTemp = Session_1.Session.Current.Context.globalState.get('FavoriteDags');
            if (FavoriteDagsTemp !== undefined) {
                this.FavoriteDags = FavoriteDagsTemp;
            }
        }
        catch (error) {
            ui.logToOutput("dagTreeView.loadState Error !!!", error);
        }
    }
    async viewConnections() {
        ui.logToOutput('DagTreeView.viewConnections Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewConnections.called');
        if (Session_1.Session.Current.Api) {
            const { ConnectionsView } = await Promise.resolve().then(() => __webpack_require__(184));
            ConnectionsView.render();
        }
    }
    async viewVariables() {
        ui.logToOutput('DagTreeView.viewVariables Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewVariables.called');
        if (Session_1.Session.Current.Api) {
            const { VariablesView } = await Promise.resolve().then(() => __webpack_require__(186));
            VariablesView.render();
        }
    }
    async viewProviders() {
        ui.logToOutput('DagTreeView.viewProviders Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewProviders.called');
        if (Session_1.Session.Current.Api) {
            const { ProvidersView } = await Promise.resolve().then(() => __webpack_require__(182));
            ProvidersView.render();
        }
    }
    async viewConfigs() {
        ui.logToOutput('DagTreeView.viewConfigs Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewConfigs.called');
        if (Session_1.Session.Current.Api) {
            const { ConfigsView } = await Promise.resolve().then(() => __webpack_require__(188));
            ConfigsView.render();
        }
    }
    async viewPlugins() {
        ui.logToOutput('DagTreeView.viewPlugins Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewPlugins.called');
        if (Session_1.Session.Current.Api) {
            const { PluginsView } = await Promise.resolve().then(() => __webpack_require__(190));
            PluginsView.render();
        }
    }
    async viewDagRuns() {
        ui.logToOutput('DagTreeView.viewDagRuns Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewDagRuns.called');
        if (Session_1.Session.Current.Api) {
            DailyDagRunView_1.DailyDagRunView.render();
        }
    }
    async viewDagRunHistory() {
        ui.logToOutput('DagTreeView.viewDagRunHistory Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewDagRunHistory.called');
        if (Session_1.Session.Current.Api) {
            DagRunView_1.DagRunView.render();
        }
    }
    async viewServerHealth() {
        ui.logToOutput('DagTreeView.viewServerHealth Started');
        Telemetry_1.Telemetry.Current.send('dagTreeView.viewServerHealth.called');
        if (Session_1.Session.Current.Api) {
            const { ServerHealthView } = await Promise.resolve().then(() => __webpack_require__(192));
            ServerHealthView.render();
        }
    }
}
exports.DagTreeView = DagTreeView;


/***/ }),
/* 154 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

/*
 * Module dependencies.
 */
const fs = __webpack_require__(3);
const os = __webpack_require__(12);
const path = __webpack_require__(4);
const crypto = __webpack_require__(155);
const _c = { fs: fs.constants, os: os.constants };

/*
 * The working inner variables.
 */
const // the random characters to choose from
  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
  TEMPLATE_PATTERN = /XXXXXX/,
  DEFAULT_TRIES = 3,
  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),
  // constants are off on the windows platform and will not match the actual errno codes
  IS_WIN32 = os.platform() === 'win32',
  EBADF = _c.EBADF || _c.os.errno.EBADF,
  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,
  DIR_MODE = 0o700 /* 448 */,
  FILE_MODE = 0o600 /* 384 */,
  EXIT = 'exit',
  // this will hold the objects need to be removed on exit
  _removeObjects = [],
  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);

let _gracefulCleanup = false;

/**
 * Recursively remove a directory and its contents.
 *
 * @param {string} dirPath path of directory to remove
 * @param {Function} callback
 * @private
 */
function rimraf(dirPath, callback) {
  return fs.rm(dirPath, { recursive: true }, callback);
}

/**
 * Recursively remove a directory and its contents, synchronously.
 *
 * @param {string} dirPath path of directory to remove
 * @private
 */
function FN_RIMRAF_SYNC(dirPath) {
  return fs.rmSync(dirPath, { recursive: true });
}

/**
 * Gets a temporary file name.
 *
 * @param {(Options|tmpNameCallback)} options options or callback
 * @param {?tmpNameCallback} callback the callback function
 */
function tmpName(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  _assertAndSanitizeOptions(opts, function (err, sanitizedOptions) {
    if (err) return cb(err);

    let tries = sanitizedOptions.tries;
    (function _getUniqueName() {
      try {
        const name = _generateTmpName(sanitizedOptions);

        // check whether the path exists then retry if needed
        fs.stat(name, function (err) {
          /* istanbul ignore else */
          if (!err) {
            /* istanbul ignore else */
            if (tries-- > 0) return _getUniqueName();

            return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
          }

          cb(null, name);
        });
      } catch (err) {
        cb(err);
      }
    })();
  });
}

/**
 * Synchronous version of tmpName.
 *
 * @param {Object} options
 * @returns {string} the generated random name
 * @throws {Error} if the options are invalid or could not generate a filename
 */
function tmpNameSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const sanitizedOptions = _assertAndSanitizeOptionsSync(opts);

  let tries = sanitizedOptions.tries;
  do {
    const name = _generateTmpName(sanitizedOptions);
    try {
      fs.statSync(name);
    } catch (e) {
      return name;
    }
  } while (tries-- > 0);

  throw new Error('Could not get a unique tmp filename, max tries reached');
}

/**
 * Creates and opens a temporary file.
 *
 * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
 * @param {?fileCallback} callback
 */
function file(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create and open the file
    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
      /* istanbu ignore else */
      if (err) return cb(err);

      if (opts.discardDescriptor) {
        return fs.close(fd, function _discardCallback(possibleErr) {
          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
        });
      } else {
        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
        // about the descriptor
        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
      }
    });
  });
}

/**
 * Synchronous version of file.
 *
 * @param {Options} options
 * @returns {FileSyncObject} object consists of name, fd and removeCallback
 * @throws {Error} if cannot create a file
 */
function fileSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
  const name = tmpNameSync(opts);
  let fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
  /* istanbul ignore else */
  if (opts.discardDescriptor) {
    fs.closeSync(fd);
    fd = undefined;
  }

  return {
    name: name,
    fd: fd,
    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
  };
}

/**
 * Creates a temporary directory.
 *
 * @param {(Options|dirCallback)} options the options or the callback function
 * @param {?dirCallback} callback
 */
function dir(options, callback) {
  const args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create the directory
    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
      /* istanbul ignore else */
      if (err) return cb(err);

      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
    });
  });
}

/**
 * Synchronous version of dir.
 *
 * @param {Options} options
 * @returns {DirSyncObject} object consists of name and removeCallback
 * @throws {Error} if it cannot create a directory
 */
function dirSync(options) {
  const args = _parseArguments(options),
    opts = args[0];

  const name = tmpNameSync(opts);
  fs.mkdirSync(name, opts.mode || DIR_MODE);

  return {
    name: name,
    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
  };
}

/**
 * Removes files asynchronously.
 *
 * @param {Object} fdPath
 * @param {Function} next
 * @private
 */
function _removeFileAsync(fdPath, next) {
  const _handler = function (err) {
    if (err && !_isENOENT(err)) {
      // reraise any unanticipated error
      return next(err);
    }
    next();
  };

  if (0 <= fdPath[0])
    fs.close(fdPath[0], function () {
      fs.unlink(fdPath[1], _handler);
    });
  else fs.unlink(fdPath[1], _handler);
}

/**
 * Removes files synchronously.
 *
 * @param {Object} fdPath
 * @private
 */
function _removeFileSync(fdPath) {
  let rethrownException = null;
  try {
    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
  } catch (e) {
    // reraise any unanticipated error
    if (!_isEBADF(e) && !_isENOENT(e)) throw e;
  } finally {
    try {
      fs.unlinkSync(fdPath[1]);
    } catch (e) {
      // reraise any unanticipated error
      if (!_isENOENT(e)) rethrownException = e;
    }
  }
  if (rethrownException !== null) {
    throw rethrownException;
  }
}

/**
 * Prepares the callback for removal of the temporary file.
 *
 * Returns either a sync callback or a async callback depending on whether
 * fileSync or file was called, which is expressed by the sync parameter.
 *
 * @param {string} name the path of the file
 * @param {number} fd file descriptor
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {fileCallback | fileCallbackSync}
 * @private
 */
function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);

  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Prepares the callback for removal of the temporary directory.
 *
 * Returns either a sync callback or a async callback depending on whether
 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
 *
 * @param {string} name
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {Function} the callback
 * @private
 */
function _prepareTmpDirRemoveCallback(name, opts, sync) {
  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * The cleanup callback is save to be called multiple times.
 * Subsequent invocations will be ignored.
 *
 * @param {Function} removeFunction
 * @param {string} fileOrDirName
 * @param {boolean} sync
 * @param {cleanupCallbackSync?} cleanupCallbackSync
 * @returns {cleanupCallback | cleanupCallbackSync}
 * @private
 */
function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
  let called = false;

  // if sync is true, the next parameter will be ignored
  return function _cleanupCallback(next) {
    /* istanbul ignore else */
    if (!called) {
      // remove cleanupCallback from cache
      const toRemove = cleanupCallbackSync || _cleanupCallback;
      const index = _removeObjects.indexOf(toRemove);
      /* istanbul ignore else */
      if (index >= 0) _removeObjects.splice(index, 1);

      called = true;
      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
        return removeFunction(fileOrDirName);
      } else {
        return removeFunction(fileOrDirName, next || function () {});
      }
    }
  };
}

/**
 * The garbage collector.
 *
 * @private
 */
function _garbageCollector() {
  /* istanbul ignore else */
  if (!_gracefulCleanup) return;

  // the function being called removes itself from _removeObjects,
  // loop until _removeObjects is empty
  while (_removeObjects.length) {
    try {
      _removeObjects[0]();
    } catch (e) {
      // already removed?
    }
  }
}

/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param {number} howMany
 * @returns {string} the generated random name
 * @private
 */
function _randomChars(howMany) {
  let value = [],
    rnd = null;

  // make sure that we do not fail because we ran out of entropy
  try {
    rnd = crypto.randomBytes(howMany);
  } catch (e) {
    rnd = crypto.pseudoRandomBytes(howMany);
  }

  for (let i = 0; i < howMany; i++) {
    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
  }

  return value.join('');
}

/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param {Object} obj
 * @returns {boolean} true if the object is undefined
 * @private
 */
function _isUndefined(obj) {
  return typeof obj === 'undefined';
}

/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param {(Options|null|undefined|Function)} options
 * @param {?Function} callback
 * @returns {Array} parsed arguments
 * @private
 */
function _parseArguments(options, callback) {
  /* istanbul ignore else */
  if (typeof options === 'function') {
    return [{}, options];
  }

  /* istanbul ignore else */
  if (_isUndefined(options)) {
    return [{}, callback];
  }

  // copy options so we do not leak the changes we make internally
  const actualOptions = {};
  for (const key of Object.getOwnPropertyNames(options)) {
    actualOptions[key] = options[key];
  }

  return [actualOptions, callback];
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @private
 */
function _resolvePath(name, tmpDir, cb) {
  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);

  fs.stat(pathToResolve, function (err) {
    if (err) {
      fs.realpath(path.dirname(pathToResolve), function (err, parentDir) {
        if (err) return cb(err);

        cb(null, path.join(parentDir, path.basename(pathToResolve)));
      });
    } else {
      fs.realpath(pathToResolve, cb);
    }
  });
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @private
 */
function _resolvePathSync(name, tmpDir) {
  const pathToResolve = path.isAbsolute(name) ? name : path.join(tmpDir, name);

  try {
    fs.statSync(pathToResolve);
    return fs.realpathSync(pathToResolve);
  } catch (_err) {
    const parentDir = fs.realpathSync(path.dirname(pathToResolve));

    return path.join(parentDir, path.basename(pathToResolve));
  }
}

/**
 * Generates a new temporary name.
 *
 * @param {Object} opts
 * @returns {string} the new random name according to opts
 * @private
 */
function _generateTmpName(opts) {
  const tmpDir = opts.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(opts.name)) {
    return path.join(tmpDir, opts.dir, opts.name);
  }

  /* istanbul ignore else */
  if (!_isUndefined(opts.template)) {
    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
  }

  // prefix and postfix
  const name = [
    opts.prefix ? opts.prefix : 'tmp',
    '-',
    process.pid,
    '-',
    _randomChars(12),
    opts.postfix ? '-' + opts.postfix : ''
  ].join('');

  return path.join(tmpDir, opts.dir, name);
}

/**
 * Asserts and sanitizes the basic options.
 *
 * @private
 */
function _assertOptionsBase(options) {
  if (!_isUndefined(options.name)) {
    const name = options.name;

    // assert that name is not absolute and does not contain a path
    if (path.isAbsolute(name)) throw new Error(`name option must not contain an absolute path, found "${name}".`);

    // must not fail on valid .<name> or ..<name> or similar such constructs
    const basename = path.basename(name);
    if (basename === '..' || basename === '.' || basename !== name)
      throw new Error(`name option must not contain a path, found "${name}".`);
  }

  /* istanbul ignore else */
  if (!_isUndefined(options.template) && !options.template.match(TEMPLATE_PATTERN)) {
    throw new Error(`Invalid template, found "${options.template}".`);
  }

  /* istanbul ignore else */
  if ((!_isUndefined(options.tries) && isNaN(options.tries)) || options.tries < 0) {
    throw new Error(`Invalid tries, found "${options.tries}".`);
  }

  // if a name was specified we will try once
  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
  options.keep = !!options.keep;
  options.detachDescriptor = !!options.detachDescriptor;
  options.discardDescriptor = !!options.discardDescriptor;
  options.unsafeCleanup = !!options.unsafeCleanup;

  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;
  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;
}

/**
 * Gets the relative directory to tmpDir.
 *
 * @private
 */
function _getRelativePath(option, name, tmpDir, cb) {
  if (_isUndefined(name)) return cb(null);

  _resolvePath(name, tmpDir, function (err, resolvedPath) {
    if (err) return cb(err);

    const relativePath = path.relative(tmpDir, resolvedPath);

    if (!resolvedPath.startsWith(tmpDir)) {
      return cb(new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`));
    }

    cb(null, relativePath);
  });
}

/**
 * Gets the relative path to tmpDir.
 *
 * @private
 */
function _getRelativePathSync(option, name, tmpDir) {
  if (_isUndefined(name)) return;

  const resolvedPath = _resolvePathSync(name, tmpDir);
  const relativePath = path.relative(tmpDir, resolvedPath);

  if (!resolvedPath.startsWith(tmpDir)) {
    throw new Error(`${option} option must be relative to "${tmpDir}", found "${relativePath}".`);
  }

  return relativePath;
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @private
 */
function _assertAndSanitizeOptions(options, cb) {
  _getTmpDir(options, function (err, tmpDir) {
    if (err) return cb(err);

    options.tmpdir = tmpDir;

    try {
      _assertOptionsBase(options, tmpDir);
    } catch (err) {
      return cb(err);
    }

    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
    _getRelativePath('dir', options.dir, tmpDir, function (err, dir) {
      if (err) return cb(err);

      options.dir = _isUndefined(dir) ? '' : dir;

      // sanitize further if template is relative to options.dir
      _getRelativePath('template', options.template, tmpDir, function (err, template) {
        if (err) return cb(err);

        options.template = template;

        cb(null, options);
      });
    });
  });
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @private
 */
function _assertAndSanitizeOptionsSync(options) {
  const tmpDir = (options.tmpdir = _getTmpDirSync(options));

  _assertOptionsBase(options, tmpDir);

  const dir = _getRelativePathSync('dir', options.dir, tmpDir);
  options.dir = _isUndefined(dir) ? '' : dir;

  options.template = _getRelativePathSync('template', options.template, tmpDir);

  return options;
}

/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isEBADF(error) {
  return _isExpectedError(error, -EBADF, 'EBADF');
}

/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isENOENT(error) {
  return _isExpectedError(error, -ENOENT, 'ENOENT');
}

/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code {string}
 *   error.errno {number} any numerical value will be negated
 *
 * CAVEAT
 *
 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
 * is no different here.
 *
 * @param {SystemError} error
 * @param {number} errno
 * @param {string} code
 * @private
 */
function _isExpectedError(error, errno, code) {
  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
}

/**
 * Sets the graceful cleanup.
 *
 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
 * object removals.
 */
function setGracefulCleanup() {
  _gracefulCleanup = true;
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 */
function _getTmpDir(options, cb) {
  return fs.realpath((options && options.tmpdir) || os.tmpdir(), cb);
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 */
function _getTmpDirSync(options) {
  return fs.realpathSync((options && options.tmpdir) || os.tmpdir());
}

// Install process exit listener
process.addListener(EXIT, _garbageCollector);

/**
 * Configuration options.
 *
 * @typedef {Object} Options
 * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
 * @property {?number} tries the number of tries before give up the name generation
 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
 * @property {?string} template the "mkstemp" like filename template
 * @property {?string} name fixed name relative to tmpdir or the specified dir option
 * @property {?string} dir tmp directory relative to the root tmp directory in use
 * @property {?string} prefix prefix for the generated name
 * @property {?string} postfix postfix for the generated name
 * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
 * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
 */

/**
 * @typedef {Object} FileSyncObject
 * @property {string} name the name of the file
 * @property {string} fd the file descriptor or -1 if the fd has been discarded
 * @property {fileCallback} removeCallback the callback function to remove the file
 */

/**
 * @typedef {Object} DirSyncObject
 * @property {string} name the name of the directory
 * @property {fileCallback} removeCallback the callback function to remove the directory
 */

/**
 * @callback tmpNameCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 */

/**
 * @callback fileCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback fileCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * @callback dirCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback dirCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallbackSync
 */

/**
 * Callback function for function composition.
 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */

// exporting all the needed methods

// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
Object.defineProperty(module.exports, "tmpdir", ({
  enumerable: true,
  configurable: false,
  get: function () {
    return _getTmpDirSync();
  }
}));

module.exports.dir = dir;
module.exports.dirSync = dirSync;

module.exports.file = file;
module.exports.fileSync = fileSync;

module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;

module.exports.setGracefulCleanup = setGracefulCleanup;


/***/ }),
/* 155 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DagTreeDataProvider = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const DagTreeItem_1 = __webpack_require__(157);
const DagTreeView_1 = __webpack_require__(153);
class DagTreeDataProvider {
    constructor() {
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.dagTreeItemList = [];
        this.visibleDagList = [];
    }
    refresh() {
        this._onDidChangeTreeData.fire();
    }
    loadDagTreeItemsFromApiResponse() {
        this.dagTreeItemList = [];
        if (this.dagList) {
            for (var dag of this.dagList) {
                if (dag) {
                    let treeItem = new DagTreeItem_1.DagTreeItem(dag);
                    this.dagTreeItemList.push(treeItem);
                }
            }
        }
    }
    getChildren(element) {
        if (!element) {
            this.visibleDagList = this.getVisibleDagList();
            return Promise.resolve(this.visibleDagList);
        }
        return Promise.resolve([]);
    }
    getVisibleDagList() {
        var result = [];
        for (var node of this.dagTreeItemList) {
            if (DagTreeView_1.DagTreeView.Current.FilterString && !node.doesFilterMatch(DagTreeView_1.DagTreeView.Current.FilterString)) {
                continue;
            }
            if (DagTreeView_1.DagTreeView.Current.ShowOnlyActive && node.IsPaused) {
                continue;
            }
            if (DagTreeView_1.DagTreeView.Current.ShowOnlyFavorite && !node.IsFav) {
                continue;
            }
            result.push(node);
        }
        return result;
    }
    getTreeItem(element) {
        return element;
    }
}
exports.DagTreeDataProvider = DagTreeDataProvider;


/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DagTreeItem = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const DagTreeView_1 = __webpack_require__(153);
class DagTreeItem extends vscode.TreeItem {
    constructor(apiResponse) {
        super(apiResponse.dag_id);
        this.LatestDagRunId = '';
        this.LatestDagState = '';
        this._IsFav = false;
        this.IsFiltered = false;
        this.ApiResponse = apiResponse;
        this.DagId = apiResponse.dag_id;
        this.IsActive = apiResponse.is_active;
        this.IsPaused = apiResponse.is_paused;
        this.Owners = apiResponse.owners;
        this.Tags = apiResponse.tags;
        this.FileToken = apiResponse.file_token;
        this._IsFav = DagTreeView_1.DagTreeView.Current.FavoriteDags.includes(this.DagId);
        this.setContextValue();
        this.refreshUI();
    }
    set IsFav(value) {
        this._IsFav = value;
        this.setContextValue();
    }
    get IsFav() {
        return this._IsFav;
    }
    isDagRunning() {
        return (this.LatestDagState === 'queued' || this.LatestDagState === 'running');
    }
    setContextValue() {
        let contextValue = "#";
        contextValue += this.IsFav ? "IsFav#" : "!IsFav#";
        contextValue += this.IsPaused ? "IsPaused#" : "!IsPaused#";
        contextValue += this.IsActive ? "IsActive#" : "!IsActive#";
        contextValue += this.IsFiltered ? "IsFiltered#" : "!IsFiltered#";
        contextValue += this.isDagRunning() ? "IsRunning#" : "!IsRunning#";
        this.contextValue = contextValue;
    }
    refreshUI() {
        if (this.IsPaused) {
            this.iconPath = new vscode.ThemeIcon('circle-outline', new vscode.ThemeColor('disabledForeground'));
            this.ApiResponse.is_paused = true;
        }
        else {
            //"queued" "running" "success" "failed"
            if (this.LatestDagState === 'queued') {
                this.iconPath = new vscode.ThemeIcon('loading~spin', new vscode.ThemeColor('charts.yellow'));
            }
            else if (this.LatestDagState === 'running') {
                this.iconPath = new vscode.ThemeIcon('loading~spin', new vscode.ThemeColor('charts.blue'));
            }
            else if (this.LatestDagState === 'success') {
                this.iconPath = new vscode.ThemeIcon('check', new vscode.ThemeColor('testing.iconPassed'));
            }
            else if (this.LatestDagState === 'failed') {
                this.iconPath = new vscode.ThemeIcon('error', new vscode.ThemeColor('testing.iconFailed'));
            }
            else {
                this.iconPath = new vscode.ThemeIcon('circle-filled', new vscode.ThemeColor('charts.gray'));
            }
            this.ApiResponse.is_paused = false;
        }
        // Update context value to reflect current running state
        this.setContextValue();
    }
    doesFilterMatch(filterString) {
        let words = filterString.split(',');
        words = words.map(word => word.trim());
        this.IsFiltered = false;
        for (const word of words) {
            if (this.DagId.includes(word)) {
                this.IsFiltered = true;
                break;
            }
            if (this.Owners.includes(word)) {
                this.IsFiltered = true;
                break;
            }
            for (const t of this.Tags) {
                if (t.name.includes(word)) {
                    this.IsFiltered = true;
                    break;
                }
            }
        }
        return this.IsFiltered;
    }
}
exports.DagTreeItem = DagTreeItem;


/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DagView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const tmp = __webpack_require__(154);
const fs = __webpack_require__(3);
const ui = __webpack_require__(2);
const DagTreeView_1 = __webpack_require__(153);
const MessageHub = __webpack_require__(159);
const Session_1 = __webpack_require__(5);
const AIHandler_1 = __webpack_require__(160);
const DagLogView_1 = __webpack_require__(178);
const Telemetry_1 = __webpack_require__(9);
class DagView {
    constructor(panel, dagId, dagRunId) {
        this._disposables = [];
        this.dagHistorySelectedDate = ui.toISODateString(new Date());
        this.activetabid = "tab-1";
        ui.logToOutput('DagView.constructor Started');
        Telemetry_1.Telemetry.Current.send('dagView.constructor.called');
        this.dagId = dagId;
        this.dagRunId = dagRunId;
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadAllDagData();
        ui.logToOutput('DagView.constructor Completed');
    }
    resetDagData() {
        this.activetabid = "tab-1";
        this.dagJson = undefined;
        this.dagRunJson = undefined;
        this.dagRunHistoryJson = undefined;
        this.dagTaskInstancesJson = undefined;
        this.dagTasksJson = undefined;
        this.stopCheckingDagRunStatus();
    }
    async loadAllDagData() {
        ui.logToOutput('DagView.loadAllDagData Started');
        Telemetry_1.Telemetry.Current.send('dagView.loadAllDagData.called');
        await this.getDagInfo();
        if (this.dagRunId) {
            await this.getDagRun();
        }
        else {
            await this.getLastRun();
        }
        await this.getDagTasks();
        //await this.getRunHistory();
        await this.renderHmtl();
    }
    async loadDagInfoOnly() {
        ui.logToOutput('DagView.loadDagInfoOnly Started');
        Telemetry_1.Telemetry.Current.send('dagView.loadDagInfoOnly.called');
        await this.getDagInfo();
        await this.renderHmtl();
    }
    async renderHmtl() {
        ui.logToOutput('DagView.renderHmtl Started');
        Telemetry_1.Telemetry.Current.send('dagView.renderHmtl.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        //ui.showOutputMessage(this._panel.webview.html);
        ui.logToOutput('DagView.renderHmtl Completed');
    }
    static render(dagId, dagRunId) {
        ui.logToOutput('DagView.render Started');
        Telemetry_1.Telemetry.Current.send('dagView.render.called');
        if (DagView.Current) {
            DagView.Current.dagId = dagId;
            DagView.Current.dagRunId = dagRunId;
            DagView.Current._panel.reveal(vscode.ViewColumn.Two);
            DagView.Current.resetDagData();
            DagView.Current.loadAllDagData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("dagView", "Dag View", vscode.ViewColumn.Two, {
                enableScripts: true,
            });
            DagView.Current = new DagView(panel, dagId, dagRunId);
        }
    }
    /**
     * Helper method to create a temp file and open it
     */
    createAndOpenTempFile(content, prefix, extension) {
        const tmpFile = tmp.fileSync({ mode: 0o644, prefix, postfix: extension });
        fs.appendFileSync(tmpFile.name, content);
        ui.openFile(tmpFile.name);
    }
    async getLastRun() {
        ui.logToOutput('DagView.getLastRun Started');
        Telemetry_1.Telemetry.Current.send('dagView.getLastRun.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getLastDagRun(this.dagId);
        if (result.isSuccessful) {
            this.dagRunJson = result.result;
            this.dagRunId = this.dagRunJson.dag_run_id;
            this.getTaskInstances();
            if (this.dagRunJson && this.dagRunJson.state === "running") {
                this.startCheckingDagRunStatus();
            }
        }
    }
    goToDagRun(dagId, dagRunId) {
        this.dagId = dagId;
        this.dagRunId = dagRunId;
        this.getDagRun();
    }
    goToDag(dagId) {
        this.dagId = dagId;
        this.dagRunId = undefined;
        this.getLastRun();
    }
    async getDagRun() {
        ui.logToOutput('DagView.getDagRun Started');
        Telemetry_1.Telemetry.Current.send('dagView.getDagRun.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getDagRun(this.dagId, this.dagRunId);
        if (result.isSuccessful) {
            this.dagRunJson = result.result;
            this.dagRunId = this.dagRunJson.dag_run_id;
            this.getTaskInstances();
        }
        await this.renderHmtl();
    }
    async getRunHistory(date) {
        ui.logToOutput('DagView.getRunHistory Started');
        Telemetry_1.Telemetry.Current.send('dagView.getRunHistory.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getDagRunHistory(this.dagId, date);
        if (result.isSuccessful) {
            this.dagRunHistoryJson = result.result;
        }
    }
    async getTaskInstances() {
        ui.logToOutput('DagView.getTaskInstances Started');
        Telemetry_1.Telemetry.Current.send('dagView.getTaskInstances.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getTaskInstances(this.dagId, this.dagRunId);
        if (result.isSuccessful) {
            this.dagTaskInstancesJson = result.result;
        }
    }
    async getDagInfo() {
        ui.logToOutput('DagView.getDagInfo Started');
        Telemetry_1.Telemetry.Current.send('dagView.getDagInfo.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getDagInfo(this.dagId);
        if (result.isSuccessful) {
            this.dagJson = result.result;
        }
    }
    async getDagTasks() {
        ui.logToOutput('DagView.getDagTasks Started');
        Telemetry_1.Telemetry.Current.send('dagView.getDagTasks.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getDagTasks(this.dagId);
        if (result.isSuccessful) {
            this.dagTasksJson = result.result;
        }
    }
    dispose() {
        ui.logToOutput('DagView.dispose Started');
        Telemetry_1.Telemetry.Current.send('dagView.dispose.called');
        DagView.Current = undefined;
        // stop any running interval checks
        this.stopCheckingDagRunStatus();
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('DagView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('dagView.getWebviewContent.called');
        //file URIs
        const toolkitUri = ui.getUri(webview, extensionUri, [
            "node_modules",
            "@vscode-elements",
            "elements",
            "dist",
            "bundled.js",
        ]);
        const mainUri = ui.getUri(webview, extensionUri, ["media", "main.js"]);
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        //LATEST DAG RUN
        let state = "";
        let logical_date = undefined;
        let start_date = undefined;
        let end_date = undefined;
        let logical_date_string = "";
        let start_date_string = "";
        let duration = "";
        let isDagRunning = false;
        let hasDagRun = false;
        if (this.dagRunJson) {
            state = this.dagRunJson.state;
            logical_date = this.dagRunJson.logical_date;
            start_date = this.dagRunJson.start_date;
            end_date = this.dagRunJson.end_date;
            logical_date_string = logical_date ? ui.toISODateTimeString(new Date(logical_date)) : "";
            start_date_string = start_date ? ui.toISODateTimeString(new Date(start_date)) : "";
            duration = start_date ? ui.getDuration(new Date(start_date), end_date ? new Date(end_date) : new Date()) : "";
            isDagRunning = (state === "queued" || state === "running") ? true : false;
            hasDagRun = true;
        }
        let runningOrFailedTasks = "";
        if (this.dagTaskInstancesJson) {
            for (const t of this.dagTaskInstancesJson["task_instances"]) {
                if (t.state === "running" || t.state === "failed" || t.state === "up_for_retry" || t.state === "up_for_reschedule" || t.state === "deferred") {
                    runningOrFailedTasks += `<span class="task-tag state-${t.state}">${t.task_id}</span> `;
                }
            }
        }
        //INFO TAB
        let owners = (this.dagJson && Array.isArray(this.dagJson["owners"])) ? this.dagJson["owners"].join(", ") : "";
        let tags = "";
        if (this.dagJson && Array.isArray(this.dagJson["tags"])) {
            this.dagJson["tags"].forEach((item) => { tags += `<span class="tag">${item.name}</span> `; });
        }
        let schedule = (this.dagJson && this.dagJson["timetable_description"]) ? this.dagJson["timetable_description"] + " - " + this.dagJson["timetable_summary"] : "";
        let next_run = (this.dagJson && this.dagJson["next_dagrun_data_interval_start"]) ? ui.toISODateTimeString(new Date(this.dagJson["next_dagrun_data_interval_start"])) : "None";
        let isPausedText = (this.dagJson) ? (this.dagJson.is_paused ? "true" : "false") : "unknown";
        let isPaused = isPausedText === "true";
        //TASKS TAB
        let taskRows = "";
        if (this.dagTaskInstancesJson) {
            for (const t of this.dagTaskInstancesJson["task_instances"].sort((a, b) => (a.start_date > b.start_date) ? 1 : -1)) {
                taskRows += `
                <tr class="table-row">
                    <td>
                        <div style="display: flex; align-items: center;">
                            <div class="state-indicator state-${t.state}" title="${t.state}" ></div>
                            <span class="task-name">${t.task_id}</span> <span class="try-number">(${t.try_number})</span>
                        </div>
                    </td>
                    <td>
                        <div class="action-links">
                            <a href="#" class="link-button" id="task-log-link-${t.task_id}">Logs</a>
                            <a href="#" class="link-button" id="task-xcom-link-${t.task_id}">XComs</a>
                        </div>
                    </td>
                    <td><span class="duration-badge">${ui.getDuration(new Date(t.start_date), new Date(t.end_date))}</span></td>
                    <td class="operator-type">${t.operator}</td>
                </tr>
                `;
            }
        }
        // BUILD TASK DEPENDENCY TREE
        let taskDependencyTree = "";
        if (this.dagTasksJson && this.dagTasksJson.tasks && this.dagTasksJson.tasks.length > 0) {
            taskDependencyTree = this.buildTaskDependencyTree(this.dagTasksJson.tasks);
        }
        //HISTORY TAB
        let runHistoryRows = "";
        if (this.dagRunHistoryJson) {
            for (const t of this.dagRunHistoryJson["dag_runs"]) {
                runHistoryRows += `
                <tr class="table-row">
                    <td>
                        <div style="display: flex; align-items: center;">
                            <div class="state-indicator state-${t.state}" title="${t.state}"></div>
                            <span class="state-text">${t.state}</span>
                        </div>
                    </td>
                    <td><a href="#" class="history-link" id="history-dag-run-id-${t.dag_run_id}">${ui.toISODateTimeString(new Date(t.start_date))}</a></td>
                    <td><span class="duration-badge">${ui.getDuration(new Date(t.start_date), new Date(t.end_date))}</span></td>
                    <td><span class="note-text">${t.note || ''}</span></td>
                </tr>
                `;
            }
        }
        let result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <script type="module" src="${toolkitUri}"></script>
        <script type="module" src="${mainUri}"></script>
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body {
                padding: var(--spacing-md);
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
            }

            a {
                color: var(--vscode-textLink-foreground);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
                color: var(--vscode-textLink-activeForeground);
            }

            /* Header Section */
            .header-container {
                display: flex;
                align-items: center;
                gap: var(--spacing-md);
                margin-bottom: var(--spacing-lg);
                padding-bottom: var(--spacing-md);
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            .dag-paused-indicator {
                width: 12px;
                height: 12px;
                border-radius: 50%;
            }
            .dag-paused-true { background-color: var(--vscode-disabledForeground); }
            .dag-paused-false { background-color: var(--vscode-testing-iconPassed); }

            /* Tabs */
            vscode-tabs {
                border-radius: var(--border-radius);
            }

            section {
                padding: 20px 0;
            }

            /* Tables */
            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
            }
            
            th.section-header {
                font-size: 13px;
                color: var(--vscode-editor-foreground);
                background-color: transparent;
                border-bottom: 2px solid var(--vscode-button-background);
                padding-bottom: 8px;
                padding-left: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }

            /* Detail Layouts */
            .detail-row td:first-child {
                width: 120px;
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
            }
            .detail-row td:nth-child(2) {
                width: 20px;
                text-align: center;
                color: var(--vscode-descriptionForeground);
            }

            /* States & Badges */
            .state-indicator {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-right: 8px;
                display: inline-block;
            }
            /* Map existing state classes to colors if possible, or assume external CSS handles it */
            
            .task-tag {
                display: inline-block;
                padding: 2px 8px;
                background-color: var(--vscode-badge-background);
                color: var(--vscode-badge-foreground);
                border-radius: 12px;
                font-size: 11px;
                margin-right: 4px;
                margin-bottom: 4px;
            }

            .tag {
                background-color: var(--vscode-textBlockQuote-background);
                color: var(--vscode-textBlockQuote-border);
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 12px;
                border: 1px solid var(--vscode-widget-border);
            }

            .duration-badge {
                font-family: 'Courier New', monospace;
                font-size: 12px;
                opacity: 0.8;
            }

            .operator-type {
                font-style: italic;
                color: var(--vscode-descriptionForeground);
            }

            .try-number {
                font-size: 11px;
                color: var(--vscode-descriptionForeground);
                margin-left: 4px;
            }

            .action-links {
                display: flex;
                gap: 12px;
            }

            .link-button {
                font-size: 12px;
            }

            /* Inputs */
            input[type="date"], vscode-textfield, vscode-textarea {
                width: 100%;
                box-sizing: border-box;
                font-family: inherit;
            }
            input[type="date"] {
                padding: 6px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border-radius: 2px;
            }

            vscode-button {
                margin-right: 8px;
            }
            
            /* Utils */
            .mt-md { margin-top: var(--spacing-md); }
            .mb-md { margin-bottom: var(--spacing-md); }

            /* Code block for JSON/Config */
            .code-block {
                font-family: var(--vscode-editor-font-family);
                background-color: var(--vscode-textBlockQuote-background);
                padding: 8px;
                border-radius: 4px;
                white-space: pre-wrap;
                font-size: 12px;
                max-height: 200px;
                overflow-y: auto;
            }

        </style>
        <title>DAG</title>
      </head>
      <body>  

        <div class="header-container">
            <div class="dag-paused-indicator dag-paused-${isPausedText}"></div>
            <h2>${this.dagId}</h2>
            <div style="visibility: ${isDagRunning ? "visible" : "hidden"}; display: flex; align-items: center;">
                <vscode-progress-ring></vscode-progress-ring>
            </div>
        </div>
                    
        <vscode-tabs id="tab-control" selected-index="${this.activetabid === 'tab-1' ? 0 : this.activetabid === 'tab-2' ? 1 : this.activetabid === 'tab-3' ? 2 : 3}">
            <vscode-tab-header slot="header">RUN</vscode-tab-header>
            <vscode-tab-header slot="header">TASKS</vscode-tab-header>
            <vscode-tab-header slot="header">INFO</vscode-tab-header>
            <vscode-tab-header slot="header">HISTORY</vscode-tab-header>
            
            <vscode-tab-panel>
                <section>
                    <table>
                        <tr>
                            <th colspan="3" class="section-header">Dag Run Details</th>
                        </tr>
                        <tr class="detail-row">
                            <td>State</td>
                            <td>:</td>
                            <td>
                                <div style="display: flex; align-items: center;">
                                    <div class="state-indicator state-${state}"></div> <span>${state}</span>
                                </div>
                            </td>
                        </tr>
                        <tr class="detail-row">
                            <td>Tasks</td>
                            <td>:</td>
                            <td>${runningOrFailedTasks || '<span style="opacity:0.5">None active</span>'}</td>
                        </tr>
                        <tr class="detail-row">
                            <td>Logical Date</td>
                            <td>:</td>
                            <td>${logical_date_string}</td>
                        </tr>
                        <tr class="detail-row">
                            <td>StartDate</td>
                            <td>:</td>
                            <td>${start_date_string}</td>
                        </tr>
                        <tr class="detail-row">
                            <td>Duration</td>
                            <td>:</td>
                            <td>${duration}</td>
                        </tr>
                        <tr class="detail-row">
                            <td>Note</td>
                            <td>:</td>
                            <td><a href="#" id="run-update-note-link" title="Click to update note">${this.dagRunJson?.note || '<span style="opacity:0.5; font-style:italic;">Add a note...</span>'}</a></td>
                        </tr>
                        <tr class="detail-row">
                            <td>Config</td>
                            <td>:</td>
                            <td><div class="code-block">${this.dagRunJson?.conf ? JSON.stringify(this.dagRunJson.conf, null, 2) : '{}'}</div></td>
                        </tr>
                    </table>
                    
                    <div class="mb-md">
                        <vscode-button appearance="secondary" id="run-ask-ai" ${!hasDagRun ? "disabled" : ""}>Ask AI</vscode-button>    
                        <vscode-button appearance="secondary" id="run-view-log" ${!hasDagRun ? "disabled" : ""}>Log</vscode-button> 
                        <vscode-button appearance="secondary" id="run-lastrun-check" ${isPaused ? "disabled" : ""}>Refresh</vscode-button>  
                        <vscode-button appearance="secondary" id="run-more-dagrun-detail" ${!hasDagRun ? "disabled" : ""}>More</vscode-button>
                    </div>
            
                    <br>
            
                    <table>
                        <tr>
                            <th colspan="3" class="section-header">Trigger Run</th>
                        </tr>
                        <tr class="detail-row">
                            <td>Logical Date</td>
                            <td>:</td>
                            <td><vscode-textfield id="run_date" placeholder="YYYY-MM-DD (Optional)" maxlength="10"></vscode-textfield></td>
                        </tr>
                        <tr class="detail-row">
                            <td>Config</td>
                            <td>:</td>
                            <td><vscode-textarea id="run_config" rows="3" placeholder='{"key": "value"}'></vscode-textarea></td>
                        </tr>
                    </table>
                    
                    <div class="mb-md">
                        <vscode-button appearance="primary" id="run-trigger-dag" ${isPaused ? "disabled" : ""}>Run</vscode-button>
                        <vscode-button appearance="secondary" id="run-lastrun-cancel" ${isPaused || !isDagRunning ? "disabled" : ""}>Cancel</vscode-button>  
                    </div>

                    <br>

                    <table>
                        <tr>
                            <th colspan="3" class="section-header">Control</th>
                        </tr>
                    </table>
                    <div class="mb-md">
                         <vscode-button appearance="secondary" id="run-pause-dag" ${isPaused ? "disabled" : ""}>Pause</vscode-button>
                         <vscode-button appearance="secondary" id="run-unpause-dag" ${!isPaused ? "disabled" : ""}>Unpause</vscode-button>
                    </div>

                    <br><br>
                    
                    <div style="opacity: 0.7; font-size: 12px; margin-top: 40px; border-top: 1px solid var(--vscode-widget-border); padding-top: 20px;">
                        <div style="margin-bottom: 8px;"><a href="https://github.com/necatiarslan/airflow-vscode-extension/issues/new">Report Bug / Request Feature</a></div>
                        <div style="margin-bottom: 8px;"><a href="https://bit.ly/airflow-extension-survey">New Feature Survey</a></div>
                        <div><a href="https://github.com/sponsors/necatiarslan">Support this extension</a></div>
                    </div>
                </section>
            </vscode-tab-panel>


            <vscode-tab-panel>
                <section>
                    ${taskDependencyTree ? `
                    <div style="margin-bottom: 20px; border: 1px solid var(--vscode-widget-border); border-radius: 4px; padding: 10px;">
                        <vscode-tree>
                        ${taskDependencyTree}
                        </vscode-tree>
                    </div>
                    ` : ''}

                    <table>
                        <tr>
                            <th>Task</th>
                            <th>Actions</th>
                            <th>Duration</th>            
                            <th>Operator</th>
                        </tr>
                        ${taskRows}
                    </table>
                    
                    <div>
                        <vscode-button appearance="secondary" id="tasks-refresh">Refresh</vscode-button>
                        <vscode-button appearance="secondary" id="tasks-more-detail" ${!this.dagTaskInstancesJson ? "disabled" : ""}>Raw JSON</vscode-button>
                    </div>

                </section>
            </vscode-tab-panel>
            
            <vscode-tab-panel>
                <section>
                    <table>
                        <tr class="detail-row">
                            <td>Owners</td>
                            <td>:</td>
                            <td>${owners}</td>
                        </tr>
                        <tr class="detail-row">
                            <td>Tags</td>
                            <td>:</td>
                            <td>${tags}</td>
                        </tr>
                        <tr class="detail-row">
                            <td>Schedule</td>
                            <td>:</td>
                            <td>${schedule}</td>
                        </tr>
                        <tr class="detail-row">
                            <td>Next Run</td>
                            <td>:</td>
                            <td>${next_run}</td>
                        </tr>
                    </table>
                    
                    <div>
                        <vscode-button appearance="secondary" id="info-source-code">Source Code</vscode-button> 
                        <vscode-button appearance="secondary" id="other-dag-detail">Raw JSON</vscode-button>
                    </div>
                </section>
            </vscode-tab-panel>

            <vscode-tab-panel>
                <section>                    
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px; background: var(--vscode-editor-inactiveSelectionBackground); padding: 10px; border-radius: 4px;">
                        <label for="history_date" style="font-weight: 600;">Filter Date:</label>
                        <input type="date" id="history_date" value="${this.dagHistorySelectedDate}" style="width: 150px;">
                        <vscode-button appearance="secondary" id="history-load-runs">Load Runs</vscode-button>
                    </div>

                    <table>
                        <thead>
                            <tr>
                                <th>State</th>
                                <th>Start Time</th>            
                                <th>Duration</th>
                                <th>Notes</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${runHistoryRows}
                        </tbody>
                    </table>   
                </section>
            </vscode-tab-panel>

        </vscode-tabs>
      </body>
    </html>
    `;
        ui.logToOutput('DagView._getWebviewContent Completed');
        return result;
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('DagView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('dagView.setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            const command = message.command;
            let activetabid = message.activetabid;
            if (["tab-1", "tab-2", "tab-3", "tab-4"].includes(activetabid)) {
                this.activetabid = message.activetabid;
            }
            ui.logToOutput('DagView._setWebviewMessageListener Message Received ' + message.command);
            switch (command) {
                case "run-trigger-dag":
                    this.triggerDagWConfig(message.config, message.date);
                    return;
                case "run-view-log":
                    this.showDAGRunLog();
                    return;
                case "run-more-dagrun-detail":
                    ui.showOutputMessage(this.dagRunJson);
                    return;
                case "other-dag-detail":
                    ui.showOutputMessage(this.dagJson);
                    return;
                case "tasks-more-detail":
                    ui.showOutputMessage(this.dagTaskInstancesJson);
                    return;
                case "history-load-runs":
                    this.getRunHistoryAndRenderHtml(message.date);
                    return;
                case "info-source-code":
                    this.showSourceCode();
                    return;
                case "run-pause-dag":
                    this.pauseDAG(true);
                    return;
                case "run-unpause-dag":
                    this.pauseDAG(false);
                    return;
                case "run-ask-ai":
                    this.askAI();
                    return;
                case "run-lastrun-check":
                    this.getLastRun();
                    if (this.dagRunJson) {
                        this.startCheckingDagRunStatus();
                    }
                    return;
                case "run-lastrun-cancel":
                    if (this.dagRunJson) {
                        this.cancelDagRun();
                    }
                    return;
                case "run-update-note":
                    if (this.dagRunJson) {
                        this.updateDagRunNote();
                    }
                    return;
                case "history-dag-run-id":
                    let dagRunId = message.id;
                    dagRunId = dagRunId.replace("history-dag-run-id-", "");
                    this.activetabid = "tab-1";
                    this.dagRunId = dagRunId;
                    this.getDagRun();
                    return;
                case "task-log-link":
                    let taskId = message.id;
                    taskId = taskId.replace("task-log-link-", "");
                    this.showTaskInstanceLog(this.dagId, this.dagRunId, taskId);
                    return;
                case "task-xcom-link":
                    let xcomTaskId = message.id;
                    xcomTaskId = xcomTaskId.replace("task-xcom-link-", "");
                    this.showTaskXComs(this.dagId, this.dagRunId, xcomTaskId);
                    return;
                case "tasks-refresh":
                    this.getTasksAndRenderHtml();
                    return;
                case "tabControlChanged":
                    this.activetabid = message.activeid;
                    ui.logToOutput("tab changed to " + message.activeid);
                    return;
            }
        }, undefined, this._disposables);
    }
    async getTasksAndRenderHtml() {
        await this.getDagTasks();
        await this.renderHmtl();
    }
    async cancelDagRun() {
        ui.logToOutput('DagView.cancelDagRun Started');
        Telemetry_1.Telemetry.Current.send('dagView.cancelDagRun.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.cancelDagRun(this.dagId, this.dagRunId);
        if (result.isSuccessful) {
            //ui.showInfoMessage(`Dag ${this.dagId} Run ${this.dagRunId} cancelled successfully.`);
            ui.logToOutput(`Dag ${this.dagId} Run ${this.dagRunId} cancelled successfully.`);
            await this.getDagRun();
            MessageHub.DagRunCancelled(this, this.dagId, this.dagRunId);
        }
    }
    async updateDagRunNote() {
        ui.logToOutput('DagView.updateDagRunNote Started');
        Telemetry_1.Telemetry.Current.send('dagView.updateDagRunNote.called');
        if (!Session_1.Session.Current.Api || !this.dagRunJson) {
            return;
        }
        // Show input box with current note as default value
        const newNote = await vscode.window.showInputBox({
            prompt: 'Enter note for this DAG run',
            value: this.dagRunJson.note || '',
            placeHolder: 'Add a note for this DAG run'
        });
        // User cancelled the input
        if (newNote === undefined) {
            return;
        }
        const result = await Session_1.Session.Current.Api.updateDagRunNote(this.dagId, this.dagRunId, newNote);
        if (result.isSuccessful) {
            // Refresh the DAG run to get the updated note
            await this.getDagRun();
        }
    }
    async pauseDAG(is_paused) {
        ui.logToOutput('DagView.pauseDAG Started');
        Telemetry_1.Telemetry.Current.send('dagView.pauseDAG.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (is_paused && this.dagJson.is_paused) {
            ui.showWarningMessage(this.dagId + 'Dag is already PAUSED');
            return;
        }
        if (!is_paused && !this.dagJson.is_paused) {
            ui.showWarningMessage(this.dagId + 'Dag is already ACTIVE');
            return;
        }
        const result = await Session_1.Session.Current.Api.pauseDag(this.dagId, is_paused);
        if (result.isSuccessful) {
            this.loadDagInfoOnly();
            is_paused ? MessageHub.DagPaused(this, this.dagId) : MessageHub.DagUnPaused(this, this.dagId);
        }
    }
    async askAI() {
        ui.logToOutput('DagView.askAI Started');
        Telemetry_1.Telemetry.Current.send('dagView.askAI.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (!DagTreeView_1.DagTreeView.Current) {
            ui.showErrorMessage('DagTreeView is not available');
            return;
        }
        if (!this.dagJson) {
            ui.showErrorMessage('DAG information is not available');
            return;
        }
        const code = await Session_1.Session.Current.Api.getSourceCode(this.dagId, this.dagJson.file_token);
        if (!code.isSuccessful) {
            ui.showErrorMessage('Failed to retrieve DAG source code for AI context');
            return;
        }
        const logs = await Session_1.Session.Current.Api.getDagRunLogText(this.dagId, this.dagRunId);
        if (!logs.isSuccessful) {
            ui.showErrorMessage('Failed to retrieve DAG logs for AI context');
            return;
        }
        // Call the askAI function from DagTreeView
        await AIHandler_1.AIHandler.Current.askAIWithContext({ code: code.result, logs: logs.result, dag: this.dagJson, dagRun: this.dagRunJson, tasks: this.dagTasksJson, taskInstances: this.dagTaskInstancesJson });
    }
    async showSourceCode() {
        ui.logToOutput('DagView.showSourceCode Started');
        Telemetry_1.Telemetry.Current.send('dagView.showSourceCode.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getSourceCode(this.dagId, this.dagJson.file_token);
        if (result.isSuccessful) {
            this.createAndOpenTempFile(result.result, this.dagId, '.py');
        }
        else {
            ui.logToOutput(result.result);
            ui.showErrorMessage(result.result);
        }
    }
    async getRunHistoryAndRenderHtml(date) {
        ui.logToOutput('DagView.getRunHistoryAndRenderHtml Started');
        Telemetry_1.Telemetry.Current.send('dagView.getRunHistoryAndRenderHtml.called');
        this.dagHistorySelectedDate = date;
        await this.getRunHistory(date);
        await this.renderHmtl();
    }
    async showDAGRunLog() {
        ui.logToOutput('DagView.showDAGRunLog Started');
        Telemetry_1.Telemetry.Current.send('dagView.showDAGRunLog.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        // const result = await Session.Current.Api.getDagRunLogText(this.dagId, this.dagRunId);
        // if (result.isSuccessful) {
        //     this.createAndOpenTempFile(result.result, this.dagId, '.log');
        // }
        DagLogView_1.DagLogView.render(this.dagId, this.dagRunId);
    }
    async showTaskInstanceLog(dagId, dagRunId, taskId) {
        ui.logToOutput('DagView.showTaskInstanceLog Started');
        Telemetry_1.Telemetry.Current.send('dagView.showTaskInstanceLog.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        // const result = await Session.Current.Api.getTaskInstanceLogText(dagId, dagRunId, taskId);
        // if (result.isSuccessful) {
        //     this.createAndOpenTempFile(result.result, dagId + '-' + taskId, '.log');
        // }
        DagLogView_1.DagLogView.render(dagId, dagRunId, taskId);
    }
    async showTaskXComs(dagId, dagRunId, taskId) {
        ui.logToOutput('DagView.showTaskXComs Started');
        Telemetry_1.Telemetry.Current.send('dagView.showTaskXComs.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getTaskXComs(dagId, dagRunId, taskId);
        if (result.isSuccessful) {
            this.createAndOpenTempFile(JSON.stringify(result.result, null, 2), dagId + '-' + taskId + '_xcom', '.json');
        }
        else {
            ui.showInfoMessage(`No XCom entries found for task: ${taskId}`);
        }
    }
    async triggerDagWConfig(config = "", date = "") {
        ui.logToOutput('DagView.triggerDagWConfig Started');
        Telemetry_1.Telemetry.Current.send('dagView.triggerDagWConfig.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (config && !ui.isJsonString(config)) {
            ui.showWarningMessage("Config is not a valid JSON");
            return;
        }
        if (date && !ui.isValidDate(date)) {
            ui.showWarningMessage("Date is not a valid DATE");
            return;
        }
        if (!config) {
            config = "{}";
        }
        if (config !== undefined) {
            const result = await Session_1.Session.Current.Api.triggerDag(this.dagId, config, date);
            if (result.isSuccessful) {
                this.dagRunId = result.result["dag_run_id"];
                this.startCheckingDagRunStatus();
                MessageHub.DagTriggered(this, this.dagId, this.dagRunId);
            }
        }
    }
    async startCheckingDagRunStatus() {
        ui.logToOutput('DagView.startCheckingDagRunStatus Started');
        Telemetry_1.Telemetry.Current.send('dagView.startCheckingDagRunStatus.called');
        await this.refreshRunningDagState(this);
        if (this.dagStatusInterval) {
            clearInterval(this.dagStatusInterval); //stop prev checking
        }
        this.dagStatusInterval = setInterval(() => {
            void this.refreshRunningDagState(this).catch((err) => ui.logToOutput('refreshRunningDagState Error', err));
        }, 5 * 1000);
    }
    async stopCheckingDagRunStatus() {
        ui.logToOutput('DagView.stopCheckingDagRunStatus Started');
        Telemetry_1.Telemetry.Current.send('dagView.stopCheckingDagRunStatus.called');
        if (this.dagStatusInterval) {
            clearInterval(this.dagStatusInterval); //stop prev checking
        }
    }
    async refreshRunningDagState(dagView) {
        ui.logToOutput('DagView.refreshRunningDagState Started');
        Telemetry_1.Telemetry.Current.send('dagView.refreshRunningDagState.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (!dagView.dagId || !dagView.dagRunId) {
            dagView.stopCheckingDagRunStatus();
            return;
        }
        const result = await Session_1.Session.Current.Api.getDagRun(dagView.dagId, dagView.dagRunId);
        if (result.isSuccessful) {
            dagView.dagRunJson = result.result;
            const resultTasks = await Session_1.Session.Current.Api.getTaskInstances(dagView.dagId, dagView.dagRunId);
            if (resultTasks.isSuccessful) {
                dagView.dagTaskInstancesJson = resultTasks.result;
            }
        }
        else {
            dagView.stopCheckingDagRunStatus();
            return;
        }
        let state = (dagView.dagRunJson) ? dagView.dagRunJson.state : "";
        //"queued" "running" "success" "failed"
        if (state === "queued" || state === "running") {
            //go on for the next check
        }
        else {
            dagView.stopCheckingDagRunStatus();
        }
        dagView.renderHmtl();
    }
    buildTaskDependencyTree(tasks) {
        ui.logToOutput('DagView.buildTaskDependencyTree Started');
        Telemetry_1.Telemetry.Current.send('dagView.buildTaskDependencyTree.called');
        // Create a map for quick task lookup
        const taskMap = new Map();
        tasks.forEach(task => {
            taskMap.set(task.task_id, task);
        });
        // Find root tasks (tasks with no upstream dependencies)
        const rootTasks = tasks.filter(task => !task.upstream_task_ids || task.upstream_task_ids.length === 0);
        if (rootTasks.length === 0) {
            return "No task dependencies found or circular dependencies detected.";
        }
        // Build tree recursively
        const visited = new Set();
        let treeHtml = "";
        const buildTree = (taskId) => {
            if (visited.has(taskId)) {
                return ""; // Prevent infinite loops and duplicates in this spanning tree view
            }
            visited.add(taskId);
            const task = taskMap.get(taskId);
            if (!task) {
                return "";
            }
            let itemHtml = `<vscode-tree-item>\n`;
            itemHtml += `${task.task_id}\n`;
            // Get downstream tasks
            const downstreamIds = task.downstream_task_ids || [];
            if (downstreamIds.length > 0) {
                downstreamIds.forEach((downstreamId) => {
                    itemHtml += buildTree(downstreamId);
                });
            }
            itemHtml += `</vscode-tree-item>\n`;
            return itemHtml;
        };
        // Build tree for each root task
        rootTasks.forEach((rootTask) => {
            treeHtml += buildTree(rootTask.task_id);
        });
        return treeHtml || "No tasks to display.";
    }
}
exports.DagView = DagView;


/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DagTriggered = DagTriggered;
exports.DagRunCancelled = DagRunCancelled;
exports.DagPaused = DagPaused;
exports.DagUnPaused = DagUnPaused;
const DagView_1 = __webpack_require__(158);
const DagTreeView_1 = __webpack_require__(153);
function DagTriggered(source, dagId, dagRunId) {
    if (!(source instanceof DagView_1.DagView) && DagView_1.DagView.Current && DagView_1.DagView.Current.dagId === dagId) {
        DagView_1.DagView.Current.goToDagRun(dagId, dagRunId);
    }
    if (!(source instanceof DagTreeView_1.DagTreeView) && DagTreeView_1.DagTreeView.Current) {
        DagTreeView_1.DagTreeView.Current?.notifyDagStateWithDagId(dagId, dagRunId, "queued");
    }
}
function DagRunCancelled(source, dagId, dagRunId) {
    if (!(source instanceof DagView_1.DagView) && DagView_1.DagView.Current && DagView_1.DagView.Current.dagId === dagId) {
        DagView_1.DagView.Current.goToDagRun(dagId, dagRunId);
    }
    if (!(source instanceof DagTreeView_1.DagTreeView) && DagTreeView_1.DagTreeView.Current) {
        DagTreeView_1.DagTreeView.Current?.notifyDagStateWithDagId(dagId, dagRunId, "failed");
    }
}
function DagPaused(source, dagId) {
    if (!(source instanceof DagView_1.DagView) && DagView_1.DagView.Current && DagView_1.DagView.Current.dagId === dagId) {
        DagView_1.DagView.Current.loadDagInfoOnly();
    }
    if (!(source instanceof DagTreeView_1.DagTreeView) && DagTreeView_1.DagTreeView.Current) {
        DagTreeView_1.DagTreeView.Current?.notifyDagPaused(dagId);
    }
}
function DagUnPaused(source, dagId) {
    if (!(source instanceof DagView_1.DagView) && DagView_1.DagView.Current && DagView_1.DagView.Current.dagId === dagId) {
        DagView_1.DagView.Current.loadDagInfoOnly();
    }
    if (!(source instanceof DagTreeView_1.DagTreeView) && DagTreeView_1.DagTreeView.Current) {
        DagTreeView_1.DagTreeView.Current?.notifyDagUnPaused(dagId);
    }
}


/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AIHandler = void 0;
const Session_1 = __webpack_require__(5);
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const AirflowClientAdapter_1 = __webpack_require__(161);
const TriggerDagRunTool_1 = __webpack_require__(162);
const GetFailedRunsTool_1 = __webpack_require__(163);
const ListActiveDagsTool_1 = __webpack_require__(164);
const ListPausedDagsTool_1 = __webpack_require__(165);
const GetRunningDagsTool_1 = __webpack_require__(166);
const PauseDagTool_1 = __webpack_require__(167);
const UnpauseDagTool_1 = __webpack_require__(168);
const GetDagRunsTool_1 = __webpack_require__(169);
const CancelDagRunTool_1 = __webpack_require__(170);
const AnalyseDagLatestRunTool_1 = __webpack_require__(171);
const GetDagHistoryTool_1 = __webpack_require__(172);
const GetDagRunDetailTool_1 = __webpack_require__(173);
const GetTodayTool_1 = __webpack_require__(174);
const GetDagSourceCodeTool_1 = __webpack_require__(175);
const GoToDagViewTool_1 = __webpack_require__(176);
const GoToDagLogViewTool_1 = __webpack_require__(177);
const GoToDagRunHistoryTool_1 = __webpack_require__(179);
const GoToProvidersViewTool_1 = __webpack_require__(181);
const GoToConnectionsViewTool_1 = __webpack_require__(183);
const GoToVariablesViewTool_1 = __webpack_require__(185);
const GoToConfigsViewTool_1 = __webpack_require__(187);
const GoToPluginsViewTool_1 = __webpack_require__(189);
const GoToServerHealthViewTool_1 = __webpack_require__(191);
const Telemetry_1 = __webpack_require__(9);
class AIHandler {
    constructor() {
        AIHandler.Current = this;
        Telemetry_1.Telemetry.Current.send('AIHandler.Initialized');
    }
    async aIHandler(request, context, stream, token) {
        ui.logToOutput('AIHandler.aIHandler Started');
        Telemetry_1.Telemetry.Current.send('AIHandler.aIHandler.Started');
        const aiContext = AIHandler.Current?.askAIContext;
        // 1. Define the tools we want to expose to the model
        // These must match the definitions in package.json
        const tools = [
            {
                name: 'list_active_dags',
                description: 'Lists all Airflow DAGs that are currently active (not paused). Returns a list of DAG IDs and their details.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'list_paused_dags',
                description: 'Lists all Airflow DAGs that are currently paused. Returns a list of DAG IDs and their details.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'get_running_dags',
                description: 'Lists all Airflow DAGs that currently have running or queued DAG runs. Use this when asked about running, executing, or in-progress DAGs. Returns DAG IDs with run states and run IDs.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'pause_dag',
                description: 'Pauses a specific Airflow DAG. Required input: dag_id (string).',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The unique identifier (ID) of the DAG to pause' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'unpause_dag',
                description: 'Unpauses (activates) a specific Airflow DAG. Required input: dag_id (string).',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The unique identifier (ID) of the DAG to unpause' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'trigger_dag_run',
                description: 'Triggers a DAG run. Inputs: dag_id (string), config_json (string, optional), date (string, optional).',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID' },
                        configJson: { type: 'string', description: 'JSON configuration or file path' },
                        date: { type: 'string', description: 'Logical date in ISO 8601 format' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'get_failed_runs',
                description: 'Gets failed DAG runs. Inputs: time_range_hours (number), dag_id_filter (string).',
                inputSchema: {
                    type: 'object',
                    properties: {
                        timeRangeHours: { type: 'number' },
                        dagIdFilter: { type: 'string' }
                    },
                    required: []
                }
            },
            {
                name: 'get_dag_runs',
                description: 'Retrieves DAG runs for a given DAG. Optional date (YYYY-MM-DD). Returns run id, start time, duration, status.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID' },
                        date: { type: 'string', description: 'Optional date filter YYYY-MM-DD' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'get_dag_history',
                description: 'Retrieves DAG run history for a given date (defaults to today). Returns date/time, status, duration, note.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID' },
                        date: { type: 'string', description: 'Optional date filter YYYY-MM-DD' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'cancel_dag_run',
                description: 'Cancels the currently running DAG run for the given DAG. Required: dag_id.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'analyse_dag_latest_run',
                description: 'Comprehensive analysis of the latest DAG run including tasks, source code, and logs. Required: dag_id.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'get_dag_run_detail',
                description: 'Comprehensive analysis of a specific DAG run by run ID. Analyzes tasks, source code, and logs for the specified run. Required: dag_id, dag_run_id.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID' },
                        dagRunId: { type: 'string', description: 'The DAG run ID to analyze' }
                    },
                    required: ['dagId', 'dagRunId']
                }
            },
            {
                name: 'get_today',
                description: 'Returns the current system date in multiple formats. Use when asked about today\'s date or current date. Helpful for date filtering operations. No inputs required.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'get_dag_source_code',
                description: 'Retrieves the Python source code for a specific DAG. Use when the user wants to see or analyze the DAG implementation. Required: dag_id.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID to get source code for' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'go_to_dag_view',
                description: 'Opens the DAG View panel to display information about a specific DAG. Optional: provide dag_run_id to view a specific run. Required: dag_id.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID to view' },
                        dagRunId: { type: 'string', description: 'Optional DAG run ID to navigate to a specific run' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'go_to_dag_log_view',
                description: 'Opens the DAG Log View panel to display task logs for a specific Airflow DAG. Required: dag_id. Optional: dag_run_id, task_id, try_number.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID' },
                        dagRunId: { type: 'string', description: 'Optional: The DAG run ID' },
                        taskId: { type: 'string', description: 'Optional: The Task ID' },
                        tryNumber: { type: 'number', description: 'Optional: The try number' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'go_to_dag_run_history',
                description: 'Opens the DAG Run History panel with optional filters. Shows run history for a DAG with optional date range and status filters. Required: dag_id.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        dagId: { type: 'string', description: 'The DAG ID to view history for' },
                        startDate: { type: 'string', description: 'Optional start date filter (YYYY-MM-DD format)' },
                        endDate: { type: 'string', description: 'Optional end date filter (YYYY-MM-DD format)' },
                        status: { type: 'string', description: 'Optional status filter (success, failed, running, queued, upstream_failed)' }
                    },
                    required: ['dagId']
                }
            },
            {
                name: 'go_to_providers_view',
                description: 'Opens the Providers View panel to display installed Airflow providers. No inputs required.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'go_to_connections_view',
                description: 'Opens the Connections View panel to display Airflow connections. No inputs required.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'go_to_variables_view',
                description: 'Opens the Variables View panel to display Airflow variables. No inputs required.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'go_to_configs_view',
                description: 'Opens the Configs View panel to display Airflow configuration settings. No inputs required.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'go_to_plugins_view',
                description: 'Opens the Plugins View panel to display installed Airflow plugins. No inputs required.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            },
            {
                name: 'go_to_server_health_view',
                description: 'Opens the Server Health View panel to display Airflow server health status. No inputs required.',
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            }
        ];
        // 2. Construct the Initial Messages
        const messages = [
            vscode.LanguageModelChatMessage.User(`You are an expert in Apache Airflow. You have access to tools to manage DAGs, view logs, and check status. Use them when appropriate.`),
            vscode.LanguageModelChatMessage.User(`Don't provide JSON responses unless specifically asked. Always format your responses in markdown.`)
        ];
        // Loop through the latest 6 entries from context.history (only previous @aws interactions)
        const recentHistory = context.history.slice(-6);
        for (const turn of recentHistory) {
            if (turn instanceof vscode.ChatRequestTurn) {
                messages.push(vscode.LanguageModelChatMessage.User(turn.prompt));
                continue;
            }
            if (turn instanceof vscode.ChatResponseTurn) {
                const responseContent = turn.response
                    .filter((part) => part instanceof vscode.ChatResponseMarkdownPart)
                    .map((part) => part.value.value)
                    .join('\n');
                if (responseContent) {
                    messages.push(vscode.LanguageModelChatMessage.Assistant(responseContent));
                }
            }
        }
        // Add context if available
        if (aiContext) {
            messages.push(vscode.LanguageModelChatMessage.User(`Context:\nDAG: ${aiContext.dag || 'N/A'}\nLogs: ${aiContext.logs || 'N/A'}\nCode: ${aiContext.code || 'N/A'}`));
        }
        if (this.currentDagId) {
            messages.push(vscode.LanguageModelChatMessage.User(`Current DAG ID in focus: ${this.currentDagId}`));
        }
        messages.push(vscode.LanguageModelChatMessage.User(request.prompt));
        // Check if user is expressing appreciation
        const usedAppreciated = request.prompt.toLowerCase().includes('thank');
        // 3. Select Model and Send Request
        try {
            //TODO: Make model configurable
            // const [model] = await vscode.lm.selectChatModels( {id: "claude-sonnet-4.5"} );
            let model = request.model;
            if (request.model.id.includes('auto')) {
                const models = await vscode.lm.selectChatModels({ vendor: model.vendor, family: model.family });
                if (models.length > 0) {
                    model = models[0];
                    ui.logToOutput(`Auto-selected model: ${model.name} (${model.id})`);
                }
                else {
                    ui.logToOutput(`No models found for vendor: ${model.vendor}, family: ${model.family}`);
                    model = undefined;
                }
            }
            ui.logToOutput(`Selected AI Family: ${model?.family || 'None'}, Name: ${model?.name || 'None'}`);
            Telemetry_1.Telemetry.Current.send('AIHandler.aIHandler.ModelSelected', { modelId: model?.id || 'None' });
            if (!model) {
                stream.markdown("No suitable AI model found.");
                return;
            }
            // Tool calling loop
            let keepGoing = true;
            while (keepGoing && !token.isCancellationRequested) {
                keepGoing = false; // Default to stop unless we get a tool call
                const chatResponse = await model.sendRequest(messages, { tools }, token);
                let toolCalls = [];
                for await (const fragment of chatResponse.text) {
                    stream.markdown(fragment);
                }
                // Collect tool calls from the response
                for await (const part of chatResponse.stream) {
                    if (part instanceof vscode.LanguageModelToolCallPart) {
                        toolCalls.push(part);
                    }
                }
                // Execute tools if any were called
                if (toolCalls.length > 0) {
                    keepGoing = true; // We need to send results back to the model
                    // Add the model's response (including tool calls) to history
                    messages.push(vscode.LanguageModelChatMessage.Assistant(toolCalls));
                    for (const toolCall of toolCalls) {
                        stream.progress(`Calling: ${toolCall.name}`);
                        ui.logToOutput(`AI requested tool: ${toolCall.name} with input: ${JSON.stringify(toolCall.input)}`);
                        Telemetry_1.Telemetry.Current.send('AIHandler.aIHandler.ToolCalled', { toolName: toolCall.name, toolInput: JSON.stringify(toolCall.input) });
                        try {
                            // Invoke the tool using VS Code LM API
                            const result = await vscode.lm.invokeTool(toolCall.name, { input: toolCall.input }, token);
                            // Convert result to string/text part
                            const resultText = result.content
                                .filter(part => part instanceof vscode.LanguageModelTextPart)
                                .map(part => part.value)
                                .join('\n');
                            // Add result to history
                            messages.push(vscode.LanguageModelChatMessage.User([
                                new vscode.LanguageModelToolResultPart(toolCall.callId, [new vscode.LanguageModelTextPart(resultText)])
                            ]));
                        }
                        catch (err) {
                            Telemetry_1.Telemetry.Current.send('AIHandler.aIHandler.ToolCallFailed', { toolName: toolCall.name, error: err instanceof Error ? err.message : String(err) });
                            const errorMessage = `Tool execution failed: ${err instanceof Error ? err.message : String(err)}`;
                            messages.push(vscode.LanguageModelChatMessage.User([
                                new vscode.LanguageModelToolResultPart(toolCall.callId, [new vscode.LanguageModelTextPart(errorMessage)])
                            ]));
                        }
                    }
                }
            }
            // Final appreciation message
            if (usedAppreciated) {
                stream.markdown("\n\n\n");
                stream.markdown("\n🙏 [Donate](https://github.com/sponsors/necatiarslan) if you found me useful!");
                stream.markdown("\n🤔 Request a [New Feature](https://github.com/necatiarslan/airflow-vscode-extension/issues/new)");
                stream.markdown("\n🗳️ Attend [Survey](https://bit.ly/airflow-extension-survey) to help me get better. ");
            }
        }
        catch (err) {
            ui.logToOutput(`AIHandler.aIHandler Error: ${err instanceof Error ? err.message : String(err)}`);
            Telemetry_1.Telemetry.Current.send('AIHandler.aIHandler.Error', { error: err instanceof Error ? err.message : String(err) });
            if (err instanceof Error) {
                stream.markdown(`I'm sorry, I couldn't connect to the AI model: ${err.message}`);
            }
            else {
                stream.markdown("I'm sorry, I couldn't connect to the AI model.");
            }
            stream.markdown("\n🪲 Please [Report Bug](https://github.com/necatiarslan/airflow-vscode-extension/issues/new)");
        }
    }
    ;
    async isChatCommandAvailable() {
        const commands = await vscode.commands.getCommands(true); // 'true' includes internal commands
        return commands.includes('workbench.action.chat.open');
    }
    async askAI(dagId, fileToken) {
        ui.logToOutput('AIHandler.askAI Started');
        Telemetry_1.Telemetry.Current.send('AIHandler.askAI.Started');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        if (!await this.isChatCommandAvailable()) {
            ui.showErrorMessage('Chat command is not available. Please ensure you have access to VS Code AI features.');
            return;
        }
        let dagSourceCode = '';
        let latestDagLogs = '';
        // Fetch DAG Source Code
        const sourceResult = await Session_1.Session.Current.Api.getSourceCode(dagId, fileToken);
        if (sourceResult.isSuccessful) {
            dagSourceCode = sourceResult.result;
        }
        else {
            ui.showErrorMessage('Failed to fetch DAG source code for AI analysis.');
            return;
        }
        // Fetch Latest DAG Run Logs
        const logResult = await Session_1.Session.Current.Api.getLastDagRunLogText(dagId);
        if (logResult.isSuccessful) {
            latestDagLogs = logResult.result;
        }
        else {
            ui.showErrorMessage('Failed to fetch latest DAG run logs for AI analysis.');
            return;
        }
        await this.askAIWithContext({ code: dagSourceCode, logs: latestDagLogs, dag: dagId, dagRun: null, tasks: null, taskInstances: null });
    }
    async askAIWithContext(askAIContext) {
        this.askAIContext = askAIContext;
        const appName = vscode.env.appName;
        let commandId = '';
        if (appName.includes('Antigravity')) {
            // Antigravity replaces the Chat with an Agent workflow.
            // We must use the Agent Manager command instead.
            // **REPLACE WITH THE ACTUAL ANTIGRAVITY AGENT COMMAND ID**
            commandId = 'antigravity.startAgentTask';
        }
        else if (appName.includes('Code - OSS') || appName.includes('Visual Studio Code')) {
            // This is standard VS Code or VSCodium. Check for the legacy Chat command.
            commandId = 'workbench.action.chat.open';
        }
        else {
            // Unknown environment, default to checking if the command exists at all.
            commandId = 'workbench.action.chat.open';
        }
        await vscode.commands.executeCommand(commandId, {
            query: '@airflow Analyze the current logs'
        });
    }
    registerChatParticipant() {
        const participant = vscode.chat.createChatParticipant('airflow-ext.participant', AIHandler.Current.aIHandler.bind(AIHandler.Current));
        participant.iconPath = vscode.Uri.joinPath(Session_1.Session.Current.Context.extensionUri, 'media', 'ai-assistant-logo.png');
        Session_1.Session.Current.Context.subscriptions.push(participant);
    }
    registerAiTools() {
        // Register Language Model Tools for AI-powered control, monitoring, and debugging
        ui.logToOutput('Registering Language Model Tools...');
        // Initialize the API adapter (uses DagTreeView.Current.api dynamically)
        const airflowClient = new AirflowClientAdapter_1.AirflowClientAdapter();
        const context = Session_1.Session.Current.Context;
        // Register Tool 1: trigger_dag_run (Control)
        const triggerDagRunTool = vscode.lm.registerTool('trigger_dag_run', new TriggerDagRunTool_1.TriggerDagRunTool(airflowClient));
        context.subscriptions.push(triggerDagRunTool);
        ui.logToOutput('Registered tool: trigger_dag_run');
        // Register Tool 2: get_failed_runs (Monitoring)
        const getFailedRunsTool = vscode.lm.registerTool('get_failed_runs', new GetFailedRunsTool_1.GetFailedRunsTool(airflowClient));
        context.subscriptions.push(getFailedRunsTool);
        ui.logToOutput('Registered tool: get_failed_runs');
        // Register Tool 4: list_active_dags (Monitoring)
        const listActiveDagsTool = vscode.lm.registerTool('list_active_dags', new ListActiveDagsTool_1.ListActiveDagsTool(airflowClient));
        context.subscriptions.push(listActiveDagsTool);
        ui.logToOutput('Registered tool: list_active_dags');
        // Register Tool 5: list_paused_dags (Monitoring)
        const listPausedDagsTool = vscode.lm.registerTool('list_paused_dags', new ListPausedDagsTool_1.ListPausedDagsTool(airflowClient));
        context.subscriptions.push(listPausedDagsTool);
        ui.logToOutput('Registered tool: list_paused_dags');
        // Register Tool 6: get_running_dags (Monitoring)
        const getRunningDagsTool = vscode.lm.registerTool('get_running_dags', new GetRunningDagsTool_1.GetRunningDagsTool(airflowClient));
        context.subscriptions.push(getRunningDagsTool);
        ui.logToOutput('Registered tool: get_running_dags');
        // Register Tool 7: pause_dag (Control)
        const pauseDagTool = vscode.lm.registerTool('pause_dag', new PauseDagTool_1.PauseDagTool(airflowClient));
        context.subscriptions.push(pauseDagTool);
        ui.logToOutput('Registered tool: pause_dag');
        // Register Tool 8: unpause_dag (Control)
        const unpauseDagTool = vscode.lm.registerTool('unpause_dag', new UnpauseDagTool_1.UnpauseDagTool(airflowClient));
        context.subscriptions.push(unpauseDagTool);
        ui.logToOutput('Registered tool: unpause_dag');
        // Register Tool 9: get_dag_runs (Monitoring)
        const getDagRunsTool = vscode.lm.registerTool('get_dag_runs', new GetDagRunsTool_1.GetDagRunsTool(airflowClient));
        context.subscriptions.push(getDagRunsTool);
        ui.logToOutput('Registered tool: get_dag_runs');
        // Register Tool 10: cancel_dag_run (Control)
        const cancelDagRunTool = vscode.lm.registerTool('cancel_dag_run', new CancelDagRunTool_1.CancelDagRunTool(airflowClient));
        context.subscriptions.push(cancelDagRunTool);
        ui.logToOutput('Registered tool: cancel_dag_run');
        // Register Tool 11: analyse_dag_latest_run (Analysis)
        const analyseDagLatestRunTool = vscode.lm.registerTool('analyse_dag_latest_run', new AnalyseDagLatestRunTool_1.AnalyseDagLatestRunTool(airflowClient));
        context.subscriptions.push(analyseDagLatestRunTool);
        ui.logToOutput('Registered tool: analyse_dag_latest_run');
        // Register Tool 12: get_dag_history (Monitoring)
        const getDagHistoryTool = vscode.lm.registerTool('get_dag_history', new GetDagHistoryTool_1.GetDagHistoryTool(airflowClient));
        context.subscriptions.push(getDagHistoryTool);
        ui.logToOutput('Registered tool: get_dag_history');
        // Register Tool 13: get_dag_run_detail (Analysis)
        const getDagRunDetailTool = vscode.lm.registerTool('get_dag_run_detail', new GetDagRunDetailTool_1.GetDagRunDetailTool(airflowClient));
        context.subscriptions.push(getDagRunDetailTool);
        ui.logToOutput('Registered tool: get_dag_run_detail');
        // Register Tool 14: get_today (Utility)
        const getTodayTool = vscode.lm.registerTool('get_today', new GetTodayTool_1.GetTodayTool());
        context.subscriptions.push(getTodayTool);
        ui.logToOutput('Registered tool: get_today');
        // Register Tool 15: get_dag_source_code (Analysis)
        const getDagSourceCodeTool = vscode.lm.registerTool('get_dag_source_code', new GetDagSourceCodeTool_1.GetDagSourceCodeTool(airflowClient));
        context.subscriptions.push(getDagSourceCodeTool);
        ui.logToOutput('Registered tool: get_dag_source_code');
        // Register Tool 16: go_to_dag_view (Navigation)
        const goToDagViewTool = vscode.lm.registerTool('go_to_dag_view', new GoToDagViewTool_1.GoToDagViewTool());
        context.subscriptions.push(goToDagViewTool);
        ui.logToOutput('Registered tool: go_to_dag_view');
        // Register Tool 17: go_to_dag_log_view (Navigation)
        const goToDagLogViewTool = vscode.lm.registerTool('go_to_dag_log_view', new GoToDagLogViewTool_1.GoToDagLogViewTool());
        context.subscriptions.push(goToDagLogViewTool);
        ui.logToOutput('Registered tool: go_to_dag_log_view');
        // Register Tool 18: go_to_dag_run_history (Navigation)
        const goToDagRunHistoryTool = vscode.lm.registerTool('go_to_dag_run_history', new GoToDagRunHistoryTool_1.GoToDagRunHistoryTool());
        context.subscriptions.push(goToDagRunHistoryTool);
        ui.logToOutput('Registered tool: go_to_dag_run_history');
        // Register Tool 19: go_to_providers_view (Navigation)
        const goToProvidersViewTool = vscode.lm.registerTool('go_to_providers_view', new GoToProvidersViewTool_1.GoToProvidersViewTool());
        context.subscriptions.push(goToProvidersViewTool);
        ui.logToOutput('Registered tool: go_to_providers_view');
        // Register Tool 20: go_to_connections_view (Navigation)
        const goToConnectionsViewTool = vscode.lm.registerTool('go_to_connections_view', new GoToConnectionsViewTool_1.GoToConnectionsViewTool());
        context.subscriptions.push(goToConnectionsViewTool);
        ui.logToOutput('Registered tool: go_to_connections_view');
        // Register Tool 21: go_to_variables_view (Navigation)
        const goToVariablesViewTool = vscode.lm.registerTool('go_to_variables_view', new GoToVariablesViewTool_1.GoToVariablesViewTool());
        context.subscriptions.push(goToVariablesViewTool);
        ui.logToOutput('Registered tool: go_to_variables_view');
        // Register Tool 22: go_to_configs_view (Navigation)
        const goToConfigsViewTool = vscode.lm.registerTool('go_to_configs_view', new GoToConfigsViewTool_1.GoToConfigsViewTool());
        context.subscriptions.push(goToConfigsViewTool);
        ui.logToOutput('Registered tool: go_to_configs_view');
        // Register Tool 23: go_to_plugins_view (Navigation)
        const goToPluginsViewTool = vscode.lm.registerTool('go_to_plugins_view', new GoToPluginsViewTool_1.GoToPluginsViewTool());
        context.subscriptions.push(goToPluginsViewTool);
        ui.logToOutput('Registered tool: go_to_plugins_view');
        // Register Tool 24: go_to_server_health_view (Navigation)
        const goToServerHealthViewTool = vscode.lm.registerTool('go_to_server_health_view', new GoToServerHealthViewTool_1.GoToServerHealthViewTool());
        context.subscriptions.push(goToServerHealthViewTool);
        ui.logToOutput('Registered tool: go_to_server_health_view');
        ui.logToOutput('All Language Model Tools registered successfully');
    }
}
exports.AIHandler = AIHandler;


/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AirflowClientAdapter = void 0;
const Session_1 = __webpack_require__(5);
const MessageHub = __webpack_require__(159);
class AirflowClientAdapter {
    /**
     * Triggers a DAG run via POST /dags/{dag_id}/dagRuns
     *
     * @param dagId - The DAG identifier
     * @param configJson - JSON string containing the DAG run configuration (optional)
     * @param date - The logical date for the run (optional)
     * @returns Promise with the created DAG run result
     */
    async triggerDagRun(dagId, configJson = '{}', date) {
        // Validate JSON before calling API
        try {
            JSON.parse(configJson);
        }
        catch (error) {
            throw new Error(`Invalid JSON in config_json parameter: ${error instanceof Error ? error.message : String(error)}`);
        }
        const result = await Session_1.Session.Current.Api.triggerDag(dagId, configJson, date);
        if (!result.isSuccessful) {
            throw new Error(result.error?.message || 'Failed to trigger DAG run');
        }
        MessageHub.DagTriggered(this, dagId, result.result.dag_run_id);
        // Map the API response to our interface
        const apiResponse = result.result;
        return {
            dag_id: apiResponse.dag_id || dagId,
            dag_run_id: apiResponse.dag_run_id || apiResponse.run_id || '',
            state: apiResponse.state || 'queued',
            execution_date: apiResponse.execution_date || apiResponse.logical_date || new Date().toISOString(),
            logical_date: apiResponse.logical_date || apiResponse.execution_date || new Date().toISOString(),
            start_date: apiResponse.start_date,
            end_date: apiResponse.end_date,
            conf: apiResponse.conf
        };
    }
    /**
     * Queries for failed DAG runs using the Airflow API
     *
     * @param timeRangeHours - Number of hours to look back (default 24)
     * @param dagIdFilter - Optional DAG ID filter
     * @returns Promise with array of failed run summaries
     */
    async queryFailedRuns(timeRangeHours = 24, dagIdFilter) {
        const failedRuns = [];
        try {
            // If dagIdFilter is specified, query only that DAG
            if (dagIdFilter) {
                const result = await Session_1.Session.Current.Api.getDagRunHistory(dagIdFilter);
                if (result.isSuccessful && result.result?.dag_runs) {
                    failedRuns.push(...this.filterFailedRuns(result.result.dag_runs, timeRangeHours));
                }
            }
            else {
                // If no filter, we need to get the DAG list first, then query each
                const dagListResult = await Session_1.Session.Current.Api.getDagList();
                if (dagListResult.isSuccessful && dagListResult.result) {
                    // Handle both v1 (array) and v2 (object with dags property) responses
                    const resultData = dagListResult.result;
                    const dags = Array.isArray(resultData) ? resultData : (resultData.dags || []);
                    // Limit to first 20 DAGs to avoid too many API calls
                    const dagsToCheck = dags.slice(0, 20);
                    // Query each DAG's runs in parallel
                    const runPromises = dagsToCheck.map(async (dag) => {
                        try {
                            const dagId = dag.dag_id;
                            const runResult = await Session_1.Session.Current.Api.getDagRunHistory(dagId);
                            if (runResult.isSuccessful && runResult.result?.dag_runs) {
                                return this.filterFailedRuns(runResult.result.dag_runs, timeRangeHours);
                            }
                        }
                        catch (error) {
                            // Silently continue on error for individual DAGs
                            return [];
                        }
                        return [];
                    });
                    const results = await Promise.all(runPromises);
                    results.forEach(runs => failedRuns.push(...runs));
                }
            }
            return failedRuns;
        }
        catch (error) {
            throw new Error(`Failed to query failed runs: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Retrieves a list of DAGs filtered by paused state
     *
     * @param isPaused - Whether to list paused (true) or active (false) DAGs
     * @returns Promise with array of DAG summaries
     */
    async getDags(isPaused) {
        try {
            const dagListResult = await Session_1.Session.Current.Api.getDagList();
            if (!dagListResult.isSuccessful || !dagListResult.result) {
                throw new Error(dagListResult.error?.message || 'Failed to fetch DAG list');
            }
            // Handle both v1 (array) and v2 (object with dags property) responses
            const resultData = dagListResult.result;
            const dags = Array.isArray(resultData) ? resultData : (resultData.dags || []);
            return dags
                .filter((dag) => dag.is_paused === isPaused)
                .map((dag) => ({
                dag_id: dag.dag_id,
                is_paused: dag.is_paused,
                is_active: dag.is_active !== undefined ? dag.is_active : !dag.is_paused,
                description: dag.description,
                owners: dag.owners,
                tags: dag.tags
            }));
        }
        catch (error) {
            throw new Error(`Failed to get DAG list: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Retrieves a list of DAGs that are currently running
     *
     * @returns Promise with array of DAG summaries that have running DAG runs
     */
    async getRunningDags() {
        try {
            const dagListResult = await Session_1.Session.Current.Api.getDagList();
            if (!dagListResult.isSuccessful || !dagListResult.result) {
                throw new Error(dagListResult.error?.message || 'Failed to fetch DAG list');
            }
            const resultData = dagListResult.result;
            const dags = Array.isArray(resultData) ? resultData : (resultData.dags || []);
            // Filter and enrich DAGs with their latest run info
            const runningDags = [];
            for (const dag of dags) {
                if (dag.is_paused) {
                    continue; // Skip paused DAGs
                }
                try {
                    const latestRun = await this.getLatestDagRun(dag.dag_id);
                    if (latestRun && (latestRun.state === 'running' || latestRun.state === 'queued')) {
                        runningDags.push({
                            dag_id: dag.dag_id,
                            is_paused: dag.is_paused,
                            is_active: dag.is_active !== undefined ? dag.is_active : !dag.is_paused,
                            description: dag.description,
                            owners: dag.owners,
                            tags: dag.tags,
                            latest_run_state: latestRun.state,
                            latest_run_id: latestRun.dag_run_id
                        });
                    }
                }
                catch (error) {
                    // Continue if we can't get the latest run for a DAG
                    continue;
                }
            }
            return runningDags;
        }
        catch (error) {
            throw new Error(`Failed to get running DAGs: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Pauses or unpauses a DAG
     *
     * @param dagId - The DAG ID
     * @param isPaused - True to pause, false to unpause
     */
    async pauseDag(dagId, isPaused) {
        try {
            const result = await Session_1.Session.Current.Api.pauseDag(dagId, isPaused);
            if (!result.isSuccessful) {
                throw new Error(result.error?.message || `Failed to ${isPaused ? 'pause' : 'unpause'} DAG`);
            }
            MessageHub.DagPaused(this, dagId);
        }
        catch (error) {
            throw new Error(`Failed to change DAG state: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Retrieves the latest DAG run for a given DAG
     *
     * @param dagId - The DAG ID
     * @returns Promise with the latest DAG run result or undefined if not found
     */
    async getLatestDagRun(dagId) {
        try {
            const result = await Session_1.Session.Current.Api.getLastDagRun(dagId);
            if (!result.isSuccessful || !result.result) {
                return undefined;
            }
            const apiResponse = result.result;
            return {
                dag_id: apiResponse.dag_id || dagId,
                dag_run_id: apiResponse.dag_run_id || apiResponse.run_id || '',
                state: apiResponse.state || 'unknown',
                execution_date: apiResponse.execution_date || apiResponse.logical_date || new Date().toISOString(),
                logical_date: apiResponse.logical_date || apiResponse.execution_date || new Date().toISOString(),
                start_date: apiResponse.start_date,
                end_date: apiResponse.end_date,
                conf: apiResponse.conf
            };
        }
        catch (error) {
            // Return undefined on error to allow caller to handle
            return undefined;
        }
    }
    /**
     * Retrieves task instances for a specific DAG run
     *
     * @param dagId - The DAG ID
     * @param dagRunId - The DAG run ID
     * @returns Promise with array of task instances
     */
    async getTaskInstances(dagId, dagRunId) {
        try {
            const result = await Session_1.Session.Current.Api.getTaskInstances(dagId, dagRunId);
            if (!result.isSuccessful || !result.result) {
                return [];
            }
            // API v2 returns { task_instances: [...] }
            return result.result.task_instances || [];
        }
        catch (error) {
            return [];
        }
    }
    /**
     * Retrieves task log content
     *
     * @param dagId - The DAG ID
     * @param dagRunId - The DAG run ID
     * @param taskId - The task ID
     * @param tryNumber - The task attempt number
     * @returns Promise with the log content (truncated for LLM processing)
     */
    async getTaskLog(dagId, dagRunId, taskId, tryNumber) {
        try {
            // Use the existing getTaskInstanceLog method
            const result = await Session_1.Session.Current.Api.getTaskInstanceLogText(dagId, dagRunId, taskId);
            if (!result.isSuccessful) {
                throw new Error(result.error?.message || 'Failed to retrieve task log');
            }
            const logContent = result.result || '';
            // Truncate to last 400 characters for token efficiency
            if (logContent.length > 400) {
                return '...' + logContent.slice(-400);
            }
            return logContent;
        }
        catch (error) {
            throw new Error(`Failed to get task log: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Helper method to filter failed runs within the time range
     */
    filterFailedRuns(dagRuns, timeRangeHours) {
        const cutoffTime = new Date();
        cutoffTime.setHours(cutoffTime.getHours() - timeRangeHours);
        const failedStates = ['failed', 'upstream_failed', 'skipped'];
        return dagRuns
            .filter((run) => {
            // Filter by state
            if (!failedStates.includes(run.state)) {
                return false;
            }
            // Filter by time range
            const runDate = new Date(run.execution_date || run.logical_date || run.start_date);
            return runDate >= cutoffTime;
        })
            .map((run) => ({
            dag_id: run.dag_id,
            dag_run_id: run.dag_run_id || run.run_id,
            state: run.state,
            execution_date: run.execution_date || run.logical_date,
            logical_date: run.logical_date || run.execution_date,
            start_date: run.start_date,
            end_date: run.end_date,
            error_message: this.extractErrorMessage(run)
        }));
    }
    /**
     * Retrieves DAG run history for a specific DAG
     *
     * @param dagId - The DAG ID
     * @param date - Optional date filter (YYYY-MM-DD format)
     * @returns Promise with DAG runs data
     */
    async getDagRunHistory(dagId, date) {
        try {
            const result = await Session_1.Session.Current.Api.getDagRunHistory(dagId, date);
            if (!result.isSuccessful || !result.result) {
                throw new Error(result.error?.message || 'Failed to fetch DAG run history');
            }
            return result.result;
        }
        catch (error) {
            throw new Error(`Failed to get DAG run history: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Stops a running DAG run by setting its state to failed
     *
     * @param dagId - The DAG ID
     * @param dagRunId - The DAG run ID to stop
     */
    async cancelDagRun(dagId, dagRunId) {
        try {
            const result = await Session_1.Session.Current.Api.cancelDagRun(dagId, dagRunId);
            if (!result.isSuccessful) {
                throw new Error(result.error?.message || 'Failed to cancel DAG run');
            }
            MessageHub.DagRunCancelled(this, dagId, dagRunId);
        }
        catch (error) {
            throw new Error(`Failed to stop DAG run: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Retrieves the source code for a DAG
     *
     * @param dagId - The DAG ID
     * @returns Promise with the DAG source code
     */
    async getDagSource(dagId) {
        try {
            const result = await Session_1.Session.Current.Api.getSourceCode(dagId);
            if (!result.isSuccessful || !result.result) {
                throw new Error(result.error?.message || 'Failed to fetch DAG source code');
            }
            return result.result;
        }
        catch (error) {
            throw new Error(`Failed to get DAG source code: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Retrieves the source code for a DAG (handles both v1 and v2 APIs)
     * For v1 API, automatically fetches the file_token first
     *
     * @param dagId - The DAG ID
     * @returns Promise with the DAG source code
     */
    async getDagSourceCode(dagId) {
        try {
            // First, try to get DAG info to obtain file_token (needed for v1 API)
            const dagInfoResult = await Session_1.Session.Current.Api.getDagInfo(dagId);
            let fileToken;
            if (dagInfoResult.isSuccessful && dagInfoResult.result?.file_token) {
                fileToken = dagInfoResult.result.file_token;
            }
            // Now get the source code (fileToken is optional for v2)
            const result = await Session_1.Session.Current.Api.getSourceCode(dagId, fileToken);
            if (!result.isSuccessful || !result.result) {
                throw new Error(result.error?.message || 'Failed to fetch DAG source code');
            }
            return result.result;
        }
        catch (error) {
            throw new Error(`Failed to get DAG source code: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Helper to extract error message from DAG run
     */
    extractErrorMessage(run) {
        // Try to extract error information from the run object
        if (run.note) {
            return run.note;
        }
        if (run.state === 'failed') {
            return `DAG run failed`;
        }
        if (run.state === 'upstream_failed') {
            return `Upstream task(s) failed`;
        }
        if (run.state === 'skipped') {
            return `DAG run was skipped`;
        }
        return undefined;
    }
}
exports.AirflowClientAdapter = AirflowClientAdapter;


/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * TriggerDagRunTool - Language Model Tool for triggering Airflow DAG runs
 *
 * This tool implements a state-changing action that requires explicit user confirmation
 * via the prepareInvocation method. It displays the target DAG ID and configuration
 * payload in a markdown-formatted confirmation dialog before execution.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TriggerDagRunTool = void 0;
const vscode = __webpack_require__(1);
const fs = __webpack_require__(3);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * TriggerDagRunTool - Implements vscode.LanguageModelTool for DAG triggering
 */
class TriggerDagRunTool {
    constructor(client) {
        this.client = client;
    }
    /**
     * SECURITY CRITICAL: Prepare invocation with user confirmation
     *
     * This method is called before invoke() and provides a confirmation gate
     * for the user to review the exact DAG and configuration before triggering.
     *
     * @param options - Contains the parsed input parameters
     * @param token - Cancellation token
     * @returns PreparedToolInvocation with confirmation message
     */
    async prepareInvocation(options, token) {
        const { dagId, configJson, date } = options.input;
        // Process configJson: check if it's a file path
        let finalConfig = configJson || '{}';
        let configSource = 'Inline';
        if (configJson && !configJson.trim().startsWith('{')) {
            // Assume it's a file path if it doesn't start with {
            try {
                // Remove quotes if present
                const filePath = configJson.replace(/^['"]|['"]$/g, '');
                if (fs.existsSync(filePath)) {
                    finalConfig = fs.readFileSync(filePath, 'utf8');
                    configSource = `File: ${filePath}`;
                }
            }
            catch (error) {
                // If read fails, keep original string (validation will happen later)
                console.warn(`Failed to read config file: ${error}`);
            }
        }
        // Validate JSON
        try {
            JSON.parse(finalConfig);
        }
        catch (e) {
            throw new Error(`Invalid JSON configuration: ${e instanceof Error ? e.message : String(e)}`);
        }
        const confirmationMessage = new vscode.MarkdownString();
        confirmationMessage.isTrusted = true;
        confirmationMessage.appendMarkdown('## ⚠️ Trigger DAG Confirmation\n\n');
        confirmationMessage.appendMarkdown(`You are about to trigger the following DAG:\n\n`);
        confirmationMessage.appendMarkdown(`**DAG ID:** \`${dagId}\`\n`);
        if (date) {
            confirmationMessage.appendMarkdown(`**Logical Date:** \`${date}\`\n`);
        }
        confirmationMessage.appendMarkdown(`**Config Source:** ${configSource}\n\n`);
        confirmationMessage.appendMarkdown('**Configuration Payload:**\n');
        confirmationMessage.appendCodeblock(finalConfig, 'json');
        confirmationMessage.appendMarkdown('\nDo you want to proceed?');
        return {
            invocationMessage: `Triggering DAG: ${dagId}`,
            confirmationMessages: {
                title: 'Confirm DAG Trigger',
                message: confirmationMessage
            }
        };
    }
    /**
     * Execute the DAG trigger action
     *
     * @param options - Contains the validated input parameters
     * @param token - Cancellation token
     * @returns LanguageModelToolResult with success/error information
     */
    async invoke(options, token) {
        const { dagId, configJson, date } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('TriggerDagRunTool.invoke');
        try {
            // Re-process config for invoke (same logic as prepare)
            let finalConfig = configJson || '{}';
            if (configJson && !configJson.trim().startsWith('{')) {
                try {
                    const filePath = configJson.replace(/^['"]|['"]$/g, '');
                    if (fs.existsSync(filePath)) {
                        finalConfig = fs.readFileSync(filePath, 'utf8');
                    }
                }
                catch (error) {
                    // Ignore error here, will fail at JSON parse in client
                }
            }
            const result = await this.client.triggerDagRun(dagId, finalConfig, date);
            const message = [
                `✅ **Success!** DAG Run triggered.`,
                ``,
                `- **DAG ID:** ${result.dag_id}`,
                `- **Run ID:** ${result.dag_run_id}`,
                `- **State:** ${result.state}`,
                `- **Logical Date:** ${result.logical_date}`,
                date ? `- **Requested Date:** ${date}` : ''
            ].filter(Boolean).join('\n');
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(message)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('TriggerDagRunTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to trigger DAG ${dagId}: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.TriggerDagRunTool = TriggerDagRunTool;


/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GetFailedRunsTool - Language Model Tool for monitoring failed DAG runs
 *
 * This tool implements a read-only observability action that retrieves
 * failed DAG runs from Airflow. It does not require user confirmation
 * since it's a non-destructive operation.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFailedRunsTool = void 0;
const vscode = __webpack_require__(1);
const Telemetry_1 = __webpack_require__(9);
/**
 * GetFailedRunsTool - Implements vscode.LanguageModelTool for monitoring
 */
class GetFailedRunsTool {
    constructor(client) {
        this.client = client;
    }
    /**
     * Prepare invocation - minimal for read-only operations
     *
     * Since this is a read-only monitoring tool, we don't need extensive
     * confirmation dialogs. This method can return undefined or a simple message.
     *
     * @param options - Contains the parsed input parameters
     * @param token - Cancellation token
     * @returns PreparedToolInvocation or undefined
     */
    async prepareInvocation(options, token) {
        const timeRange = options.input.timeRangeHours || 24;
        const dagFilter = options.input.dagIdFilter;
        const message = dagFilter
            ? `Querying failed runs for DAG '${dagFilter}' (last ${timeRange} hours)`
            : `Querying all failed runs (last ${timeRange} hours)`;
        return {
            invocationMessage: message
        };
    }
    /**
     * Execute the query for failed DAG runs
     *
     * @param options - Contains the validated input parameters
     * @param token - Cancellation token
     * @returns LanguageModelToolResult with failed runs data
     */
    async invoke(options, token) {
        const timeRange = options.input.timeRangeHours || 24;
        const dagFilter = options.input.dagIdFilter;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GetFailedRunsTool.invoke');
        try {
            // Call the mock API client to get failed runs
            const failedRuns = await this.client.queryFailedRuns(timeRange, dagFilter);
            // Format the response for the LLM
            if (failedRuns.length === 0) {
                const noFailuresMessage = dagFilter
                    ? `✅ No failed runs found for DAG '${dagFilter}' in the last ${timeRange} hours.`
                    : `✅ No failed runs found in the last ${timeRange} hours. All DAGs are healthy!`;
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(noFailuresMessage)
                ]);
            }
            // Build a detailed summary
            let summaryMessage = `## ⚠️ Failed DAG Runs Report\n\n`;
            summaryMessage += `**Time Range:** Last ${timeRange} hours\n`;
            if (dagFilter) {
                summaryMessage += `**DAG Filter:** ${dagFilter}\n`;
            }
            summaryMessage += `**Total Failed Runs:** ${failedRuns.length}\n\n`;
            summaryMessage += `---\n\n`;
            // Add individual run details
            failedRuns.forEach((run, index) => {
                summaryMessage += `### ${index + 1}. ${run.dag_id}\n\n`;
                summaryMessage += `- **Run ID:** \`${run.dag_run_id}\`\n`;
                summaryMessage += `- **State:** ${run.state}\n`;
                summaryMessage += `- **Execution Date:** ${run.execution_date}\n`;
                summaryMessage += `- **Logical Date:** ${run.logical_date}\n`;
                if (run.start_date) {
                    summaryMessage += `- **Started:** ${run.start_date}\n`;
                }
                if (run.end_date) {
                    summaryMessage += `- **Ended:** ${run.end_date}\n`;
                }
                if (run.error_message) {
                    summaryMessage += `- **Error:** ${run.error_message}\n`;
                }
                summaryMessage += `\n`;
            });
            // Also include raw JSON for LLM processing
            summaryMessage += `\n---\n\n**Raw Data (JSON):**\n\n`;
            summaryMessage += `\`\`\`json\n${JSON.stringify(failedRuns, null, 2)}\n\`\`\`\n`;
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(summaryMessage)
            ]);
        }
        catch (error) {
            // Handle errors gracefully
            const errorMessage = `
❌ Failed to Query DAG Runs

**Error:** ${error instanceof Error ? error.message : String(error)}

Please check:
- The Airflow server is accessible
- You have the necessary permissions
- The time range and filters are valid
            `.trim();
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GetFailedRunsTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(errorMessage)
            ]);
        }
    }
}
exports.GetFailedRunsTool = GetFailedRunsTool;


/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * ListActiveDagsTool - Language Model Tool for listing active DAGs
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListActiveDagsTool = void 0;
const vscode = __webpack_require__(1);
const Telemetry_1 = __webpack_require__(9);
class ListActiveDagsTool {
    constructor(client) {
        this.client = client;
    }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: "Listing active DAGs..."
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('ListActiveDagsTool.invoke');
        try {
            const dags = await this.client.getDags(false); // false = active (not paused)
            if (dags.length === 0) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart("✅ No active DAGs found.")
                ]);
            }
            let message = `## 🟢 Active DAGs (${dags.length})\n\n`;
            dags.forEach(dag => {
                message += `- **${dag.dag_id}**`;
                if (dag.description) {
                    message += `: ${dag.description}`;
                }
                message += `\n`;
            });
            message += `\n---\n**Raw Data:**\n\`\`\`json\n${JSON.stringify(dags, null, 2)}\n\`\`\``;
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(message)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('ListActiveDagsTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to list active DAGs: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.ListActiveDagsTool = ListActiveDagsTool;


/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * ListPausedDagsTool - Language Model Tool for listing paused DAGs
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListPausedDagsTool = void 0;
const vscode = __webpack_require__(1);
const Telemetry_1 = __webpack_require__(9);
class ListPausedDagsTool {
    constructor(client) {
        this.client = client;
    }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: "Listing paused DAGs..."
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('ListPausedDagsTool.invoke');
        try {
            const dags = await this.client.getDags(true); // true = paused
            if (dags.length === 0) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart("✅ No paused DAGs found.")
                ]);
            }
            let message = `## ⏸️ Paused DAGs (${dags.length})\n\n`;
            dags.forEach(dag => {
                message += `- **${dag.dag_id}**`;
                if (dag.description) {
                    message += `: ${dag.description}`;
                }
                message += `\n`;
            });
            message += `\n---\n**Raw Data:**\n\`\`\`json\n${JSON.stringify(dags, null, 2)}\n\`\`\``;
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(message)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('ListPausedDagsTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to list paused DAGs: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.ListPausedDagsTool = ListPausedDagsTool;


/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GetRunningDagsTool - Language Model Tool for listing currently running DAGs
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRunningDagsTool = void 0;
const vscode = __webpack_require__(1);
const Telemetry_1 = __webpack_require__(9);
class GetRunningDagsTool {
    constructor(client) {
        this.client = client;
    }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: "Checking for running DAGs..."
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GetRunningDagsTool.invoke');
        try {
            const runningDags = await this.client.getRunningDags();
            if (runningDags.length === 0) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart("✅ No DAGs are currently running.")
                ]);
            }
            let message = `## ▶️ Running DAGs (${runningDags.length})\n\n`;
            runningDags.forEach(dag => {
                const stateEmoji = dag.latest_run_state === 'running' ? '▶️' : '⏳';
                message += `- ${stateEmoji} **${dag.dag_id}** - State: ${dag.latest_run_state}, Run ID: \`${dag.latest_run_id}\``;
                if (dag.description) {
                    message += `\n  Description: ${dag.description}`;
                }
                if (dag.owners && dag.owners.length > 0) {
                    message += `\n  Owners: ${dag.owners.join(', ')}`;
                }
                message += `\n`;
            });
            message += `\n---\n**Raw Data:**\n\`\`\`json\n${JSON.stringify(runningDags, null, 2)}\n\`\`\``;
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(message)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GetRunningDagsTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to get running DAGs: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GetRunningDagsTool = GetRunningDagsTool;


/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * PauseDagTool - Language Model Tool for pausing a DAG
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PauseDagTool = void 0;
const vscode = __webpack_require__(1);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
class PauseDagTool {
    constructor(client) {
        this.client = client;
    }
    async prepareInvocation(options, token) {
        const { dagId } = options.input;
        const confirmationMessage = new vscode.MarkdownString();
        confirmationMessage.isTrusted = true;
        confirmationMessage.appendMarkdown('## ⚠️ Pause DAG Confirmation\n\n');
        confirmationMessage.appendMarkdown(`You are about to **PAUSE** the following DAG:\n\n`);
        confirmationMessage.appendMarkdown(`**DAG ID:** \`${dagId}\`\n\n`);
        confirmationMessage.appendMarkdown('**Effect:** No new runs will be scheduled for this DAG.\n\n');
        confirmationMessage.appendMarkdown('Do you want to proceed?');
        return {
            invocationMessage: `Pausing DAG: ${dagId}`,
            confirmationMessages: {
                title: 'Confirm Pause DAG',
                message: confirmationMessage
            }
        };
    }
    async invoke(options, token) {
        const { dagId } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('PauseDagTool.invoke');
        try {
            await this.client.pauseDag(dagId, true); // true = pause
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`✅ Successfully PAUSED DAG: **${dagId}**`)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('PauseDagTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to pause DAG ${dagId}: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.PauseDagTool = PauseDagTool;


/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * UnpauseDagTool - Language Model Tool for unpausing (activating) a DAG
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnpauseDagTool = void 0;
const vscode = __webpack_require__(1);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
class UnpauseDagTool {
    constructor(client) {
        this.client = client;
    }
    async prepareInvocation(options, token) {
        const { dagId } = options.input;
        const confirmationMessage = new vscode.MarkdownString();
        confirmationMessage.isTrusted = true;
        confirmationMessage.appendMarkdown('## ⚠️ Unpause DAG Confirmation\n\n');
        confirmationMessage.appendMarkdown(`You are about to **UNPAUSE** (activate) the following DAG:\n\n`);
        confirmationMessage.appendMarkdown(`**DAG ID:** \`${dagId}\`\n\n`);
        confirmationMessage.appendMarkdown('**Effect:** New runs will be scheduled for this DAG.\n\n');
        confirmationMessage.appendMarkdown('Do you want to proceed?');
        return {
            invocationMessage: `Unpausing DAG: ${dagId}`,
            confirmationMessages: {
                title: 'Confirm Unpause DAG',
                message: confirmationMessage
            }
        };
    }
    async invoke(options, token) {
        const { dagId } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('UnpauseDagTool.invoke');
        try {
            await this.client.pauseDag(dagId, false); // false = unpause
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`✅ Successfully UNPAUSED DAG: **${dagId}**`)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('UnpauseDagTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to unpause DAG ${dagId}: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.UnpauseDagTool = UnpauseDagTool;


/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GetDagRunsTool - Language Model Tool for retrieving DAG runs
 *
 * This tool retrieves the runs for a specific DAG, optionally filtered by date.
 * Returns run ID, start time, duration, and status for each run.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDagRunsTool = void 0;
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * GetDagRunsTool - Implements vscode.LanguageModelTool for retrieving DAG runs
 */
class GetDagRunsTool {
    constructor(client) {
        this.client = client;
    }
    /**
     * Prepare invocation - minimal for read-only operations
     */
    async prepareInvocation(options, token) {
        const { dagId, date } = options.input;
        const dateStr = date || ui.toISODateString(new Date());
        return {
            invocationMessage: `Retrieving runs for DAG '${dagId}' (date: ${dateStr})`
        };
    }
    /**
     * Execute the query for DAG runs
     */
    async invoke(options, token) {
        const { dagId, date } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GetDagRunsTool.invoke');
        try {
            // Get DAG run history from the API
            const result = await this.client.getDagRunHistory(dagId);
            if (!result || !result.dag_runs || result.dag_runs.length === 0) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`ℹ️ No runs found for DAG '${dagId}'.`)
                ]);
            }
            let runs = result.dag_runs;
            // Filter by date if provided
            if (date) {
                const targetDate = new Date(date);
                runs = runs.filter((run) => {
                    const runDate = new Date(run.execution_date || run.logical_date);
                    return ui.toISODateString(runDate) === ui.toISODateString(targetDate);
                });
                if (runs.length === 0) {
                    return new vscode.LanguageModelToolResult([
                        new vscode.LanguageModelTextPart(`ℹ️ No runs found for DAG '${dagId}' on ${date}.`)
                    ]);
                }
            }
            // Build detailed summary
            let summaryMessage = `## 📊 DAG Runs for '${dagId}'\n\n`;
            if (date) {
                summaryMessage += `**Date Filter:** ${date}\n`;
            }
            else {
                summaryMessage += `**Date Filter:** Today (${ui.toISODateString(new Date())})\n`;
            }
            summaryMessage += `**Total Runs:** ${runs.length}\n\n`;
            summaryMessage += `---\n\n`;
            // Add individual run details
            runs.forEach((run, index) => {
                const startTime = run.start_date || run.execution_date || 'N/A';
                const endTime = run.end_date || 'N/A';
                let duration = 'N/A';
                if (run.start_date && run.end_date) {
                    const start = new Date(run.start_date);
                    const end = new Date(run.end_date);
                    const durationMs = end.getTime() - start.getTime();
                    const durationSec = Math.floor(durationMs / 1000);
                    const minutes = Math.floor(durationSec / 60);
                    const seconds = durationSec % 60;
                    duration = `${minutes}m ${seconds}s`;
                }
                const status = run.state || 'unknown';
                const statusEmoji = this.getStatusEmoji(status);
                summaryMessage += `### ${index + 1}. Run: ${run.dag_run_id || run.run_id}\n\n`;
                summaryMessage += `- **Status:** ${statusEmoji} ${status}\n`;
                summaryMessage += `- **Start Time:** ${startTime}\n`;
                if (endTime !== 'N/A') {
                    summaryMessage += `- **End Time:** ${endTime}\n`;
                }
                summaryMessage += `- **Duration:** ${duration}\n`;
                summaryMessage += `- **Execution Date:** ${run.execution_date || run.logical_date}\n`;
                summaryMessage += `\n`;
            });
            // Include raw JSON for LLM processing
            summaryMessage += `\n---\n\n**Raw Data (JSON):**\n\n`;
            summaryMessage += `\`\`\`json\n${JSON.stringify(runs, null, 2)}\n\`\`\`\n`;
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(summaryMessage)
            ]);
        }
        catch (error) {
            const errorMessage = `
❌ Failed to retrieve DAG runs

**Error:** ${error instanceof Error ? error.message : String(error)}

Please check:
- The DAG ID is correct
- The Airflow server is accessible
- You have the necessary permissions
            `.trim();
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GetDagRunsTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(errorMessage)
            ]);
        }
    }
    /**
     * Helper to get emoji for run status
     */
    getStatusEmoji(status) {
        const statusMap = {
            'success': '✅',
            'failed': '❌',
            'running': '▶️',
            'queued': '⏳',
            'upstream_failed': '⚠️',
            'skipped': '⏭️',
            'up_for_retry': '🔄',
            'up_for_reschedule': '📅',
            'removed': '🗑️',
            'scheduled': '📆'
        };
        return statusMap[status.toLowerCase()] || '❓';
    }
}
exports.GetDagRunsTool = GetDagRunsTool;


/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * CancelDagRunTool - Language Model Tool for cancelling a running DAG run
 *
 * This tool cancels the currently running DAG run for a specific DAG.
 * It requires user confirmation since it's a state-changing operation.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancelDagRunTool = void 0;
const vscode = __webpack_require__(1);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * CancelDagRunTool - Implements vscode.LanguageModelTool for cancelling DAG runs
 */
class CancelDagRunTool {
    constructor(client) {
        this.client = client;
    }
    /**
     * Prepare invocation with user confirmation
     */
    async prepareInvocation(options, token) {
        const { dagId } = options.input;
        // Try to get the current running DAG run
        let runInfo = '';
        try {
            const latestRun = await this.client.getLatestDagRun(dagId);
            if (latestRun && (latestRun.state === 'running' || latestRun.state === 'queued')) {
                runInfo = `\n**Current Run:** \`${latestRun.dag_run_id}\`\n**State:** ${latestRun.state}\n\n`;
            }
        }
        catch (error) {
            // Ignore error, proceed with generic confirmation
        }
        const confirmationMessage = new vscode.MarkdownString();
        confirmationMessage.isTrusted = true;
        confirmationMessage.appendMarkdown('## ⚠️ Cancel DAG Run Confirmation\n\n');
        confirmationMessage.appendMarkdown(`You are about to **CANCEL** the running DAG run for:\n\n`);
        confirmationMessage.appendMarkdown(`**DAG ID:** \`${dagId}\`\n`);
        if (runInfo) {
            confirmationMessage.appendMarkdown(runInfo);
        }
        confirmationMessage.appendMarkdown('**Effect:** The current DAG run will be marked as failed and cancelled.\n\n');
        confirmationMessage.appendMarkdown('Do you want to proceed?');
        return {
            invocationMessage: `Cancelling DAG run: ${dagId}`,
            confirmationMessages: {
                title: 'Confirm Cancel DAG Run',
                message: confirmationMessage
            }
        };
    }
    /**
     * Execute the cancel DAG run action
     */
    async invoke(options, token) {
        const { dagId } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('CancelDagRunTool.invoke');
        try {
            // First, get the latest DAG run to find the running one
            const latestRun = await this.client.getLatestDagRun(dagId);
            if (!latestRun) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`ℹ️ No DAG run found for '${dagId}'.`)
                ]);
            }
            // Check if the latest run is actually running
            if (latestRun.state !== 'running' && latestRun.state !== 'queued') {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`ℹ️ DAG '${dagId}' is not currently running.\n\nLatest run state: **${latestRun.state}**\nRun ID: \`${latestRun.dag_run_id}\``)
                ]);
            }
            // Cancel the DAG run
            await this.client.cancelDagRun(dagId, latestRun.dag_run_id);
            const message = [
                `✅ **Success!** DAG run cancelled.`,
                ``,
                `- **DAG ID:** ${dagId}`,
                `- **Run ID:** ${latestRun.dag_run_id}`,
                `- **Previous State:** ${latestRun.state}`,
                ``,
                `The DAG run has been marked as failed and cancelled.`
            ].join('\n');
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(message)
            ]);
        }
        catch (error) {
            Telemetry_1.Telemetry.Current.sendError('CancelDagRunTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to cancel DAG run for ${dagId}: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.CancelDagRunTool = CancelDagRunTool;


/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * AnalyseDagLatestRunTool - Language Model Tool for comprehensive DAG run analysis
 *
 * This tool retrieves comprehensive information about the latest DAG run including:
 * - DAG run details
 * - Task instances
 * - DAG source code
 * - Task logs
 *
 * It provides a complete analysis to help diagnose issues and understand execution.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyseDagLatestRunTool = void 0;
const vscode = __webpack_require__(1);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * AnalyseDagLatestRunTool - Implements vscode.LanguageModelTool for comprehensive DAG analysis
 */
class AnalyseDagLatestRunTool {
    constructor(client) {
        this.client = client;
    }
    /**
     * Prepare invocation
     */
    async prepareInvocation(options, token) {
        const { dagId } = options.input;
        return {
            invocationMessage: `Analyzing latest run for DAG '${dagId}'...`
        };
    }
    /**
     * Execute comprehensive DAG run analysis
     */
    async invoke(options, token) {
        const { dagId } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('AnalyseDagLatestRunTool.invoke');
        try {
            // Step 1: Get the latest DAG run
            const dagRun = await this.client.getLatestDagRun(dagId);
            if (!dagRun) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`ℹ️ No DAG run found for '${dagId}'.`)
                ]);
            }
            // Step 2: Get task instances for this run
            const taskInstances = await this.client.getTaskInstances(dagId, dagRun.dag_run_id);
            // Step 3: Get DAG source code
            let dagSourceCode = 'N/A';
            try {
                dagSourceCode = await this.client.getDagSource(dagId);
            }
            catch (error) {
                dagSourceCode = `Failed to retrieve source code: ${error instanceof Error ? error.message : String(error)}`;
            }
            // Step 4: Get logs for each task (focusing on failed tasks first, then all)
            const taskLogs = [];
            // Sort tasks: failed first, then by execution order
            const sortedTasks = [...taskInstances].sort((a, b) => {
                const failedStates = ['failed', 'upstream_failed'];
                const aFailed = failedStates.includes(a.state);
                const bFailed = failedStates.includes(b.state);
                if (aFailed && !bFailed)
                    return -1;
                if (!aFailed && bFailed)
                    return 1;
                return 0;
            });
            // Get logs for up to 5 tasks (prioritizing failed tasks)
            const tasksToLog = sortedTasks.slice(0, 5);
            for (const task of tasksToLog) {
                try {
                    const log = await this.client.getTaskLog(dagId, dagRun.dag_run_id, task.task_id, task.try_number?.toString() || '1');
                    taskLogs.push({
                        task_id: task.task_id,
                        state: task.state,
                        log: log
                    });
                }
                catch (error) {
                    taskLogs.push({
                        task_id: task.task_id,
                        state: task.state,
                        log: `Failed to retrieve log: ${error instanceof Error ? error.message : String(error)}`
                    });
                }
            }
            // Build comprehensive analysis report
            let report = this.buildAnalysisReport(dagId, dagRun, taskInstances, dagSourceCode, taskLogs);
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(report)
            ]);
        }
        catch (error) {
            const errorMessage = `
❌ Failed to analyze DAG run

**Error:** ${error instanceof Error ? error.message : String(error)}

Please check:
- The DAG ID is correct
- The Airflow server is accessible
- You have the necessary permissions
            `.trim();
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('AnalyseDagLatestRunTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(errorMessage)
            ]);
        }
    }
    /**
     * Build comprehensive analysis report
     */
    buildAnalysisReport(dagId, dagRun, taskInstances, dagSourceCode, taskLogs) {
        let report = `# 🔍 Comprehensive DAG Run Analysis\n\n`;
        report += `## DAG: ${dagId}\n\n`;
        report += `---\n\n`;
        // Section 1: DAG Run Overview
        report += `## 📊 DAG Run Overview\n\n`;
        report += `- **Run ID:** \`${dagRun.dag_run_id}\`\n`;
        report += `- **State:** ${this.getStatusEmoji(dagRun.state)} **${dagRun.state}**\n`;
        report += `- **Execution Date:** ${dagRun.execution_date}\n`;
        report += `- **Logical Date:** ${dagRun.logical_date}\n`;
        if (dagRun.start_date) {
            report += `- **Start Date:** ${dagRun.start_date}\n`;
        }
        if (dagRun.end_date) {
            report += `- **End Date:** ${dagRun.end_date}\n`;
            // Calculate duration
            const start = new Date(dagRun.start_date);
            const end = new Date(dagRun.end_date);
            const durationMs = end.getTime() - start.getTime();
            const durationSec = Math.floor(durationMs / 1000);
            const minutes = Math.floor(durationSec / 60);
            const seconds = durationSec % 60;
            report += `- **Duration:** ${minutes}m ${seconds}s\n`;
        }
        report += `\n---\n\n`;
        // Section 2: Task Instances Summary
        report += `## 📋 Task Instances (${taskInstances.length} tasks)\n\n`;
        // Group tasks by state
        const tasksByState = {};
        taskInstances.forEach((task) => {
            const state = task.state || 'unknown';
            if (!tasksByState[state]) {
                tasksByState[state] = [];
            }
            tasksByState[state].push(task);
        });
        // Display summary by state
        for (const [state, tasks] of Object.entries(tasksByState)) {
            report += `### ${this.getStatusEmoji(state)} ${state} (${tasks.length})\n`;
            tasks.forEach((task) => {
                report += `- **${task.task_id}**`;
                if (task.duration) {
                    report += ` - Duration: ${Math.round(task.duration)}s`;
                }
                if (task.start_date) {
                    report += ` - Started: ${task.start_date}`;
                }
                report += `\n`;
            });
            report += `\n`;
        }
        report += `---\n\n`;
        // Section 3: Task Logs Analysis
        if (taskLogs.length > 0) {
            report += `## 📝 Task Logs (Top ${taskLogs.length} tasks)\n\n`;
            taskLogs.forEach((taskLog, index) => {
                report += `### ${index + 1}. Task: ${taskLog.task_id} (${this.getStatusEmoji(taskLog.state)} ${taskLog.state})\n\n`;
                report += `\`\`\`\n${taskLog.log}\n\`\`\`\n\n`;
            });
            report += `---\n\n`;
        }
        // Section 4: DAG Source Code
        report += `## 💻 DAG Source Code\n\n`;
        report += `\`\`\`python\n${dagSourceCode}\n\`\`\`\n\n`;
        report += `---\n\n`;
        // Section 5: Raw Data
        report += `## 📦 Raw Data (JSON)\n\n`;
        report += `### DAG Run\n\`\`\`json\n${JSON.stringify(dagRun, null, 2)}\n\`\`\`\n\n`;
        report += `### Task Instances\n\`\`\`json\n${JSON.stringify(taskInstances, null, 2)}\n\`\`\`\n\n`;
        // Section 6: Analysis Prompt
        report += `---\n\n`;
        report += `## 🤖 Analysis Request\n\n`;
        report += `Please analyze the above information and provide:\n`;
        report += `1. **Summary of Execution:** What happened during this DAG run?\n`;
        report += `2. **Issues Identified:** What errors or problems occurred?\n`;
        report += `3. **Root Cause Analysis:** What likely caused any failures?\n`;
        report += `4. **Recommendations:** How can these issues be resolved?\n`;
        report += `5. **Code Review:** Any issues in the DAG code that need attention?\n`;
        return report;
    }
    /**
     * Helper to get emoji for task/run status
     */
    getStatusEmoji(status) {
        const statusMap = {
            'success': '✅',
            'failed': '❌',
            'running': '▶️',
            'queued': '⏳',
            'upstream_failed': '⚠️',
            'skipped': '⏭️',
            'up_for_retry': '🔄',
            'up_for_reschedule': '📅',
            'removed': '🗑️',
            'scheduled': '📆',
            'none': '⚪',
            'unknown': '❓'
        };
        return statusMap[status?.toLowerCase()] || '❓';
    }
}
exports.AnalyseDagLatestRunTool = AnalyseDagLatestRunTool;


/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GetDagHistoryTool - Language Model Tool for retrieving DAG run history
 *
 * This tool retrieves the run history for a specific DAG, optionally filtered by date.
 * Returns date of run, status, duration, and notes for each run.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDagHistoryTool = void 0;
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * GetDagHistoryTool - Implements vscode.LanguageModelTool for retrieving DAG history
 */
class GetDagHistoryTool {
    constructor(client) {
        this.client = client;
    }
    /**
     * Prepare invocation - minimal for read-only operations
     */
    async prepareInvocation(options, token) {
        const { dagId, date } = options.input;
        const dateStr = date || ui.toISODateString(new Date());
        return {
            invocationMessage: `Retrieving history for DAG '${dagId}' (date: ${dateStr})`
        };
    }
    /**
     * Execute the query for DAG history
     */
    async invoke(options, token) {
        const { dagId, date } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GetDagHistoryTool.invoke');
        // Use today's date if not provided
        const queryDate = date || ui.toISODateString(new Date());
        try {
            // Get DAG run history from the API
            const result = await this.client.getDagRunHistory(dagId, queryDate);
            if (!result || !result.dag_runs || result.dag_runs.length === 0) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`ℹ️ No run history found for DAG '${dagId}' on ${queryDate}.`)
                ]);
            }
            const runs = result.dag_runs;
            // Build detailed summary
            let summaryMessage = `## 📜 DAG Run History for '${dagId}'\n\n`;
            summaryMessage += `**Date Filter:** ${queryDate}\n`;
            summaryMessage += `**Total Runs:** ${runs.length}\n\n`;
            summaryMessage += `---\n\n`;
            // Add individual run details in a table-like format
            summaryMessage += `| # | Date/Time | Status | Duration | Note |\n`;
            summaryMessage += `|---|-----------|--------|----------|------|\n`;
            runs.forEach((run, index) => {
                const runDate = run.execution_date || run.logical_date || 'N/A';
                const status = this.getStatusEmoji(run.state) + ' ' + (run.state || 'unknown');
                let duration = 'N/A';
                if (run.start_date && run.end_date) {
                    const start = new Date(run.start_date);
                    const end = new Date(run.end_date);
                    const durationMs = end.getTime() - start.getTime();
                    const durationSec = Math.floor(durationMs / 1000);
                    const minutes = Math.floor(durationSec / 60);
                    const seconds = durationSec % 60;
                    duration = `${minutes}m ${seconds}s`;
                }
                else if (run.start_date && !run.end_date) {
                    duration = '⏳ Running';
                }
                const note = run.note || '-';
                summaryMessage += `| ${index + 1} | ${runDate} | ${status} | ${duration} | ${note} |\n`;
            });
            summaryMessage += `\n---\n\n`;
            // Add detailed breakdown
            summaryMessage += `### Detailed Breakdown\n\n`;
            runs.forEach((run, index) => {
                summaryMessage += `#### ${index + 1}. Run ID: ${run.dag_run_id || run.run_id}\n\n`;
                summaryMessage += `- **Status:** ${this.getStatusEmoji(run.state)} ${run.state || 'unknown'}\n`;
                summaryMessage += `- **Execution Date:** ${run.execution_date || run.logical_date}\n`;
                summaryMessage += `- **Logical Date:** ${run.logical_date || run.execution_date}\n`;
                if (run.start_date) {
                    summaryMessage += `- **Start Date:** ${run.start_date}\n`;
                }
                if (run.end_date) {
                    summaryMessage += `- **End Date:** ${run.end_date}\n`;
                    const start = new Date(run.start_date);
                    const end = new Date(run.end_date);
                    const durationMs = end.getTime() - start.getTime();
                    const durationSec = Math.floor(durationMs / 1000);
                    const minutes = Math.floor(durationSec / 60);
                    const seconds = durationSec % 60;
                    summaryMessage += `- **Duration:** ${minutes}m ${seconds}s\n`;
                }
                if (run.note) {
                    summaryMessage += `- **Note:** ${run.note}\n`;
                }
                if (run.conf && Object.keys(run.conf).length > 0) {
                    summaryMessage += `- **Configuration:** \`${JSON.stringify(run.conf)}\`\n`;
                }
                summaryMessage += `\n`;
            });
            // Include raw JSON for LLM processing
            summaryMessage += `---\n\n**Raw Data (JSON):**\n\n`;
            summaryMessage += `\`\`\`json\n${JSON.stringify(runs, null, 2)}\n\`\`\`\n`;
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(summaryMessage)
            ]);
        }
        catch (error) {
            const errorMessage = `
❌ Failed to retrieve DAG history

**Error:** ${error instanceof Error ? error.message : String(error)}

Please check:
- The DAG ID is correct
- The date format is YYYY-MM-DD
- The Airflow server is accessible
- You have the necessary permissions
            `.trim();
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GetDagHistoryTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(errorMessage)
            ]);
        }
    }
    /**
     * Helper to get emoji for run status
     */
    getStatusEmoji(status) {
        const statusMap = {
            'success': '✅',
            'failed': '❌',
            'running': '▶️',
            'queued': '⏳',
            'upstream_failed': '⚠️',
            'skipped': '⏭️',
            'up_for_retry': '🔄',
            'up_for_reschedule': '📅',
            'removed': '🗑️',
            'scheduled': '📆'
        };
        return statusMap[status?.toLowerCase()] || '❓';
    }
}
exports.GetDagHistoryTool = GetDagHistoryTool;


/***/ }),
/* 173 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GetDagRunDetailTool - Language Model Tool for comprehensive DAG run analysis by run ID
 *
 * This tool retrieves comprehensive information about a specific DAG run including:
 * - DAG run details
 * - Task instances
 * - DAG source code
 * - Task logs
 *
 * It provides a complete analysis to help diagnose issues and understand execution.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDagRunDetailTool = void 0;
const vscode = __webpack_require__(1);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * GetDagRunDetailTool - Implements vscode.LanguageModelTool for comprehensive DAG run analysis
 */
class GetDagRunDetailTool {
    constructor(client) {
        this.client = client;
    }
    /**
     * Prepare invocation
     */
    async prepareInvocation(options, token) {
        const { dagId, dagRunId } = options.input;
        return {
            invocationMessage: `Analyzing DAG run '${dagRunId}' for DAG '${dagId}'...`
        };
    }
    /**
     * Execute comprehensive DAG run analysis
     */
    async invoke(options, token) {
        const { dagId, dagRunId } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GetDagRunDetailTool.invoke');
        try {
            // Step 1: Get task instances for this run
            const taskInstances = await this.client.getTaskInstances(dagId, dagRunId);
            if (!taskInstances || taskInstances.length === 0) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`ℹ️ No task instances found for DAG run '${dagRunId}' in DAG '${dagId}'.`)
                ]);
            }
            // Step 2: Get DAG source code
            let dagSourceCode = 'N/A';
            try {
                dagSourceCode = await this.client.getDagSource(dagId);
            }
            catch (error) {
                dagSourceCode = `Failed to retrieve source code: ${error instanceof Error ? error.message : String(error)}`;
            }
            // Step 3: Get logs for each task (focusing on failed tasks first, then all)
            const taskLogs = [];
            // Sort tasks: failed first, then by execution order
            const sortedTasks = [...taskInstances].sort((a, b) => {
                const failedStates = ['failed', 'upstream_failed'];
                const aFailed = failedStates.includes(a.state);
                const bFailed = failedStates.includes(b.state);
                if (aFailed && !bFailed)
                    return -1;
                if (!aFailed && bFailed)
                    return 1;
                return 0;
            });
            // Get logs for up to 5 tasks (prioritizing failed tasks)
            const tasksToLog = sortedTasks.slice(0, 5);
            for (const task of tasksToLog) {
                try {
                    const log = await this.client.getTaskLog(dagId, dagRunId, task.task_id, task.try_number?.toString() || '1');
                    taskLogs.push({
                        task_id: task.task_id,
                        state: task.state,
                        log: log
                    });
                }
                catch (error) {
                    taskLogs.push({
                        task_id: task.task_id,
                        state: task.state,
                        log: `Failed to retrieve log: ${error instanceof Error ? error.message : String(error)}`
                    });
                }
            }
            // Build DAG run object from task instances
            const dagRun = {
                dag_id: dagId,
                dag_run_id: dagRunId,
                state: this.deriveDagRunState(taskInstances),
                execution_date: taskInstances[0]?.execution_date || 'N/A',
                logical_date: taskInstances[0]?.execution_date || 'N/A',
                start_date: this.getEarliestStartDate(taskInstances),
                end_date: this.getLatestEndDate(taskInstances)
            };
            // Build comprehensive analysis report
            let report = this.buildAnalysisReport(dagId, dagRun, taskInstances, dagSourceCode, taskLogs);
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(report)
            ]);
        }
        catch (error) {
            const errorMessage = `
❌ Failed to analyze DAG run

**Error:** ${error instanceof Error ? error.message : String(error)}

Please check:
- The DAG ID is correct
- The DAG run ID is correct
- The Airflow server is accessible
- You have the necessary permissions
            `.trim();
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GetDagRunDetailTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(errorMessage)
            ]);
        }
    }
    /**
     * Derive overall DAG run state from task instances
     */
    deriveDagRunState(taskInstances) {
        if (taskInstances.some((t) => t.state === 'failed'))
            return 'failed';
        if (taskInstances.some((t) => t.state === 'running'))
            return 'running';
        if (taskInstances.some((t) => t.state === 'queued'))
            return 'queued';
        if (taskInstances.every((t) => t.state === 'success'))
            return 'success';
        return 'unknown';
    }
    /**
     * Get earliest start date from task instances
     */
    getEarliestStartDate(taskInstances) {
        const startDates = taskInstances
            .filter((t) => t.start_date)
            .map((t) => new Date(t.start_date).getTime());
        if (startDates.length === 0)
            return undefined;
        const earliest = Math.min(...startDates);
        return new Date(earliest).toISOString();
    }
    /**
     * Get latest end date from task instances
     */
    getLatestEndDate(taskInstances) {
        const endDates = taskInstances
            .filter((t) => t.end_date)
            .map((t) => new Date(t.end_date).getTime());
        if (endDates.length === 0)
            return undefined;
        const latest = Math.max(...endDates);
        return new Date(latest).toISOString();
    }
    /**
     * Build comprehensive analysis report
     */
    buildAnalysisReport(dagId, dagRun, taskInstances, dagSourceCode, taskLogs) {
        let report = `# 🔍 Comprehensive DAG Run Analysis\n\n`;
        report += `## DAG: ${dagId}\n\n`;
        report += `---\n\n`;
        // Section 1: DAG Run Overview
        report += `## 📊 DAG Run Overview\n\n`;
        report += `- **Run ID:** \`${dagRun.dag_run_id}\`\n`;
        report += `- **State:** ${this.getStatusEmoji(dagRun.state)} **${dagRun.state}**\n`;
        report += `- **Execution Date:** ${dagRun.execution_date}\n`;
        report += `- **Logical Date:** ${dagRun.logical_date}\n`;
        if (dagRun.start_date) {
            report += `- **Start Date:** ${dagRun.start_date}\n`;
        }
        if (dagRun.end_date) {
            report += `- **End Date:** ${dagRun.end_date}\n`;
            // Calculate duration
            const start = new Date(dagRun.start_date);
            const end = new Date(dagRun.end_date);
            const durationMs = end.getTime() - start.getTime();
            const durationSec = Math.floor(durationMs / 1000);
            const minutes = Math.floor(durationSec / 60);
            const seconds = durationSec % 60;
            report += `- **Duration:** ${minutes}m ${seconds}s\n`;
        }
        report += `\n---\n\n`;
        // Section 2: Task Instances Summary
        report += `## 📋 Task Instances (${taskInstances.length} tasks)\n\n`;
        // Group tasks by state
        const tasksByState = {};
        taskInstances.forEach((task) => {
            const state = task.state || 'unknown';
            if (!tasksByState[state]) {
                tasksByState[state] = [];
            }
            tasksByState[state].push(task);
        });
        // Display summary by state
        for (const [state, tasks] of Object.entries(tasksByState)) {
            report += `### ${this.getStatusEmoji(state)} ${state} (${tasks.length})\n`;
            tasks.forEach((task) => {
                report += `- **${task.task_id}**`;
                if (task.duration) {
                    report += ` - Duration: ${Math.round(task.duration)}s`;
                }
                if (task.start_date) {
                    report += ` - Started: ${task.start_date}`;
                }
                report += `\n`;
            });
            report += `\n`;
        }
        report += `---\n\n`;
        // Section 3: Task Logs Analysis
        if (taskLogs.length > 0) {
            report += `## 📝 Task Logs (Top ${taskLogs.length} tasks)\n\n`;
            taskLogs.forEach((taskLog, index) => {
                report += `### ${index + 1}. Task: ${taskLog.task_id} (${this.getStatusEmoji(taskLog.state)} ${taskLog.state})\n\n`;
                report += `\`\`\`\n${taskLog.log}\n\`\`\`\n\n`;
            });
            report += `---\n\n`;
        }
        // Section 4: DAG Source Code
        report += `## 💻 DAG Source Code\n\n`;
        report += `\`\`\`python\n${dagSourceCode}\n\`\`\`\n\n`;
        report += `---\n\n`;
        // Section 5: Raw Data
        report += `## 📦 Raw Data (JSON)\n\n`;
        report += `### DAG Run\n\`\`\`json\n${JSON.stringify(dagRun, null, 2)}\n\`\`\`\n\n`;
        report += `### Task Instances\n\`\`\`json\n${JSON.stringify(taskInstances, null, 2)}\n\`\`\`\n\n`;
        // Section 6: Analysis Prompt
        report += `---\n\n`;
        report += `## 🤖 Analysis Request\n\n`;
        report += `Please analyze the above information and provide:\n`;
        report += `1. **Summary of Execution:** What happened during this DAG run?\n`;
        report += `2. **Issues Identified:** What errors or problems occurred?\n`;
        report += `3. **Root Cause Analysis:** What likely caused any failures?\n`;
        report += `4. **Recommendations:** How can these issues be resolved?\n`;
        report += `5. **Code Review:** Any issues in the DAG code that need attention?\n`;
        return report;
    }
    /**
     * Helper to get emoji for task/run status
     */
    getStatusEmoji(status) {
        const statusMap = {
            'success': '✅',
            'failed': '❌',
            'running': '▶️',
            'queued': '⏳',
            'upstream_failed': '⚠️',
            'skipped': '⏭️',
            'up_for_retry': '🔄',
            'up_for_reschedule': '📅',
            'removed': '🗑️',
            'scheduled': '📆',
            'none': '⚪',
            'unknown': '❓'
        };
        return statusMap[status?.toLowerCase()] || '❓';
    }
}
exports.GetDagRunDetailTool = GetDagRunDetailTool;


/***/ }),
/* 174 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetTodayTool = void 0;
const vscode = __webpack_require__(1);
const Telemetry_1 = __webpack_require__(9);
class GetTodayTool {
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GetTodayTool.invoke');
        const today = new Date();
        // Format: YYYY-MM-DD
        const formattedDate = today.toISOString().split('T')[0];
        // Additional formats for user convenience
        const dayOfWeek = today.toLocaleDateString('en-US', { weekday: 'long' });
        const fullDate = today.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        const result = `## Today's Date

**ISO Format:** ${formattedDate}
**Full Date:** ${fullDate}
**Day of Week:** ${dayOfWeek}

*Use the ISO format (${formattedDate}) when filtering DAG runs or working with date ranges.*`;
        return new vscode.LanguageModelToolResult([
            new vscode.LanguageModelTextPart(result)
        ]);
    }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: 'Getting current system date...'
        };
    }
}
exports.GetTodayTool = GetTodayTool;


/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDagSourceCodeTool = void 0;
const vscode = __webpack_require__(1);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
class GetDagSourceCodeTool {
    constructor(airflowClient) {
        this.airflowClient = airflowClient;
    }
    async invoke(options, token) {
        const { dagId } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GetDagSourceCodeTool.invoke');
        try {
            const sourceCode = await this.airflowClient.getDagSourceCode(dagId);
            const result = `## DAG Source Code: ${dagId}

\`\`\`python
${sourceCode}
\`\`\`

**Total Lines:** ${sourceCode.split('\n').length}

The source code has been retrieved successfully. You can analyze it for:
- DAG structure and task dependencies
- Operator configurations
- Schedule and retry settings
- Custom logic and parameters
- Potential issues or improvements
`;
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(result)
            ]);
        }
        catch (error) {
            const errorMessage = `Failed to retrieve source code for DAG '${dagId}': ${error instanceof Error ? error.message : String(error)}`;
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GetDagSourceCodeTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(errorMessage)
            ]);
        }
    }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: `Retrieving source code for DAG '${options.input.dagId}'...`
        };
    }
}
exports.GetDagSourceCodeTool = GetDagSourceCodeTool;


/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToDagViewTool - Language Model Tool for opening the DAG View panel
 *
 * This tool allows users to open the DagView for a specific DAG,
 * optionally navigating to a specific DAG run.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToDagViewTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const DagView_1 = __webpack_require__(158);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToDagViewTool - Implements vscode.LanguageModelTool for opening DAG View
 *
 * This tool opens the DagView panel to display information about a specific DAG.
 * If a dagRunId is provided, it will navigate to that specific run.
 */
class GoToDagViewTool {
    constructor() {
        // No external dependencies needed - uses DagTreeView.Current directly
    }
    async prepareInvocation(options, token) {
        const { dagId, dagRunId } = options.input;
        let message = `Opening DAG View for: **${dagId}**`;
        if (dagRunId) {
            message += `\nDAG Run ID: **${dagRunId}**`;
        }
        return {
            invocationMessage: message
        };
    }
    async invoke(options, token) {
        const { dagId, dagRunId } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToDagViewTool.invoke');
        try {
            // Check if API is available
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            // Open the DagView with the specified DAG ID and optional run ID
            DagView_1.DagView.render(dagId, dagRunId);
            let successMessage = `✅ Opened DAG View for: **${dagId}**`;
            if (dagRunId) {
                successMessage += `\n📋 Showing DAG Run: **${dagRunId}**`;
            }
            else {
                successMessage += `\n📋 Showing latest DAG run`;
            }
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(successMessage)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToDagViewTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open DAG View for ${dagId}: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToDagViewTool = GoToDagViewTool;


/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToDagLogViewTool - Language Model Tool for opening the DAG Log View panel
 *
 * This tool allows users to open the DagLogView for a specific DAG,
 * optionally providing dagRunId, taskId, and tryNumber.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToDagLogViewTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const DagLogView_1 = __webpack_require__(178);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToDagLogViewTool - Implements vscode.LanguageModelTool for opening DAG Log View
 *
 * This tool opens the DagLogView panel to display logs for tasks.
 */
class GoToDagLogViewTool {
    constructor() {
    }
    async prepareInvocation(options, token) {
        const { dagId, dagRunId, taskId, tryNumber } = options.input;
        let message = `Opening DAG Log View for: **${dagId}**`;
        if (dagRunId) {
            message += `\nDAG Run ID: **${dagRunId}**`;
        }
        if (taskId) {
            message += `\nTask ID: **${taskId}**`;
        }
        if (tryNumber) {
            message += `\nTry Number: **${tryNumber}**`;
        }
        return {
            invocationMessage: message
        };
    }
    async invoke(options, token) {
        const { dagId, dagRunId, taskId, tryNumber } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToDagLogViewTool.invoke');
        try {
            // Check if API is available
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            // Open the DagLogView with the specified parameters
            DagLogView_1.DagLogView.render(dagId, dagRunId, taskId, tryNumber);
            let successMessage = `✅ Opened DAG Log View for: **${dagId}**`;
            if (dagRunId)
                successMessage += `, Run: **${dagRunId}**`;
            if (taskId)
                successMessage += `, Task: **${taskId}**`;
            if (tryNumber)
                successMessage += `, Try: **${tryNumber}**`;
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(successMessage)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToDagLogViewTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open DAG Log View for ${dagId}: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToDagLogViewTool = GoToDagLogViewTool;


/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DagLogView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const Session_1 = __webpack_require__(5);
const Telemetry_1 = __webpack_require__(9);
class DagLogView {
    constructor(panel, dagId, dagRunId, taskId, tryNumber) {
        this._disposables = [];
        this.logs = new Map(); // taskId -> logJson
        ui.logToOutput('DagLogView.constructor Started');
        Telemetry_1.Telemetry.Current.send('DagLogView.constructor.called');
        this._panel = panel;
        this.dagId = dagId;
        this.dagRunId = dagRunId;
        this.taskId = taskId;
        this.tryNumber = tryNumber;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('DagLogView.constructor Completed');
    }
    static render(dagId, dagRunId, taskId, tryNumber) {
        ui.logToOutput('DagLogView.render Started');
        Telemetry_1.Telemetry.Current.send('DagLogView.render.called');
        if (DagLogView.Current) {
            DagLogView.Current.dagId = dagId;
            DagLogView.Current.dagRunId = dagRunId;
            DagLogView.Current.taskId = taskId;
            DagLogView.Current.tryNumber = tryNumber;
            DagLogView.Current._panel.reveal(vscode.ViewColumn.One);
            DagLogView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("dagLogView", "DAG Logs", vscode.ViewColumn.One, {
                enableScripts: true,
                retainContextWhenHidden: true
            });
            DagLogView.Current = new DagLogView(panel, dagId, dagRunId, taskId, tryNumber);
        }
    }
    async loadData() {
        ui.logToOutput('DagLogView.loadData Started');
        Telemetry_1.Telemetry.Current.send('DagLogView.loadData.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        // 1. Resolve dagRunId if missing
        if (!this.dagRunId) {
            const lastRunResult = await Session_1.Session.Current.Api.getLastDagRun(this.dagId);
            if (lastRunResult.isSuccessful && lastRunResult.result) {
                this.dagRunJson = lastRunResult.result;
                this.dagRunId = this.dagRunJson.dag_run_id;
            }
            else {
                ui.showErrorMessage("Could not fetch latest DAG run.");
                return;
            }
        }
        else {
            // Fetch specific dag run details
            const runResult = await Session_1.Session.Current.Api.getDagRun(this.dagId, this.dagRunId);
            if (runResult.isSuccessful) {
                this.dagRunJson = runResult.result;
            }
        }
        // 2. Fetch Task Instances
        if (this.dagRunId) {
            const tasksResult = await Session_1.Session.Current.Api.getTaskInstances(this.dagId, this.dagRunId);
            if (tasksResult.isSuccessful && tasksResult.result) {
                this.taskInstancesJson = tasksResult.result;
            }
        }
        // 3. Clear logs cache on reload
        this.logs.clear();
        // 4. Fetch logs for tasks
        const tasks = this._getTasks();
        // Use Promise.all to fetch concurrently
        await Promise.all(tasks.map(t => {
            let tryNum = t.try_number;
            // If specific task requested AND specific try requested, use that.
            if (this.taskId && t.task_id === this.taskId && this.tryNumber !== undefined) {
                tryNum = this.tryNumber;
            }
            return this.fetchLogForTask(t.task_id, tryNum);
        }));
        await this.renderHtml();
    }
    _getTasks() {
        if (!this.taskInstancesJson || !this.taskInstancesJson.task_instances) {
            return [];
        }
        let tasks = [...this.taskInstancesJson.task_instances];
        // Filter by taskId if provided
        if (this.taskId) {
            tasks = tasks.filter((t) => t.task_id === this.taskId);
        }
        return tasks.sort((a, b) => {
            const dateA = a.start_date ? new Date(a.start_date).getTime() : 0;
            const dateB = b.start_date ? new Date(b.start_date).getTime() : 0;
            return dateA - dateB;
        });
    }
    async fetchLogForTask(taskId, tryNum) {
        if (!this.dagRunId) {
            return;
        }
        let targetTryNumber = tryNum;
        if (targetTryNumber === undefined) {
            const task = this.taskInstancesJson.task_instances.find((t) => t.task_id === taskId);
            if (task) {
                targetTryNumber = task.try_number;
            }
            else {
                targetTryNumber = 1;
            }
        }
        if (this.logs.has(taskId)) {
            return;
        }
        const result = await Session_1.Session.Current.Api?.getTaskInstanceLog(this.dagId, this.dagRunId, taskId, targetTryNumber);
        if (result?.isSuccessful) {
            this.logs.set(taskId, result.result);
        }
    }
    async renderHtml() {
        ui.logToOutput('DagLogView.renderHtml Started');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
    }
    dispose() {
        DagLogView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('DagLogView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('DagLogView._getWebviewContent.called');
        const elementsUri = ui.getUri(webview, extensionUri, [
            "node_modules",
            "@vscode-elements",
            "elements",
            "dist",
            "bundled.js",
        ]);
        const mainUri = ui.getUri(webview, extensionUri, ["media", "main.js"]);
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        const tasks = this._getTasks();
        // Metadata
        const dagRun = this.dagRunJson || {};
        const startDate = dagRun.start_date ? ui.toISODateTimeString(new Date(dagRun.start_date)) : 'N/A';
        const endDate = dagRun.end_date ? ui.toISODateTimeString(new Date(dagRun.end_date)) : 'Running';
        const duration = dagRun.start_date ? ui.getDuration(new Date(dagRun.start_date), dagRun.end_date ? new Date(dagRun.end_date) : new Date()) : 'N/A';
        const status = dagRun.state || 'N/A';
        const taskSections = tasks.map(t => {
            const logData = this.logs.get(t.task_id);
            let contentHtml = '';
            const isSuccess = t.state === 'success';
            const isError = ['failed', 'upstream_failed', 'shutdown', 'restart'].includes(t.state);
            let statusClass = 'status-other';
            if (isSuccess)
                statusClass = 'status-success';
            if (isError)
                statusClass = 'status-error';
            let displayTry = t.try_number;
            if (this.taskId && t.task_id === this.taskId && this.tryNumber !== undefined) {
                displayTry = this.tryNumber;
            }
            if (logData) {
                if (logData.content && Array.isArray(logData.content)) {
                    contentHtml = logData.content.map((entry) => {
                        const ts = entry.timestamp ? `[${entry.timestamp}]` : '';
                        const lvl = entry.level ? `[${entry.level}]` : '';
                        const logger = entry.logger ? `[${entry.logger}]` : '';
                        const evt = entry.event || '';
                        let extra = '';
                        // Error detail
                        if (entry.error_detail) {
                            extra = `<pre class="error-detail">${JSON.stringify(entry.error_detail, null, 2)}</pre>`;
                        }
                        let lineClass = 'log-line';
                        if (lvl.toLowerCase().includes('error')) {
                            lineClass += ' log-error';
                        }
                        if (lvl.toLowerCase().includes('warn')) {
                            lineClass += ' log-warn';
                        }
                        return `<div class="${lineClass}"><span class="log-ts">${ts}</span> <span class="log-lvl">${lvl}</span> <span class="log-logger">${logger}</span> <span class="log-msg">${this._escapeHtml(evt)}</span>${extra}</div>`;
                    }).join('');
                }
                else if (logData.detail) {
                    contentHtml = `<div class="log-error">${this._escapeHtml(logData.detail)}</div>`;
                }
                else {
                    contentHtml = `<pre>${this._escapeHtml(JSON.stringify(logData, null, 2))}</pre>`;
                }
            }
            else {
                contentHtml = '<div class="loading-logs">Loading logs...</div>';
            }
            return `
            <div class="task-section ${statusClass}">
                <div class="task-header">
                    <div class="header-left">
                        <span class="status-indicator"></span>
                        <span class="task-title">${this._escapeHtml(t.task_id)}</span>
                        <span class="status-pill">${this._escapeHtml(t.state)}</span>
                    </div>
                    <div class="header-right">
                        <span class="task-try">Try: ${displayTry}</span>
                    </div>
                </div>
                <div class="log-container" id="log-${t.task_id}">
                    ${contentHtml}
                </div>
            </div>`;
        }).join('\n');
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <script type="module" src="${elementsUri}"></script>
    <script type="module" src="${mainUri}"></script>
    <link rel="stylesheet" href="${styleUri}">
    <style>
        :root {
            --font-size-sm: 12px;
            --font-size-md: 13px;
            --font-size-lg: 15px;
            --border-radius: 4px;
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
        }

        body { 
            padding: var(--spacing-md); 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            box-sizing: border-box; 
            background: var(--vscode-editor-background); 
            color: var(--vscode-editor-foreground);
            font-family: var(--vscode-font-family);
        }

        .metadata { 
            margin-bottom: var(--spacing-lg); 
            padding: var(--spacing-md); 
            background: var(--vscode-editor-inactiveSelectionBackground); 
            border-radius: var(--border-radius); 
        }
        .metadata-row { display: flex; gap: 32px; font-size: 13px; margin-bottom: 4px; }
        .label { font-weight: 600; color: var(--vscode-descriptionForeground); width: 70px; display: inline-block; text-transform: uppercase; font-size: 11px; }
        
        .task-container { display: flex; flex-direction: column; gap: 16px; padding-bottom: 20px; }
        
        .task-section { 
            border: 1px solid var(--vscode-widget-border); 
            border-radius: var(--border-radius); 
            overflow: hidden; 
            background: var(--vscode-editor-background);
        }
        
        .task-header { 
            padding: 8px 16px; 
            display: flex; 
            justify-content: space-between;
            align-items: center; 
            border-bottom: 1px solid var(--vscode-widget-border);
        }

        .header-left { display: flex; align-items: center; gap: 12px; }
        .header-right { display: flex; align-items: center; gap: 12px; }

        .task-title { font-weight: 600; font-size: 14px; }
        .task-try { font-size: 11px; color: var(--vscode-descriptionForeground); }
        
        .status-indicator {
            width: 8px; height: 8px; border-radius: 50%;
            display: inline-block;
        }

        .status-pill {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        /* Status Colors */
        .task-section.status-success .task-header {
            background-color: var(--vscode-notebook-cellEditorBackground); 
        }
        .task-section.status-success .status-indicator {
            background-color: var(--vscode-testing-iconPassed);
        }
        .task-section.status-success .status-pill {
            background-color: var(--vscode-testing-iconPassed);
            color: var(--vscode-editor-background);
        }

        .task-section.status-error .task-header {
            background-color: rgba(255, 0, 0, 0.1); 
        }
        .task-section.status-error .status-indicator {
            background-color: var(--vscode-errorForeground);
        }
        .task-section.status-error .status-pill {
            background-color: var(--vscode-errorForeground);
            color: white;
        }

        .task-section.status-other .task-header {
            background-color: var(--vscode-sideBarSectionHeader-background);
        }
        .task-section.status-other .status-indicator {
            background-color: var(--vscode-descriptionForeground);
        }
        .task-section.status-other .status-pill {
            background-color: var(--vscode-badge-background);
            color: var(--vscode-badge-foreground);
        }

        .log-container { 
            padding: 16px;
            max-height: 500px;
            overflow-y: auto; 
            font-family: var(--vscode-editor-font-family);
            font-size: 12px;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .log-line { margin-bottom: 2px; }
        .log-ts { color: var(--vscode-debugConsole-infoForeground); margin-right: 8px; opacity: 0.8; font-size: 0.9em; }
        .log-lvl { font-weight: bold; margin-right: 8px; }
        .log-logger { color: var(--vscode-textLink-foreground); margin-right: 8px; }
        
        .log-error { color: var(--vscode-errorForeground); }
        .log-warn { color: var(--vscode-editorWarning-foreground); }
        
        .error-detail { 
            color: var(--vscode-textPreformat-foreground); 
            background-color: var(--vscode-textBlockQuote-background);
            padding: 12px;
            margin: 8px 0 8px 16px;
            border-left: 3px solid var(--vscode-errorForeground);
            border-radius: 3px;
        }
        .loading-logs { font-style: italic; color: var(--vscode-descriptionForeground); padding: 20px; text-align: center; }

    </style>
    <title>DAG Logs</title>
</head>
<body>
    <div class="metadata">
        <div class="metadata-row">
            <div><span class="label">DAG ID:</span> <span>${this.dagId}</span></div>
            <div><span class="label">Run ID:</span> <span>${this.dagRunId}</span></div>
            <div><span class="label">Status:</span> <span>${status}</span></div>
        </div>
        <div class="metadata-row">
            <div><span class="label">Start:</span> <span>${startDate}</span></div>
            <div><span class="label">End:</span> <span>${endDate}</span></div>
            <div><span class="label">Duration:</span> <span>${duration}</span></div>
        </div>
    </div>

    <div class="task-container">
        ${taskSections}
    </div>

    <script>
        const vscode = acquireVsCodeApi();
        // Just listener for now if we want to add interactivity later e.g. collapse/expand
    </script>
</body>
</html>`;
    }
    _escapeHtml(text) {
        if (!text)
            return '';
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('DagLogView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('DagLogView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage(async (message) => {
            // No messages expected for now
        }, undefined, this._disposables);
    }
}
exports.DagLogView = DagLogView;


/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToDagRunHistoryTool - Language Model Tool for opening the DAG Run History view
 *
 * This tool allows users to open the DagRunHistory view with optional filters
 * for dagId, startDate, endDate, and status.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToDagRunHistoryTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const DagRunView_1 = __webpack_require__(180);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToDagRunHistoryTool - Implements vscode.LanguageModelTool for opening DAG Run History View
 *
 * This tool opens the DagRunHistory panel to display run history for a specific DAG.
 * Optional filters can be applied for date range and status.
 */
class GoToDagRunHistoryTool {
    constructor() {
        // No external dependencies needed - uses DagTreeView.Current directly
    }
    async prepareInvocation(options, token) {
        const { dagId, startDate, endDate, status } = options.input;
        let message = `Opening DAG Run History for: **${dagId}**`;
        if (startDate) {
            message += `\nStart Date: **${startDate}**`;
        }
        if (endDate) {
            message += `\nEnd Date: **${endDate}**`;
        }
        if (status) {
            message += `\nStatus Filter: **${status}**`;
        }
        return {
            invocationMessage: message
        };
    }
    async invoke(options, token) {
        const { dagId, startDate, endDate, status } = options.input;
        AIHandler_1.AIHandler.Current.currentDagId = dagId;
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToDagRunHistoryTool.invoke');
        try {
            // Check if API is available
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            // Validate date format if provided (YYYY-MM-DD)
            const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
            if (startDate && !dateRegex.test(startDate)) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`❌ Invalid startDate format: "${startDate}". Expected format: YYYY-MM-DD`)
                ]);
            }
            if (endDate && !dateRegex.test(endDate)) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`❌ Invalid endDate format: "${endDate}". Expected format: YYYY-MM-DD`)
                ]);
            }
            // Validate status if provided
            const validStatuses = ['success', 'failed', 'running', 'queued', 'upstream_failed', 'skipped', 'deferred'];
            if (status && !validStatuses.includes(status.toLowerCase())) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart(`❌ Invalid status: "${status}". Valid values: ${validStatuses.join(', ')}`)
                ]);
            }
            // Open the DagRunView with the specified parameters
            DagRunView_1.DagRunView.render(dagId, startDate, endDate, status?.toLowerCase());
            let successMessage = `✅ Opened DAG Run History for: **${dagId}**`;
            const filters = [];
            if (startDate) {
                filters.push(`Start Date: ${startDate}`);
            }
            if (endDate) {
                filters.push(`End Date: ${endDate}`);
            }
            if (status) {
                filters.push(`Status: ${status}`);
            }
            if (filters.length > 0) {
                successMessage += `\n📋 Filters applied: ${filters.join(', ')}`;
            }
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(successMessage)
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToDagRunHistoryTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open DAG Run History for ${dagId}: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToDagRunHistoryTool = GoToDagRunHistoryTool;


/***/ }),
/* 180 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DagRunView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const DagView_1 = __webpack_require__(158);
const Session_1 = __webpack_require__(5);
const DagLogView_1 = __webpack_require__(178);
const Telemetry_1 = __webpack_require__(9);
class DagRunView {
    constructor(panel) {
        this._disposables = [];
        // Filters
        this.selectedDagId = '';
        this.selectedStartDate = ui.toISODateString(new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)); // Default to 7 days ago
        this.selectedEndDate = ui.toISODateString(new Date());
        this.selectedStatus = '';
        this.allDagIds = [];
        ui.logToOutput('DagRunView.constructor Started');
        Telemetry_1.Telemetry.Current.send('DagRunView.constructor.called');
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('DagRunView.constructor Completed');
    }
    async loadData() {
        ui.logToOutput('DagRunView.loadData Started');
        Telemetry_1.Telemetry.Current.send('DagRunView.loadData.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        // Fetch all DAGs to populate dag_id filter
        const dagsResult = await Session_1.Session.Current.Api.getDagList();
        if (dagsResult.isSuccessful && Array.isArray(dagsResult.result)) {
            this.allDagIds = dagsResult.result.map((dag) => dag.dag_id).sort();
            // If no DAG is selected yet, select the first one
            if (!this.selectedDagId && this.allDagIds.length > 0) {
                this.selectedDagId = this.allDagIds[0];
            }
        }
        // Fetch DAG runs for the selected DAG and date range
        if (this.selectedDagId) {
            const result = await Session_1.Session.Current.Api.getDagRunHistory(this.selectedDagId);
            if (result.isSuccessful && result.result && result.result.dag_runs) {
                // Filter runs by date range on the client side
                const startDateTime = new Date(this.selectedStartDate + 'T00:00:00Z').getTime();
                const endDateTime = new Date(this.selectedEndDate + 'T23:59:59Z').getTime();
                this.dagRunsJson = result.result.dag_runs.filter((run) => {
                    if (run.start_date) {
                        const runTime = new Date(run.start_date).getTime();
                        return runTime >= startDateTime && runTime <= endDateTime;
                    }
                    return false;
                });
            }
        }
        else {
            this.dagRunsJson = [];
        }
        await this.renderHtml();
    }
    async renderHtml() {
        ui.logToOutput('DagRunView.renderHtml Started');
        Telemetry_1.Telemetry.Current.send('DagRunView.renderHtml.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        ui.logToOutput('DagRunView.renderHtml Completed');
    }
    static render(dagId, startDate, endDate, status) {
        ui.logToOutput('DagRunView.render Started');
        Telemetry_1.Telemetry.Current.send('DagRunView.render.called');
        if (DagRunView.Current) {
            // Apply optional filter parameters
            if (dagId) {
                DagRunView.Current.selectedDagId = dagId;
            }
            if (startDate) {
                DagRunView.Current.selectedStartDate = startDate;
            }
            if (endDate) {
                DagRunView.Current.selectedEndDate = endDate;
            }
            if (status) {
                DagRunView.Current.selectedStatus = status;
            }
            DagRunView.Current._panel.reveal(vscode.ViewColumn.One);
            DagRunView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("dagRunView", "DAG Run History", vscode.ViewColumn.One, {
                enableScripts: true,
            });
            DagRunView.Current = new DagRunView(panel);
            // Apply optional filter parameters after creation
            if (dagId) {
                DagRunView.Current.selectedDagId = dagId;
            }
            if (startDate) {
                DagRunView.Current.selectedStartDate = startDate;
            }
            if (endDate) {
                DagRunView.Current.selectedEndDate = endDate;
            }
            if (status) {
                DagRunView.Current.selectedStatus = status;
            }
            // Reload data with new parameters if any were provided
            if (dagId || startDate || endDate || status) {
                DagRunView.Current.loadData();
            }
        }
    }
    dispose() {
        ui.logToOutput('DagRunView.dispose Started');
        Telemetry_1.Telemetry.Current.send('DagRunView.dispose.called');
        DagRunView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('DagRunView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('DagRunView._getWebviewContent.called');
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        // Filter DAG runs based on selected status
        let filteredRuns = [];
        if (this.dagRunsJson && Array.isArray(this.dagRunsJson)) {
            filteredRuns = this.dagRunsJson.filter((run) => {
                // Filter by status
                if (this.selectedStatus && run.state !== this.selectedStatus) {
                    return false;
                }
                return true;
            });
        }
        // Build table rows
        let tableRows = '';
        filteredRuns.forEach((run) => {
            const dagId = run.dag_id || 'N/A';
            const status = run.state || 'N/A';
            const startDate = run.start_date ? ui.toISODateTimeString(new Date(run.start_date)) : 'N/A';
            const duration = run.start_date && run.end_date ? ui.getDuration(new Date(run.start_date), new Date(run.end_date)) : 'Running';
            const config = run.conf ? JSON.stringify(run.conf) : '{}';
            const note = run.note || '';
            const dagRunId = run.dag_run_id || '';
            tableRows += `
            <tr class="table-row">
                <td><a href="#" data-dag-id="${this._escapeHtml(dagId)}" data-dag-run-id="${this._escapeHtml(dagRunId)}" class="dag-link">${this._escapeHtml(dagId)}</a></td>
                <td>
                    <div style="display: flex; align-items: center;">
                        <div class="state-indicator state-${status}" title="${this._escapeHtml(status)}"></div>
                        <span>${this._escapeHtml(status)}</span>
                    </div>
                </td>
                <td>
                    <div class="action-links">
                        <a href="#" data-dag-id="${this._escapeHtml(dagId)}" data-dag-run-id="${this._escapeHtml(dagRunId)}" class="dag-log-link link-button">Logs</a>
                    </div>
                </td>
                <td>${this._escapeHtml(startDate)}</td>
                <td><span class="duration-badge">${this._escapeHtml(duration)}</span></td>
                <td><div class="code-block" style="max-height: 50px; overflow: hidden; font-size: 11px;">${this._escapeHtml(config)}</div></td>
                <td>${this._escapeHtml(note)}</td>
            </tr>`;
        });
        // Build dag_id filter options
        const dagIdOptions = this.allDagIds.map(id => `<option value="${this._escapeHtml(id)}" ${id === this.selectedDagId ? 'selected' : ''}>${this._escapeHtml(id)}</option>`).join('');
        const result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body {
                padding: var(--spacing-md);
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0 0 var(--spacing-lg) 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
                border-bottom: 1px solid var(--vscode-widget-border);
                padding-bottom: var(--spacing-md);
            }

            /* Filters */
            .filters {
                display: flex;
                gap: var(--spacing-md);
                margin-bottom: var(--spacing-lg);
                flex-wrap: wrap;
                align-items: flex-end;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                padding: var(--spacing-md);
                border-radius: var(--border-radius);
            }
            .filter-group {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }
            .filter-group label {
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                color: var(--vscode-descriptionForeground);
            }
            .filter-group select,
            .filter-group input {
                padding: 6px 8px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border-radius: 4px;
                font-size: 13px;
                min-width: 150px;
            }

            /* Tables */
            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                position: sticky;
                top: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }

            /* States */
            .state-indicator {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-right: 8px;
                display: inline-block;
            }
            /* Add state-specific colors here if standard style.css doesn't cover them all, 
               but assuming style.css has .state-* classes or DagView style block logic is global enough?
               Actually DagView styles were inline in the file. I need to include them or rely on style.css.
               Assuming style.css handles basic colors, but let's add the indicator styles to be safe 
               since they were in DagView's style block. */
            
            .state-success { background-color: var(--vscode-testing-iconPassed); }
            .state-failed { background-color: var(--vscode-errorForeground); }
            .state-running { background-color: var(--vscode-charts-blue); }
            .state-queued { background-color: var(--vscode-charts-yellow); }
            .state-upstream_failed { background-color: var(--vscode-charts-orange); }
            .state-skipped { background-color: var(--vscode-disabledForeground); }
            .state-deferred { background-color: var(--vscode-charts-purple); }

            a {
                color: var(--vscode-textLink-foreground);
                text-decoration: none;
                cursor: pointer;
            }
            a:hover {
                text-decoration: underline;
                color: var(--vscode-textLink-activeForeground);
            }

            .duration-badge {
                font-family: 'Courier New', monospace;
                font-size: 12px;
                opacity: 0.8;
            }

            .code-block {
                font-family: var(--vscode-editor-font-family);
                background-color: var(--vscode-textBlockQuote-background);
                padding: 4px;
                border-radius: 4px;
            }
        </style>
        <title>DAG Run History</title>
      </head>
      <body>  
        <h2>DAG Run History</h2>
        
        <div class="filters">
            <div class="filter-group">
                <label>DAG ID</label>
                <select id="filter-dag-id">
                    ${dagIdOptions}
                </select>
            </div>
            <div class="filter-group">
                <label>Start Date</label>
                <input type="date" id="filter-start-date" value="${this.selectedStartDate}">
            </div>
            <div class="filter-group">
                <label>End Date</label>
                <input type="date" id="filter-end-date" value="${this.selectedEndDate}">
            </div>
            <div class="filter-group">
                <label>Status</label>
                <select id="filter-status">
                    <option value="">All</option>
                    <option value="success" ${this.selectedStatus === 'success' ? 'selected' : ''}>Success</option>
                    <option value="failed" ${this.selectedStatus === 'failed' ? 'selected' : ''}>Failed</option>
                    <option value="running" ${this.selectedStatus === 'running' ? 'selected' : ''}>Running</option>
                    <option value="queued" ${this.selectedStatus === 'queued' ? 'selected' : ''}>Queued</option>
                    <option value="upstream_failed" ${this.selectedStatus === 'upstream_failed' ? 'selected' : ''}>Upstream Failed</option>
                </select>
            </div>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>DAG ID</th>
                    <th>Status</th>
                    <th>Actions</th>
                    <th>Start Date</th>
                    <th>Duration</th>
                    <th>Config</th>
                    <th>Note</th>
                </tr>
            </thead>
            <tbody>
            ${tableRows || '<tr><td colspan="7" style="text-align:center; padding: 20px; opacity: 0.7;">No runs found for the selected filters</td></tr>'}        
            </tbody>
        </table>

        <script>
            const vscode = acquireVsCodeApi();

            document.getElementById('filter-dag-id').addEventListener('change', (e) => {
                vscode.postMessage({ command: 'filter-dag-id', dagId: e.target.value });
            });

            document.getElementById('filter-start-date').addEventListener('change', (e) => {
                vscode.postMessage({ command: 'filter-start-date', startDate: e.target.value });
            });

            document.getElementById('filter-end-date').addEventListener('change', (e) => {
                vscode.postMessage({ command: 'filter-end-date', endDate: e.target.value });
            });

            document.getElementById('filter-status').addEventListener('change', (e) => {
                vscode.postMessage({ command: 'filter-status', status: e.target.value });
            });

            // Handle dag-link clicks
            document.querySelectorAll('.dag-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    // Handle clicks on child elements
                    const target = e.target.closest('a') || e.target;
                    const dagId = target.getAttribute('data-dag-id');
                    const dagRunId = target.getAttribute('data-dag-run-id');
                    vscode.postMessage({ command: 'open-dag-view', dagId, dagRunId });
                });
            });

            // Handle dag-log-link clicks
            document.querySelectorAll('.dag-log-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const target = e.target.closest('a') || e.target;
                    const dagId = target.getAttribute('data-dag-id');
                    const dagRunId = target.getAttribute('data-dag-run-id');
                    vscode.postMessage({ command: 'view-dag-log', dagId, dagRunId });
                });
            });
        </script>
      </body>
    </html>
    `;
        return result;
    }
    _escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    _getStatusEmoji(status) {
        const statusMap = {
            'success': '✅',
            'failed': '❌',
            'running': '▶️',
            'queued': '⏳',
            'upstream_failed': '⚠️',
            'skipped': '⏭️',
            'deferred': '🔄'
        };
        return statusMap[status.toLowerCase()] || '📅';
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('DagRunView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('DagRunView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            ui.logToOutput('DagRunView._setWebviewMessageListener Message Received ' + message.command);
            switch (message.command) {
                case "filter-dag-id":
                    this.selectedDagId = message.dagId;
                    this.loadData();
                    return;
                case "filter-start-date":
                    this.selectedStartDate = message.startDate;
                    this.loadData();
                    return;
                case "filter-end-date":
                    this.selectedEndDate = message.endDate;
                    this.loadData();
                    return;
                case "filter-status":
                    this.selectedStatus = message.status;
                    this.renderHtml();
                    return;
                case "open-dag-view":
                    // Open DagView with specific dag and run
                    if (!Session_1.Session.Current.Api) {
                        return;
                    }
                    if (Session_1.Session.Current.Api && message.dagId) {
                        DagView_1.DagView.render(message.dagId, message.dagRunId);
                    }
                    return;
                case "view-dag-log":
                    if (message.dagId) {
                        DagLogView_1.DagLogView.render(message.dagId, message.dagRunId);
                    }
                    return;
            }
        }, undefined, this._disposables);
    }
}
exports.DagRunView = DagRunView;


/***/ }),
/* 181 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToProvidersViewTool - Language Model Tool for opening the Providers view
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToProvidersViewTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const ProvidersView_1 = __webpack_require__(182);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToProvidersViewTool - Opens the Providers panel
 */
class GoToProvidersViewTool {
    constructor() { }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: 'Opening Providers View...'
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToProvidersViewTool.invoke');
        try {
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            ProvidersView_1.ProvidersView.render();
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart('✅ Opened Providers View - showing installed Airflow providers with their versions')
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToProvidersViewTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open Providers View: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToProvidersViewTool = GoToProvidersViewTool;


/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProvidersView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const Session_1 = __webpack_require__(5);
const Telemetry_1 = __webpack_require__(9);
class ProvidersView {
    constructor(panel) {
        this._disposables = [];
        ui.logToOutput('ProvidersView.constructor Started');
        Telemetry_1.Telemetry.Current.send('ProvidersView.constructor.called');
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('ProvidersView.constructor Completed');
    }
    async loadData() {
        ui.logToOutput('ProvidersView.loadData Started');
        Telemetry_1.Telemetry.Current.send('ProvidersView.loadData.called');
        const result = await Session_1.Session.Current.Api.getProviders();
        if (result.isSuccessful) {
            this.providersJson = result.result;
        }
        await this.renderHtml();
    }
    async renderHtml() {
        ui.logToOutput('ProvidersView.renderHtml Started');
        Telemetry_1.Telemetry.Current.send('ProvidersView.renderHtml.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        ui.logToOutput('ProvidersView.renderHtml Completed');
    }
    static render() {
        ui.logToOutput('ProvidersView.render Started');
        Telemetry_1.Telemetry.Current.send('ProvidersView.render.called');
        if (ProvidersView.Current) {
            ProvidersView.Current._panel.reveal(vscode.ViewColumn.One);
            ProvidersView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("providersView", "Providers", vscode.ViewColumn.One, {
                enableScripts: true,
            });
            ProvidersView.Current = new ProvidersView(panel);
        }
    }
    dispose() {
        ui.logToOutput('ProvidersView.dispose Started');
        Telemetry_1.Telemetry.Current.send('ProvidersView.dispose.called');
        ProvidersView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('ProvidersView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('ProvidersView._getWebviewContent.called');
        const elementsUri = ui.getUri(webview, extensionUri, [
            "node_modules",
            "@vscode-elements",
            "elements",
            "dist",
            "bundled.js",
        ]);
        const mainUri = ui.getUri(webview, extensionUri, ["media", "main.js"]);
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        // Build table rows from providers data
        let tableRows = '';
        if (this.providersJson && this.providersJson.providers) {
            for (const provider of this.providersJson.providers) {
                const packageName = provider.package_name || 'N/A';
                const version = provider.version || 'N/A';
                const description = provider.description || 'N/A';
                tableRows += `
                <tr class="table-row">
                    <td>${this._escapeHtml(packageName)}</td>
                    <td>${this._escapeHtml(version)}</td>
                    <td>${this._escapeHtml(description)}</td>
                </tr>`;
            }
        }
        const result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <script type="module" src="${elementsUri}"></script>
        <script type="module" src="${mainUri}"></script>
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body { 
                padding: var(--spacing-md); 
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0 0 var(--spacing-lg) 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
                border-bottom: 1px solid var(--vscode-widget-border);
                padding-bottom: var(--spacing-md);
            }

            .controls {
                margin-bottom: var(--spacing-lg);
            }

            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                position: sticky;
                top: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }
        </style>
        <title>Providers</title>
      </head>
      <body>  
        <h2>Airflow Providers</h2>
        <div class="controls">
            <vscode-button appearance="secondary" id="refresh-providers">Refresh</vscode-button>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>Package Name</th>
                    <th>Version</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
            ${tableRows || '<tr><td colspan="3" style="text-align:center; padding: 20px; opacity: 0.7;">No providers found</td></tr>'}
            </tbody>
        </table>
      </body>
    </html>
    `;
        return result;
    }
    _escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('ProvidersView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('ProvidersView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            ui.logToOutput('ProvidersView._setWebviewMessageListener Message Received ' + message.command);
            switch (message.command) {
                case "refresh-providers":
                    this.loadData();
                    return;
            }
        }, undefined, this._disposables);
    }
}
exports.ProvidersView = ProvidersView;


/***/ }),
/* 183 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToConnectionsViewTool - Language Model Tool for opening the Connections view
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToConnectionsViewTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const ConnectionsView_1 = __webpack_require__(184);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToConnectionsViewTool - Opens the Connections panel
 */
class GoToConnectionsViewTool {
    constructor() { }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: 'Opening Connections View...'
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToConnectionsViewTool.invoke');
        try {
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            ConnectionsView_1.ConnectionsView.render();
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart('✅ Opened Connections View - showing Airflow connections (databases, APIs, cloud services, etc.)')
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToConnectionsViewTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open Connections View: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToConnectionsViewTool = GoToConnectionsViewTool;


/***/ }),
/* 184 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionsView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const Session_1 = __webpack_require__(5);
const Telemetry_1 = __webpack_require__(9);
class ConnectionsView {
    constructor(panel) {
        this._disposables = [];
        ui.logToOutput('ConnectionsView.constructor Started');
        Telemetry_1.Telemetry.Current.send('ConnectionsView.constructor.called');
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('ConnectionsView.constructor Completed');
    }
    async loadData() {
        ui.logToOutput('ConnectionsView.loadData Started');
        Telemetry_1.Telemetry.Current.send('ConnectionsView.loadData.called');
        const result = await Session_1.Session.Current.Api.getConnections();
        if (result.isSuccessful) {
            this.connectionsJson = result.result;
        }
        await this.renderHtml();
    }
    async renderHtml() {
        ui.logToOutput('ConnectionsView.renderHtml Started');
        Telemetry_1.Telemetry.Current.send('ConnectionsView.renderHtml.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        ui.logToOutput('ConnectionsView.renderHtml Completed');
    }
    static render() {
        ui.logToOutput('ConnectionsView.render Started');
        Telemetry_1.Telemetry.Current.send('ConnectionsView.render.called');
        if (ConnectionsView.Current) {
            ConnectionsView.Current._panel.reveal(vscode.ViewColumn.One);
            ConnectionsView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("connectionsView", "Connections", vscode.ViewColumn.One, {
                enableScripts: true,
            });
            ConnectionsView.Current = new ConnectionsView(panel);
        }
    }
    dispose() {
        ui.logToOutput('ConnectionsView.dispose Started');
        Telemetry_1.Telemetry.Current.send('ConnectionsView.dispose.called');
        ConnectionsView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('ConnectionsView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('ConnectionsView._getWebviewContent.called');
        const toolkitUri = ui.getUri(webview, extensionUri, [
            "node_modules",
            "@vscode",
            "webview-ui-toolkit",
            "dist",
            "toolkit.js",
        ]);
        const mainUri = ui.getUri(webview, extensionUri, ["media", "main.js"]);
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        let tableRows = '';
        if (this.connectionsJson && this.connectionsJson.connections && Array.isArray(this.connectionsJson.connections)) {
            for (const conn of this.connectionsJson.connections) {
                const connId = conn.conn_id || 'N/A';
                const connType = conn.conn_type || 'N/A';
                const host = conn.host || '';
                const port = conn.port || '';
                const schema = conn.schema || '';
                tableRows += `
                <tr class="table-row">
                    <td>${this._escapeHtml(connId)}</td>
                    <td><span class="tag">${this._escapeHtml(connType)}</span></td>
                    <td>${this._escapeHtml(host)}</td>
                    <td>${this._escapeHtml(String(port))}</td>
                    <td>${this._escapeHtml(schema)}</td>
                </tr>`;
            }
        }
        else if (this.connectionsJson) {
            // Fallback if structure is different
            tableRows = `<tr><td colspan="5"><pre>${JSON.stringify(this.connectionsJson, null, 2)}</pre></td></tr>`;
        }
        const result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <script type="module" src="${toolkitUri}"></script>
        <script type="module" src="${mainUri}"></script>
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body { 
                padding: var(--spacing-md); 
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0 0 var(--spacing-lg) 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
                border-bottom: 1px solid var(--vscode-widget-border);
                padding-bottom: var(--spacing-md);
            }

            .controls {
                margin-bottom: var(--spacing-lg);
            }

            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                position: sticky;
                top: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }

            .tag {
                background-color: var(--vscode-textBlockQuote-background);
                color: var(--vscode-textBlockQuote-border);
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 11px;
                border: 1px solid var(--vscode-widget-border);
            }
        </style>
        <title>Connections</title>
      </head>
      <body>  
        <h2>Airflow Connections</h2>
        <div class="controls">
            <vscode-button appearance="secondary" id="refresh-connections">Refresh</vscode-button>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>Conn ID</th>
                    <th>Type</th>
                    <th>Host</th>
                    <th>Port</th>
                    <th>Schema</th>
                </tr>
            </thead>
            <tbody>
                ${tableRows || '<tr><td colspan="5" style="text-align:center; padding: 20px; opacity: 0.7;">No connections found</td></tr>'}
            </tbody>
        </table>
      </body>
    </html>
    `;
        return result;
    }
    _escapeHtml(text) {
        if (!text)
            return '';
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('ConnectionsView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('ConnectionsView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            ui.logToOutput('ConnectionsView._setWebviewMessageListener Message Received ' + message.command);
            switch (message.command) {
                case "refresh-connections":
                    this.loadData();
                    return;
            }
        }, undefined, this._disposables);
    }
}
exports.ConnectionsView = ConnectionsView;


/***/ }),
/* 185 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToVariablesViewTool - Language Model Tool for opening the Variables view
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToVariablesViewTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const VariablesView_1 = __webpack_require__(186);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToVariablesViewTool - Opens the Variables panel
 */
class GoToVariablesViewTool {
    constructor() { }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: 'Opening Variables View...'
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToVariablesViewTool.invoke');
        try {
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            VariablesView_1.VariablesView.render();
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart('✅ Opened Variables View - showing Airflow variables (key-value configuration settings)')
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToVariablesViewTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open Variables View: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToVariablesViewTool = GoToVariablesViewTool;


/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VariablesView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const Session_1 = __webpack_require__(5);
const Telemetry_1 = __webpack_require__(9);
class VariablesView {
    constructor(panel) {
        this._disposables = [];
        ui.logToOutput('VariablesView.constructor Started');
        Telemetry_1.Telemetry.Current.send('VariablesView.constructor.called');
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('VariablesView.constructor Completed');
    }
    async loadData() {
        ui.logToOutput('VariablesView.loadData Started');
        Telemetry_1.Telemetry.Current.send('VariablesView.loadData.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getVariables();
        if (result.isSuccessful) {
            this.variablesJson = result.result;
        }
        await this.renderHtml();
    }
    async renderHtml() {
        ui.logToOutput('VariablesView.renderHtml Started');
        Telemetry_1.Telemetry.Current.send('VariablesView.renderHtml.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        ui.logToOutput('VariablesView.renderHtml Completed');
    }
    static render() {
        ui.logToOutput('VariablesView.render Started');
        Telemetry_1.Telemetry.Current.send('VariablesView.render.called');
        if (VariablesView.Current) {
            VariablesView.Current._panel.reveal(vscode.ViewColumn.One);
            VariablesView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("variablesView", "Variables", vscode.ViewColumn.One, {
                enableScripts: true,
            });
            VariablesView.Current = new VariablesView(panel);
        }
    }
    dispose() {
        ui.logToOutput('VariablesView.dispose Started');
        Telemetry_1.Telemetry.Current.send('VariablesView.dispose.called');
        VariablesView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('VariablesView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('VariablesView._getWebviewContent.called');
        const elementsUri = ui.getUri(webview, extensionUri, [
            "node_modules",
            "@vscode-elements",
            "elements",
            "dist",
            "bundled.js",
        ]);
        const mainUri = ui.getUri(webview, extensionUri, ["media", "main.js"]);
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        // Build table rows from variables data
        let tableRows = '';
        if (this.variablesJson && this.variablesJson.variables) {
            for (const variable of this.variablesJson.variables) {
                const key = variable.key || 'N/A';
                const value = variable.val || 'N/A';
                const description = variable.description || '';
                tableRows += `
                <tr class="table-row">
                    <td>${this._escapeHtml(key)}</td>
                    <td><code>${this._escapeHtml(value)}</code></td>
                    <td>${this._escapeHtml(description)}</td>
                </tr>`;
            }
        }
        const result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <script type="module" src="${elementsUri}"></script>
        <script type="module" src="${mainUri}"></script>
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body { 
                padding: var(--spacing-md); 
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0 0 var(--spacing-lg) 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
                border-bottom: 1px solid var(--vscode-widget-border);
                padding-bottom: var(--spacing-md);
            }

            .controls {
                margin-bottom: var(--spacing-lg);
            }

            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                position: sticky;
                top: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }

            code {
                background-color: var(--vscode-textBlockQuote-background);
                color: var(--vscode-editor-foreground);
                padding: 2px 4px;
                border-radius: 3px;
                font-family: monospace;
                font-size: 11px;
            }
        </style>
        <title>Variables</title>
      </head>
      <body>  
        <h2>Airflow Variables</h2>
        <div class="controls">
            <vscode-button appearance="secondary" id="refresh-variables">Refresh</vscode-button>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>Key</th>
                    <th>Value</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
            ${tableRows || '<tr><td colspan="3" style="text-align:center; padding: 20px; opacity: 0.7;">No variables found</td></tr>'}
            </tbody>
        </table>
      </body>
    </html>
    `;
        return result;
    }
    _escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('VariablesView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('VariablesView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            ui.logToOutput('VariablesView._setWebviewMessageListener Message Received ' + message.command);
            switch (message.command) {
                case "refresh-variables":
                    this.loadData();
                    return;
            }
        }, undefined, this._disposables);
    }
}
exports.VariablesView = VariablesView;


/***/ }),
/* 187 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToConfigsViewTool - Language Model Tool for opening the Configs view
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToConfigsViewTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const ConfigsView_1 = __webpack_require__(188);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToConfigsViewTool - Opens the Configs panel
 */
class GoToConfigsViewTool {
    constructor() { }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: 'Opening Configs View...'
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToConfigsViewTool.invoke');
        try {
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            ConfigsView_1.ConfigsView.render();
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart('✅ Opened Configs View - showing Airflow configuration settings (airflow.cfg)')
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToConfigsViewTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open Configs View: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToConfigsViewTool = GoToConfigsViewTool;


/***/ }),
/* 188 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigsView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const Session_1 = __webpack_require__(5);
const Telemetry_1 = __webpack_require__(9);
class ConfigsView {
    constructor(panel) {
        this._disposables = [];
        ui.logToOutput('ConfigsView.constructor Started');
        Telemetry_1.Telemetry.Current.send('ConfigsView.constructor.called');
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('ConfigsView.constructor Completed');
    }
    async loadData() {
        ui.logToOutput('ConfigsView.loadData Started');
        Telemetry_1.Telemetry.Current.send('ConfigsView.loadData.called');
        const result = await Session_1.Session.Current.Api.getConfig();
        if (result.isSuccessful) {
            this.configJson = result.result;
        }
        await this.renderHtml();
    }
    async renderHtml() {
        ui.logToOutput('ConfigsView.renderHtml Started');
        Telemetry_1.Telemetry.Current.send('ConfigsView.renderHtml.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        ui.logToOutput('ConfigsView.renderHtml Completed');
    }
    static render() {
        ui.logToOutput('ConfigsView.render Started');
        Telemetry_1.Telemetry.Current.send('ConfigsView.render.called');
        if (ConfigsView.Current) {
            ConfigsView.Current._panel.reveal(vscode.ViewColumn.One);
            ConfigsView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("configsView", "Configs", vscode.ViewColumn.One, {
                enableScripts: true,
            });
            ConfigsView.Current = new ConfigsView(panel);
        }
    }
    dispose() {
        ui.logToOutput('ConfigsView.dispose Started');
        Telemetry_1.Telemetry.Current.send('ConfigsView.dispose.called');
        ConfigsView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('ConfigsView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('ConfigsView._getWebviewContent.called');
        const elementsUri = ui.getUri(webview, extensionUri, [
            "node_modules",
            "@vscode-elements",
            "elements",
            "dist",
            "bundled.js",
        ]);
        const mainUri = ui.getUri(webview, extensionUri, ["media", "main.js"]);
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        // Build table rows from config sections
        let tableRows = '';
        if (this.configJson && this.configJson.sections) {
            for (const section of this.configJson.sections) {
                const sectionName = section.name || 'N/A';
                if (section.options && Array.isArray(section.options)) {
                    for (const option of section.options) {
                        const key = option.key || 'N/A';
                        const value = option.value || 'N/A';
                        tableRows += `
                        <tr class="table-row">
                            <td>${this._escapeHtml(sectionName)}</td>
                            <td>${this._escapeHtml(key)}</td>
                            <td><code>${this._escapeHtml(String(value))}</code></td>
                        </tr>`;
                    }
                }
            }
        }
        const result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <script type="module" src="${elementsUri}"></script>
        <script type="module" src="${mainUri}"></script>
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body { 
                padding: var(--spacing-md); 
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0 0 var(--spacing-lg) 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
                border-bottom: 1px solid var(--vscode-widget-border);
                padding-bottom: var(--spacing-md);
            }

            .controls {
                margin-bottom: var(--spacing-lg);
            }

            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                position: sticky;
                top: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }

            code {
                background-color: var(--vscode-textBlockQuote-background);
                color: var(--vscode-editor-foreground);
                padding: 2px 4px;
                border-radius: 3px;
                font-family: monospace;
                font-size: 11px;
            }
        </style>
        <title>Configs</title>
      </head>
      <body>  
        <h2>Airflow Configuration</h2>
        <div class="controls">
            <vscode-button appearance="secondary" id="refresh-configs">Refresh</vscode-button>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>Section</th>
                    <th>Key</th>
                    <th>Value</th>
                </tr>
            </thead>
            <tbody>
            ${tableRows}
            </tbody>
        </table>
      </body>
    </html>
    `;
        return result;
    }
    _escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('ConfigsView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('ConfigsView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            ui.logToOutput('ConfigsView._setWebviewMessageListener Message Received ' + message.command);
            switch (message.command) {
                case "refresh-configs":
                    this.loadData();
                    return;
            }
        }, undefined, this._disposables);
    }
}
exports.ConfigsView = ConfigsView;


/***/ }),
/* 189 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToPluginsViewTool - Language Model Tool for opening the Plugins view
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToPluginsViewTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const PluginsView_1 = __webpack_require__(190);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToPluginsViewTool - Opens the Plugins panel
 */
class GoToPluginsViewTool {
    constructor() { }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: 'Opening Plugins View...'
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToPluginsViewTool.invoke');
        try {
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            PluginsView_1.PluginsView.render();
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart('✅ Opened Plugins View - showing installed Airflow plugins')
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToPluginsViewTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open Plugins View: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToPluginsViewTool = GoToPluginsViewTool;


/***/ }),
/* 190 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginsView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const Session_1 = __webpack_require__(5);
const Telemetry_1 = __webpack_require__(9);
class PluginsView {
    constructor(panel) {
        this._disposables = [];
        ui.logToOutput('PluginsView.constructor Started');
        Telemetry_1.Telemetry.Current.send('PluginsView.constructor.called');
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('PluginsView.constructor Completed');
    }
    async loadData() {
        ui.logToOutput('PluginsView.loadData Started');
        Telemetry_1.Telemetry.Current.send('PluginsView.loadData.called');
        const result = await Session_1.Session.Current.Api.getPlugins();
        if (result.isSuccessful) {
            this.pluginsJson = result.result;
        }
        await this.renderHtml();
    }
    async renderHtml() {
        ui.logToOutput('PluginsView.renderHtml Started');
        Telemetry_1.Telemetry.Current.send('PluginsView.renderHtml.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        ui.logToOutput('PluginsView.renderHtml Completed');
    }
    static render() {
        ui.logToOutput('PluginsView.render Started');
        Telemetry_1.Telemetry.Current.send('PluginsView.render.called');
        if (PluginsView.Current) {
            PluginsView.Current._panel.reveal(vscode.ViewColumn.One);
            PluginsView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("pluginsView", "Plugins", vscode.ViewColumn.One, {
                enableScripts: true,
            });
            PluginsView.Current = new PluginsView(panel);
        }
    }
    dispose() {
        ui.logToOutput('PluginsView.dispose Started');
        Telemetry_1.Telemetry.Current.send('PluginsView.dispose.called');
        PluginsView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('PluginsView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('PluginsView._getWebviewContent.called');
        const elementsUri = ui.getUri(webview, extensionUri, [
            "node_modules",
            "@vscode-elements",
            "elements",
            "dist",
            "bundled.js",
        ]);
        const mainUri = ui.getUri(webview, extensionUri, ["media", "main.js"]);
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        // Build table rows from plugins data
        let tableRows = '';
        if (this.pluginsJson && this.pluginsJson.plugins) {
            for (const plugin of this.pluginsJson.plugins) {
                const name = plugin.name || 'N/A';
                const hooks = plugin.hooks && plugin.hooks.length > 0 ? plugin.hooks.join(', ') : 'None';
                const executors = plugin.executors && plugin.executors.length > 0 ? plugin.executors.join(', ') : 'None';
                const macros = plugin.macros && plugin.macros.length > 0 ? plugin.macros.map((m) => m.name).join(', ') : 'None';
                tableRows += `
                <tr class="table-row">
                    <td>${this._escapeHtml(name)}</td>
                    <td>${this._escapeHtml(hooks)}</td>
                    <td>${this._escapeHtml(executors)}</td>
                    <td>${this._escapeHtml(macros)}</td>
                </tr>`;
            }
        }
        const result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <script type="module" src="${elementsUri}"></script>
        <script type="module" src="${mainUri}"></script>
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body { 
                padding: var(--spacing-md); 
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0 0 var(--spacing-lg) 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
                border-bottom: 1px solid var(--vscode-widget-border);
                padding-bottom: var(--spacing-md);
            }

            .controls {
                margin-bottom: var(--spacing-lg);
            }

            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                position: sticky;
                top: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }
        </style>
        <title>Plugins</title>
      </head>
      <body>  
        <h2>Airflow Plugins</h2>
        <div class="controls">
            <vscode-button appearance="secondary" id="refresh-plugins">Refresh</vscode-button>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Hooks</th>
                    <th>Executors</th>
                    <th>Macros</th>
                </tr>
            </thead>
            <tbody>
            ${tableRows || '<tr><td colspan="4" style="text-align:center; padding: 20px; opacity: 0.7;">No plugins found</td></tr>'}
            </tbody>
        </table>
      </body>
    </html>
    `;
        return result;
    }
    _escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('PluginsView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('PluginsView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            ui.logToOutput('PluginsView._setWebviewMessageListener Message Received ' + message.command);
            switch (message.command) {
                case "refresh-plugins":
                    this.loadData();
                    return;
            }
        }, undefined, this._disposables);
    }
}
exports.PluginsView = PluginsView;


/***/ }),
/* 191 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * GoToServerHealthViewTool - Language Model Tool for opening the Server Health view
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToServerHealthViewTool = void 0;
const vscode = __webpack_require__(1);
const Session_1 = __webpack_require__(5);
const ServerHealthView_1 = __webpack_require__(192);
const Telemetry_1 = __webpack_require__(9);
/**
 * GoToServerHealthViewTool - Opens the Server Health panel
 */
class GoToServerHealthViewTool {
    constructor() { }
    async prepareInvocation(options, token) {
        return {
            invocationMessage: 'Opening Server Health View...'
        };
    }
    async invoke(options, token) {
        // Track tool invocation
        Telemetry_1.Telemetry.Current.send('GoToServerHealthViewTool.invoke');
        try {
            if (!Session_1.Session.Current.Api) {
                return new vscode.LanguageModelToolResult([
                    new vscode.LanguageModelTextPart('❌ Not connected to an Airflow server. Please connect to a server first.')
                ]);
            }
            ServerHealthView_1.ServerHealthView.render();
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart('✅ Opened Server Health View - showing Airflow server health status, scheduler status, and metadata database status')
            ]);
        }
        catch (error) {
            // Track invocation error
            Telemetry_1.Telemetry.Current.sendError('GoToServerHealthViewTool.invocationError', error instanceof Error ? error : new Error(String(error)));
            return new vscode.LanguageModelToolResult([
                new vscode.LanguageModelTextPart(`❌ Failed to open Server Health View: ${error instanceof Error ? error.message : String(error)}`)
            ]);
        }
    }
}
exports.GoToServerHealthViewTool = GoToServerHealthViewTool;


/***/ }),
/* 192 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerHealthView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const Session_1 = __webpack_require__(5);
const Telemetry_1 = __webpack_require__(9);
class ServerHealthView {
    constructor(panel) {
        this._disposables = [];
        ui.logToOutput('ServerHealthView.constructor Started');
        Telemetry_1.Telemetry.Current.send('ServerHealthView.constructor.called');
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('ServerHealthView.constructor Completed');
    }
    async loadData() {
        ui.logToOutput('ServerHealthView.loadData Started');
        Telemetry_1.Telemetry.Current.send('ServerHealthView.loadData.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        const result = await Session_1.Session.Current.Api.getHealth();
        if (result.isSuccessful) {
            this.healthJson = result.result;
        }
        await this.renderHtml();
    }
    async renderHtml() {
        ui.logToOutput('ServerHealthView.renderHtml Started');
        Telemetry_1.Telemetry.Current.send('ServerHealthView.renderHtml.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        ui.logToOutput('ServerHealthView.renderHtml Completed');
    }
    static render() {
        ui.logToOutput('ServerHealthView.render Started');
        Telemetry_1.Telemetry.Current.send('ServerHealthView.render.called');
        if (ServerHealthView.Current) {
            ServerHealthView.Current._panel.reveal(vscode.ViewColumn.One);
            ServerHealthView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("serverHealthView", "Server Health", vscode.ViewColumn.One, {
                enableScripts: true,
            });
            ServerHealthView.Current = new ServerHealthView(panel);
        }
    }
    dispose() {
        ui.logToOutput('ServerHealthView.dispose Started');
        Telemetry_1.Telemetry.Current.send('ServerHealthView.dispose.called');
        ServerHealthView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('ServerHealthView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('ServerHealthView._getWebviewContent.called');
        const elementsUri = ui.getUri(webview, extensionUri, [
            "node_modules",
            "@vscode-elements",
            "elements",
            "dist",
            "bundled.js",
        ]);
        const mainUri = ui.getUri(webview, extensionUri, ["media", "main.js"]);
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        // Build table rows from health data
        let tableRows = '';
        if (this.healthJson) {
            // Metadatabase status
            if (this.healthJson.metadatabase) {
                const status = this.healthJson.metadatabase.status || 'N/A';
                const emoji = this._getHealthEmoji(status);
                tableRows += `
                <tr class="table-row">
                    <td>Metadatabase</td>
                    <td>${emoji} ${this._escapeHtml(status)}</td>
                </tr>`;
            }
            // Scheduler status
            if (this.healthJson.scheduler) {
                const status = this.healthJson.scheduler.status || 'N/A';
                const latestHeartbeat = ui.toISODateTimeString(new Date(this.healthJson.scheduler.latest_scheduler_heartbeat)) || 'N/A';
                const emoji = this._getHealthEmoji(status);
                tableRows += `
                <tr class="table-row">
                    <td>Scheduler</td>
                    <td>${emoji} ${this._escapeHtml(status)}</td>
                </tr>`;
                if (latestHeartbeat !== 'N/A') {
                    tableRows += `
                    <tr class="table-row">
                        <td>Latest Scheduler Heartbeat</td>
                        <td>${this._escapeHtml(latestHeartbeat)}</td>
                    </tr>`;
                }
            }
            // Triggerer status
            if (this.healthJson.triggerer) {
                const status = this.healthJson.triggerer.status || 'N/A';
                const latestHeartbeat = ui.toISODateTimeString(new Date(this.healthJson.triggerer.latest_triggerer_heartbeat)) || 'N/A';
                const emoji = this._getHealthEmoji(status);
                tableRows += `
                <tr class="table-row">
                    <td>Triggerer</td>
                    <td>${emoji} ${this._escapeHtml(status)}</td>
                </tr>`;
                if (latestHeartbeat !== 'N/A') {
                    tableRows += `
                    <tr class="table-row">
                        <td>Latest Triggerer Heartbeat</td>
                        <td>${this._escapeHtml(latestHeartbeat)}</td>
                    </tr>`;
                }
            }
            // Dag Processor status
            if (this.healthJson.dag_processor) {
                const status = this.healthJson.dag_processor.status || 'N/A';
                const latestHeartbeat = ui.toISODateTimeString(new Date(this.healthJson.dag_processor.latest_dag_processor_heartbeat)) || 'N/A';
                const emoji = this._getHealthEmoji(status);
                tableRows += `
                <tr class="table-row">
                    <td>DAG Processor</td>
                    <td>${emoji} ${this._escapeHtml(status)}</td>
                </tr>`;
                if (latestHeartbeat !== 'N/A') {
                    tableRows += `
                    <tr class="table-row">
                        <td>Latest DAG Processor Heartbeat</td>
                        <td>${this._escapeHtml(latestHeartbeat)}</td>
                    </tr>`;
                }
            }
        }
        const result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <script type="module" src="${elementsUri}"></script>
        <script type="module" src="${mainUri}"></script>
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body { 
                padding: var(--spacing-md); 
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0 0 var(--spacing-lg) 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
                border-bottom: 1px solid var(--vscode-widget-border);
                padding-bottom: var(--spacing-md);
            }

            h3 {
                font-size: var(--font-size-md);
                color: var(--vscode-descriptionForeground);
                margin-top: -16px;
                margin-bottom: var(--spacing-lg);
                font-weight: normal;
            }

            .controls {
                margin-bottom: var(--spacing-lg);
            }

            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                position: sticky;
                top: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }
        </style>
        <title>Server Health</title>
      </head>
      <body>  
        <h2>Server Health</h2>
        <h3>${Session_1.Session.Current.Server?.apiUrl}</h3>
        <div class="controls">
            <vscode-button id="refresh-btn" appearance="secondary">Refresh</vscode-button>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>Component</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
            ${tableRows || '<tr><td colspan="2" style="text-align:center; padding: 20px; opacity: 0.7;">No health data available</td></tr>'}        
            </tbody>
        </table>

        <script>
            const vscode = acquireVsCodeApi();

            document.getElementById('refresh-btn').addEventListener('click', () => {
                vscode.postMessage({ command: 'refresh' });
            });
        </script>
      </body>
    </html>
    `;
        return result;
    }
    _escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    _getHealthEmoji(status) {
        const statusLower = status.toLowerCase();
        if (statusLower === 'healthy') {
            return '✅';
        }
        else if (statusLower === 'unhealthy') {
            return '❌';
        }
        return '⚠️';
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('ServerHealthView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('ServerHealthView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            ui.logToOutput('ServerHealthView._setWebviewMessageListener Message Received ' + message.command);
            switch (message.command) {
                case "refresh":
                    this.loadData();
                    return;
            }
        }, undefined, this._disposables);
    }
}
exports.ServerHealthView = ServerHealthView;


/***/ }),
/* 193 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DailyDagRunView = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const DagView_1 = __webpack_require__(158);
const Session_1 = __webpack_require__(5);
const DagLogView_1 = __webpack_require__(178);
const Telemetry_1 = __webpack_require__(9);
class DailyDagRunView {
    constructor(panel) {
        this._disposables = [];
        // Filters
        this.selectedDate = ui.toISODateString(new Date());
        this.selectedStatus = '';
        this.selectedDagId = '';
        this.allDagIds = [];
        ui.logToOutput('DailyDagRunView.constructor Started');
        Telemetry_1.Telemetry.Current.send('DailyDagRunView.constructor.called');
        this._panel = panel;
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._setWebviewMessageListener(this._panel.webview);
        this.loadData();
        ui.logToOutput('DailyDagRunView.constructor Completed');
    }
    async loadData() {
        ui.logToOutput('DailyDagRunView.loadData Started');
        Telemetry_1.Telemetry.Current.send('DailyDagRunView.loadData.called');
        if (!Session_1.Session.Current.Api) {
            return;
        }
        // Fetch all DAGs to populate dag_id filter
        const dagsResult = await Session_1.Session.Current.Api.getDagList();
        if (dagsResult.isSuccessful && Array.isArray(dagsResult.result)) {
            this.allDagIds = dagsResult.result.map((dag) => dag.dag_id).sort();
        }
        // Fetch DAG runs for the selected date
        // If a specific DAG is selected, query that DAG, otherwise query all
        if (this.selectedDagId) {
            const result = await Session_1.Session.Current.Api.getDagRunHistory(this.selectedDagId, this.selectedDate);
            if (result.isSuccessful && result.result && result.result.dag_runs) {
                this.dagRunsJson = result.result.dag_runs;
            }
        }
        else {
            // Query all DAGs for runs on the selected date
            const allRuns = [];
            for (const dagId of this.allDagIds) {
                const result = await Session_1.Session.Current.Api.getDagRunHistory(dagId, this.selectedDate);
                if (result.isSuccessful && result.result && result.result.dag_runs) {
                    allRuns.push(...result.result.dag_runs);
                }
            }
            this.dagRunsJson = allRuns;
        }
        await this.renderHtml();
    }
    async renderHtml() {
        ui.logToOutput('DailyDagRunView.renderHtml Started');
        Telemetry_1.Telemetry.Current.send('DailyDagRunView.renderHtml.called');
        this._panel.webview.html = this._getWebviewContent(this._panel.webview, Session_1.Session.Current.ExtensionUri);
        ui.logToOutput('DailyDagRunView.renderHtml Completed');
    }
    static render() {
        ui.logToOutput('DailyDagRunView.render Started');
        Telemetry_1.Telemetry.Current.send('DailyDagRunView.render.called');
        if (DailyDagRunView.Current) {
            DailyDagRunView.Current._panel.reveal(vscode.ViewColumn.One);
            DailyDagRunView.Current.loadData();
        }
        else {
            const panel = vscode.window.createWebviewPanel("dailyDagRunView", "Daily DAG Runs", vscode.ViewColumn.One, {
                enableScripts: true,
            });
            DailyDagRunView.Current = new DailyDagRunView(panel);
        }
    }
    dispose() {
        ui.logToOutput('DailyDagRunView.dispose Started');
        Telemetry_1.Telemetry.Current.send('DailyDagRunView.dispose.called');
        DailyDagRunView.Current = undefined;
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
    _getWebviewContent(webview, extensionUri) {
        ui.logToOutput('DailyDagRunView._getWebviewContent Started');
        Telemetry_1.Telemetry.Current.send('DailyDagRunView._getWebviewContent.called');
        const styleUri = ui.getUri(webview, extensionUri, ["media", "style.css"]);
        // Filter DAG runs based on selected filters
        let filteredRuns = [];
        if (this.dagRunsJson && Array.isArray(this.dagRunsJson)) {
            filteredRuns = this.dagRunsJson.filter((run) => {
                // Filter by status
                if (this.selectedStatus && run.state !== this.selectedStatus) {
                    return false;
                }
                return true;
            });
        }
        // Build table rows
        let tableRows = '';
        filteredRuns.forEach((run) => {
            const dagId = run.dag_id || 'N/A';
            const status = run.state || 'N/A';
            const startDate = run.start_date ? ui.toISODateTimeString(new Date(run.start_date)) : 'N/A';
            const duration = run.start_date && run.end_date ? ui.getDuration(new Date(run.start_date), new Date(run.end_date)) : 'Running';
            const config = run.conf ? JSON.stringify(run.conf) : '{}';
            const note = run.note || '';
            const dagRunId = run.dag_run_id || '';
            tableRows += `
            <tr class="table-row">
                <td><a href="#" data-dag-id="${this._escapeHtml(dagId)}" data-dag-run-id="${this._escapeHtml(dagRunId)}" class="dag-link">${this._escapeHtml(dagId)}</a></td>
                <td>
                    <div style="display: flex; align-items: center;">
                        <div class="state-indicator state-${status}" title="${this._escapeHtml(status)}"></div>
                        <span>${this._escapeHtml(status)}</span>
                    </div>
                </td>
                <td>
                    <div class="action-links">
                        <a href="#" data-dag-id="${this._escapeHtml(dagId)}" data-dag-run-id="${this._escapeHtml(dagRunId)}" class="dag-log-link link-button">Logs</a>
                    </div>
                </td>
                <td>${this._escapeHtml(startDate)}</td>
                <td><span class="duration-badge">${this._escapeHtml(duration)}</span></td>
                <td><div class="code-block" style="max-height: 50px; overflow: hidden; font-size: 11px;">${this._escapeHtml(config)}</div></td>
                <td>${this._escapeHtml(note)}</td>
            </tr>`;
        });
        // Build dag_id filter options
        const dagIdOptions = this.allDagIds.map(id => `<option value="${this._escapeHtml(id)}">${this._escapeHtml(id)}</option>`).join('');
        const result = /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <link rel="stylesheet" href="${styleUri}">
        <style>
            :root {
                --font-size-sm: 12px;
                --font-size-md: 13px;
                --font-size-lg: 15px;
                --border-radius: 4px;
                --spacing-xs: 4px;
                --spacing-sm: 8px;
                --spacing-md: 16px;
                --spacing-lg: 24px;
            }

            body {
                padding: var(--spacing-md);
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
            }

            h2 {
                margin: 0 0 var(--spacing-lg) 0;
                font-size: 18px;
                font-weight: 600;
                color: var(--vscode-editor-foreground);
                border-bottom: 1px solid var(--vscode-widget-border);
                padding-bottom: var(--spacing-md);
            }

            /* Filters */
            .filters {
                display: flex;
                gap: var(--spacing-md);
                margin-bottom: var(--spacing-lg);
                flex-wrap: wrap;
                align-items: flex-end;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                padding: var(--spacing-md);
                border-radius: var(--border-radius);
            }
            .filter-group {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }
            .filter-group label {
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                color: var(--vscode-descriptionForeground);
            }
            .filter-group select,
            .filter-group input {
                padding: 6px 8px;
                border: 1px solid var(--vscode-input-border);
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border-radius: 4px;
                font-size: 13px;
                min-width: 150px;
            }

            /* Tables */
            table {
                width: 100%;
                border-collapse: separate;
                border-spacing: 0;
                margin-bottom: var(--spacing-lg);
                font-size: var(--font-size-md);
            }

            th, td {
                padding: 5px 8px;
                text-align: left;
                border-bottom: 1px solid var(--vscode-widget-border);
            }

            th {
                font-weight: 600;
                color: var(--vscode-descriptionForeground);
                text-transform: uppercase;
                font-size: 11px;
                letter-spacing: 0.5px;
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                position: sticky;
                top: 0;
            }

            tr:last-child td {
                border-bottom: none;
            }

            .table-row:hover td {
                background-color: var(--vscode-list-hoverBackground);
            }

            /* States */
            .state-indicator {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                margin-right: 8px;
                display: inline-block;
            }
            
            .state-success { background-color: var(--vscode-testing-iconPassed); }
            .state-failed { background-color: var(--vscode-errorForeground); }
            .state-running { background-color: var(--vscode-charts-blue); }
            .state-queued { background-color: var(--vscode-charts-yellow); }
            .state-upstream_failed { background-color: var(--vscode-charts-orange); }
            .state-skipped { background-color: var(--vscode-disabledForeground); }
            .state-deferred { background-color: var(--vscode-charts-purple); }

            a {
                color: var(--vscode-textLink-foreground);
                text-decoration: none;
                cursor: pointer;
            }
            a:hover {
                text-decoration: underline;
                color: var(--vscode-textLink-activeForeground);
            }

            .duration-badge {
                font-family: 'Courier New', monospace;
                font-size: 12px;
                opacity: 0.8;
            }

            .code-block {
                font-family: var(--vscode-editor-font-family);
                background-color: var(--vscode-textBlockQuote-background);
                padding: 4px;
                border-radius: 4px;
            }
        </style>
        <title>Daily DAG Runs</title>
      </head>
      <body>  
        <h2>Daily DAG Runs</h2>
        
        <div class="filters">
            <div class="filter-group">
                <label>Date</label>
                <input type="date" id="filter-date" value="${this.selectedDate}">
            </div>
            <div class="filter-group">
                <label>Status</label>
                <select id="filter-status">
                    <option value="">All</option>
                    <option value="success">Success</option>
                    <option value="failed">Failed</option>
                    <option value="running">Running</option>
                    <option value="queued">Queued</option>
                    <option value="upstream_failed">Upstream Failed</option>
                </select>
            </div>
            <div class="filter-group">
                <label>DAG ID</label>
                <select id="filter-dag-id">
                    <option value="">All DAGs</option>
                    ${dagIdOptions}
                </select>
            </div>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>DAG ID</th>
                    <th>Status</th>
                    <th>Actions</th>
                    <th>Start Date</th>
                    <th>Duration</th>
                    <th>Config</th>
                    <th>Note</th>
                </tr>
            </thead>
            <tbody>
            ${tableRows || '<tr><td colspan="7" style="text-align:center; padding: 20px; opacity: 0.7;">No runs found for the selected filters</td></tr>'}        
            </tbody>
        </table>

        <script>
            const vscode = acquireVsCodeApi();

            document.getElementById('filter-date').addEventListener('change', (e) => {
                vscode.postMessage({ command: 'filter-date', date: e.target.value });
            });

            document.getElementById('filter-status').addEventListener('change', (e) => {
                vscode.postMessage({ command: 'filter-status', status: e.target.value });
            });

            document.getElementById('filter-dag-id').addEventListener('change', (e) => {
                vscode.postMessage({ command: 'filter-dag-id', dagId: e.target.value });
            });

            // Handle dag-link clicks
            document.querySelectorAll('.dag-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    // Handle clicks on child elements
                    const target = e.target.closest('a') || e.target;
                    const dagId = target.getAttribute('data-dag-id');
                    const dagRunId = target.getAttribute('data-dag-run-id');
                    vscode.postMessage({ command: 'open-dag-view', dagId, dagRunId });
                });
            });

            // Handle dag-log-link clicks
            document.querySelectorAll('.dag-log-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const target = e.target.closest('a') || e.target;
                    const dagId = target.getAttribute('data-dag-id');
                    const dagRunId = target.getAttribute('data-dag-run-id');
                    vscode.postMessage({ command: 'view-dag-log', dagId, dagRunId });
                });
            });
        </script>
      </body>
    </html>
    `;
        return result;
    }
    _escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }
    _getStatusEmoji(status) {
        const statusMap = {
            'success': '✅',
            'failed': '❌',
            'running': '▶️',
            'queued': '⏳',
            'upstream_failed': '⚠️',
            'skipped': '⏭️',
            'deferred': '🔄'
        };
        return statusMap[status.toLowerCase()] || '📅';
    }
    _setWebviewMessageListener(webview) {
        ui.logToOutput('DailyDagRunView._setWebviewMessageListener Started');
        Telemetry_1.Telemetry.Current.send('DailyDagRunView._setWebviewMessageListener.called');
        webview.onDidReceiveMessage((message) => {
            ui.logToOutput('DailyDagRunView._setWebviewMessageListener Message Received ' + message.command);
            switch (message.command) {
                case "filter-date":
                    this.selectedDate = message.date;
                    this.loadData();
                    return;
                case "filter-status":
                    this.selectedStatus = message.status;
                    this.renderHtml();
                    return;
                case "filter-dag-id":
                    this.selectedDagId = message.dagId;
                    this.loadData();
                    return;
                case "open-dag-view":
                    // Open DagView with specific dag and run
                    if (Session_1.Session.Current.Api && message.dagId) {
                        DagView_1.DagView.render(message.dagId, message.dagRunId);
                    }
                    return;
                case "view-dag-log":
                    if (message.dagId) {
                        DagLogView_1.DagLogView.render(message.dagId, message.dagRunId);
                    }
                    return;
            }
        }, undefined, this._disposables);
    }
}
exports.DailyDagRunView = DailyDagRunView;


/***/ }),
/* 194 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminTreeView = void 0;
const vscode = __webpack_require__(1);
const AdminTreeItem_1 = __webpack_require__(195);
const Telemetry_1 = __webpack_require__(9);
class AdminTreeView {
    constructor() {
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        Telemetry_1.Telemetry.Current.send('AdminTreeViewInitialized');
    }
    refresh() {
        this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (!element) {
            // Root level - return the admin nodes
            return Promise.resolve([
                new AdminTreeItem_1.AdminTreeItem('Variables', vscode.TreeItemCollapsibleState.None, {
                    command: 'dagTreeView.viewVariables',
                    title: 'View Variables',
                    arguments: []
                }, new vscode.ThemeIcon('symbol-variable')),
                new AdminTreeItem_1.AdminTreeItem('Connections', vscode.TreeItemCollapsibleState.None, {
                    command: 'dagTreeView.viewConnections',
                    title: 'View Connections',
                    arguments: []
                }, new vscode.ThemeIcon('link')),
                new AdminTreeItem_1.AdminTreeItem('Providers', vscode.TreeItemCollapsibleState.None, {
                    command: 'dagTreeView.viewProviders',
                    title: 'View Providers',
                    arguments: []
                }, new vscode.ThemeIcon('package')),
                new AdminTreeItem_1.AdminTreeItem('Configs', vscode.TreeItemCollapsibleState.None, {
                    command: 'dagTreeView.viewConfigs',
                    title: 'View Configs',
                    arguments: []
                }, new vscode.ThemeIcon('settings-gear')),
                new AdminTreeItem_1.AdminTreeItem('Plugins', vscode.TreeItemCollapsibleState.None, {
                    command: 'dagTreeView.viewPlugins',
                    title: 'View Plugins',
                    arguments: []
                }, new vscode.ThemeIcon('extensions')),
                new AdminTreeItem_1.AdminTreeItem('Server Health', vscode.TreeItemCollapsibleState.None, {
                    command: 'dagTreeView.viewServerHealth',
                    title: 'View Server Health',
                    arguments: []
                }, new vscode.ThemeIcon('pulse'))
            ]);
        }
        return Promise.resolve([]);
    }
}
exports.AdminTreeView = AdminTreeView;


/***/ }),
/* 195 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminTreeItem = void 0;
const vscode = __webpack_require__(1);
class AdminTreeItem extends vscode.TreeItem {
    constructor(label, collapsibleState, command, iconPath) {
        super(label, collapsibleState);
        this.label = label;
        this.collapsibleState = collapsibleState;
        this.command = command;
        this.iconPath = iconPath;
        this.command = command;
        this.iconPath = iconPath;
    }
}
exports.AdminTreeItem = AdminTreeItem;


/***/ }),
/* 196 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReportTreeView = void 0;
const vscode = __webpack_require__(1);
const ReportTreeItem_1 = __webpack_require__(197);
const Telemetry_1 = __webpack_require__(9);
class ReportTreeView {
    constructor() {
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        Telemetry_1.Telemetry.Current.send('ReportTreeView.constructor.called');
    }
    refresh() {
        Telemetry_1.Telemetry.Current.send('ReportTreeView.refresh.called');
        this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (!element) {
            // Root level - return the report nodes
            return Promise.resolve([
                new ReportTreeItem_1.ReportTreeItem('Daily DAG Runs', vscode.TreeItemCollapsibleState.None, {
                    command: 'dagTreeView.viewDagRuns',
                    title: 'View Daily DAG Runs',
                    arguments: []
                }, new vscode.ThemeIcon('list-selection')),
                new ReportTreeItem_1.ReportTreeItem('DAG Run History', vscode.TreeItemCollapsibleState.None, {
                    command: 'dagTreeView.viewDagRunHistory',
                    title: 'View DAG Run History',
                    arguments: []
                }, new vscode.ThemeIcon('history'))
            ]);
        }
        return Promise.resolve([]);
    }
}
exports.ReportTreeView = ReportTreeView;


/***/ }),
/* 197 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReportTreeItem = void 0;
const vscode = __webpack_require__(1);
class ReportTreeItem extends vscode.TreeItem {
    constructor(label, collapsibleState, command, iconPath) {
        super(label, collapsibleState);
        this.label = label;
        this.collapsibleState = collapsibleState;
        this.command = command;
        this.iconPath = iconPath;
        this.command = command;
        this.iconPath = iconPath;
    }
}
exports.ReportTreeItem = ReportTreeItem;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".extension.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			0: 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					var installedChunk = require("./" + __webpack_require__.u(chunkId));
/******/ 					if (!installedChunks[chunkId]) {
/******/ 						installChunk(installedChunk);
/******/ 					}
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.activate = activate;
exports.deactivate = deactivate;
// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
const vscode = __webpack_require__(1);
const ui = __webpack_require__(2);
const Session_1 = __webpack_require__(5);
const DagTreeView_1 = __webpack_require__(153);
const AdminTreeView_1 = __webpack_require__(194);
const ReportTreeView_1 = __webpack_require__(196);
const AIHandler_1 = __webpack_require__(160);
const Telemetry_1 = __webpack_require__(9);
const os_1 = __webpack_require__(12);
// this method is called when your extension is activated
// your extension is activated the very first time the command is executed
function activate(context) {
    ui.logToOutput('Extension activation started');
    new Telemetry_1.Telemetry(context);
    const properties = {
        extensionVersion: context.extension.packageJSON.version,
        vscodeVersion: vscode.version,
        osVersion: (0, os_1.version)(),
        platform: process.platform,
        appName: vscode.env.appName,
        appHost: vscode.env.appHost,
        language: vscode.env.language
    };
    Telemetry_1.Telemetry.Current.send('extension.activate.called', properties);
    new Session_1.Session(context);
    new AIHandler_1.AIHandler();
    let dagTreeView = new DagTreeView_1.DagTreeView();
    let adminTreeView = new AdminTreeView_1.AdminTreeView();
    let reportTreeView = new ReportTreeView_1.ReportTreeView();
    // Register the Admin Tree View
    vscode.window.registerTreeDataProvider('adminTreeView', adminTreeView);
    ui.logToOutput('Admin Tree View registered');
    // Register the Report Tree View
    vscode.window.registerTreeDataProvider('reportTreeView', reportTreeView);
    ui.logToOutput('Report Tree View registered');
    // register commands and keep disposables so they are cleaned up on deactivate
    const commands = [];
    commands.push(vscode.commands.registerCommand('dagTreeView.refreshServer', () => { dagTreeView.refresh(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.addServer', () => { dagTreeView.addServer(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.removeServer', () => { dagTreeView.removeServer(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.connectServer', () => { dagTreeView.connectServer(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.clearServers', () => { dagTreeView.clearServers(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.filter', () => { dagTreeView.filter(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.showOnlyActive', () => { dagTreeView.showOnlyActive(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.showOnlyFavorite', () => { dagTreeView.showOnlyFavorite(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewDagView', (node) => { dagTreeView.viewDagView(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.triggerDag', (node) => { dagTreeView.triggerDag(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.triggerDagWithConfig', (node) => { dagTreeView.triggerDagWConfig(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.checkDagRunState', (node) => { dagTreeView.checkDagRunState(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.checkAllDagsRunState', () => { dagTreeView.checkAllDagsRunState(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.pauseDAG', (node) => { dagTreeView.pauseDAG(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.unPauseDAG', (node) => { dagTreeView.unPauseDAG(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.cancelDagRun', (node) => { dagTreeView.cancelDagRun(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.lastDAGRunLog', (node) => { dagTreeView.lastDAGRunLog(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.dagSourceCode', (node) => { dagTreeView.dagSourceCode(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.showDagInfo', (node) => { dagTreeView.showDagInfo(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.addToFavDAG', (node) => { dagTreeView.addToFavDAG(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.deleteFromFavDAG', (node) => { dagTreeView.deleteFromFavDAG(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.showDagView', (node) => { dagTreeView.viewDagView(node); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewConnections', () => { dagTreeView.viewConnections(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewVariables', () => { dagTreeView.viewVariables(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewProviders', () => { dagTreeView.viewProviders(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewConfigs', () => { dagTreeView.viewConfigs(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewPlugins', () => { dagTreeView.viewPlugins(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewServerHealth', () => { dagTreeView.viewServerHealth(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewDagRuns', () => { dagTreeView.viewDagRuns(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.viewDagRunHistory', () => { dagTreeView.viewDagRunHistory(); }));
    commands.push(vscode.commands.registerCommand('dagTreeView.AskAI', (node) => { AIHandler_1.AIHandler.Current.askAI(node.DagId, node.FileToken); }));
    // Support and feedback commands
    commands.push(vscode.commands.registerCommand('airflow-ext.installAirflowSkills', () => {
        const terminal = vscode.window.createTerminal({ name: 'Airflow Skills' });
        terminal.show(false);
        terminal.sendText('echo Installing Airflow Skills...', true);
        // wait for the terminal to be ready before sending the command
        setTimeout(() => {
            terminal.sendText('npx skills add necatiarslan/airflow-vscode-extension --skill "*" -a github-copilot', true);
        }, 5000);
    }));
    commands.push(vscode.commands.registerCommand('airflow-ext.donate', () => { vscode.env.openExternal(vscode.Uri.parse('https://github.com/sponsors/necatiarslan')); }));
    commands.push(vscode.commands.registerCommand('airflow-ext.newFeaturesSurvey', () => { vscode.env.openExternal(vscode.Uri.parse('https://bit.ly/airflow-extension-survey')); }));
    commands.push(vscode.commands.registerCommand('airflow-ext.requestFeature', () => { vscode.env.openExternal(vscode.Uri.parse('https://github.com/necatiarslan/airflow-vscode-extension/issues/new?labels=feature-request&template=feature_request.md')); }));
    commands.push(vscode.commands.registerCommand('airflow-ext.reportBug', () => { vscode.env.openExternal(vscode.Uri.parse('https://github.com/necatiarslan/airflow-vscode-extension/issues/new?labels=bug&template=bug_report.md')); }));
    for (const c of commands) {
        context.subscriptions.push(c);
    }
    AIHandler_1.AIHandler.Current.registerChatParticipant();
    AIHandler_1.AIHandler.Current.registerAiTools();
    Telemetry_1.Telemetry.Current?.send('extension.activated');
    ui.logToOutput('Extension activation completed');
}
// this method is called when your extension is deactivated
function deactivate() {
    ui.logToOutput('Extension is now deactive!');
}

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=extension.js.map